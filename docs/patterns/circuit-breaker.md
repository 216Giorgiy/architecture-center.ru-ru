---
title: Шаблон автоматического выключения
titleSuffix: Cloud Design Patterns
description: Обработка ошибок при подключении к удаленной службе или ресурсу, устранение которых может занять непредсказуемое количество времени.
keywords: Конструктивный шаблон
author: dragon119
ms.date: 06/23/2017
ms.custom: seodec18
ms.openlocfilehash: 56c90fcb23fd68b0d1b545db90adeab3272705c2
ms.sourcegitcommit: 680c9cef945dff6fee5e66b38e24f07804510fa9
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/04/2019
ms.locfileid: "54009769"
---
# <a name="circuit-breaker-pattern"></a><span data-ttu-id="ea6ab-104">Шаблон автоматического выключения</span><span class="sxs-lookup"><span data-stu-id="ea6ab-104">Circuit Breaker pattern</span></span>

<span data-ttu-id="ea6ab-105">Выполняйте обработку ошибок, которая может занять разное количество времени при подключении к удаленной службе или ресурсу.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-105">Handle faults that might take a variable amount of time to recover from, when connecting to a remote service or resource.</span></span> <span data-ttu-id="ea6ab-106">Это может повысить стабильность и устойчивость приложения.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-106">This can improve the stability and resiliency of an application.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="ea6ab-107">Контекст и проблема</span><span class="sxs-lookup"><span data-stu-id="ea6ab-107">Context and problem</span></span>

<span data-ttu-id="ea6ab-108">В распределенной среде вызовы удаленных ресурсов и служб могут завершиться со сбоем из-за временных сбоев, таких как медленные сетевые подключения, длительное время ожидания, перегруженные или временно недоступные ресурсы.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-108">In a distributed environment, calls to remote resources and services can fail due to transient faults, such as slow network connections, timeouts, or the resources being overcommitted or temporarily unavailable.</span></span> <span data-ttu-id="ea6ab-109">Эти ошибки обычно устраняются через короткий промежуток времени. Следует подготовить надежное облачное приложение для их обработки с использованием стратегии, такой как [шаблон повторов][retry-pattern].</span><span class="sxs-lookup"><span data-stu-id="ea6ab-109">These faults typically correct themselves after a short period of time, and a robust cloud application should be prepared to handle them by using a strategy such as the [Retry pattern][retry-pattern].</span></span>

<span data-ttu-id="ea6ab-110">Однако в некоторых ситуациях ошибки возникают из-за непредвиденных событий. На их устранение может потребоваться гораздо больше времени.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-110">However, there can also be situations where faults are due to unanticipated events, and that might take much longer to fix.</span></span> <span data-ttu-id="ea6ab-111">Эти ошибки могут варьироваться по серьезности от частичной потери возможности подключения до полного отказа службы.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-111">These faults can range in severity from a partial loss of connectivity to the complete failure of a service.</span></span> <span data-ttu-id="ea6ab-112">В таких ситуациях приложение, вместо постоянных попыток повторить операцию, которая, скорее всего, не будет успешно выполнена, должно быстро принять сбой операции и обработать его.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-112">In these situations it might be pointless for an application to continually retry an operation that is unlikely to succeed, and instead the application should quickly accept that the operation has failed and handle this failure accordingly.</span></span>

<span data-ttu-id="ea6ab-113">Кроме того, если служба занята, сбой в одной из частей системы может привести к лавинообразному накоплению сбоев.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-113">Additionally, if a service is very busy, failure in one part of the system might lead to cascading failures.</span></span> <span data-ttu-id="ea6ab-114">Например, операция, вызывающая службу, может быть настроена для реализации времени ожидания и будет отвечать сообщением об ошибке, если служба не отвечает в течение этого периода.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-114">For example, an operation that invokes a service could be configured to implement a timeout, and reply with a failure message if the service fails to respond within this period.</span></span> <span data-ttu-id="ea6ab-115">Однако эта стратегия может привести к тому, что многие параллельные запросы к одной операции будут заблокированы до истечения периода ожидания.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-115">However, this strategy could cause many concurrent requests to the same operation to be blocked until the timeout period expires.</span></span> <span data-ttu-id="ea6ab-116">Эти заблокированные запросы могут содержать критические системные ресурсы, такие как память, потоки, подключения к базе данных и т. д.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-116">These blocked requests might hold critical system resources such as memory, threads, database connections, and so on.</span></span> <span data-ttu-id="ea6ab-117">Следовательно, эти ресурсы могут закончиться, что приведет к сбою других, возможно, несвязанных частей системы, которым нужно использовать те же ресурсы.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-117">Consequently, these resources could become exhausted, causing failure of other possibly unrelated parts of the system that need to use the same resources.</span></span> <span data-ttu-id="ea6ab-118">В этих ситуациях предпочтительно, чтобы операция немедленно завершалась с ошибкой и пыталась вызвать службу, только если такой вызов может быть успешно выполнен.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-118">In these situations, it would be preferable for the operation to fail immediately, and only attempt to invoke the service if it's likely to succeed.</span></span> <span data-ttu-id="ea6ab-119">Обратите внимание, установка более короткого времени ожидания может помочь решить эту проблему, но время ожидания не должно быть настолько коротким, чтобы операция завершалась со сбоем в большинстве случаев, даже если запрос к службе в конечном итоге будет успешным.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-119">Note that setting a shorter timeout might help to resolve this problem, but the timeout shouldn't be so short that the operation fails most of the time, even if the request to the service would eventually succeed.</span></span>

## <a name="solution"></a><span data-ttu-id="ea6ab-120">Решение</span><span class="sxs-lookup"><span data-stu-id="ea6ab-120">Solution</span></span>

<span data-ttu-id="ea6ab-121">Шаблон автоматического выключения, популяризированный Майклом Найгардом (Michael Nygard) в книге [Release It! Design and Deploy Production-Ready Software](https://pragprog.com/book/mnee/release-it) (Выпускаем в свет! Разработка и внедрение ПО, готового к выпуску), может помешать повторной попытке приложения выполнить операцию, которая, скорее всего, завершится со сбоем.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-121">The Circuit Breaker pattern, popularized by Michael Nygard in his book, [Release It!](https://pragprog.com/book/mnee/release-it), can prevent an application from repeatedly trying to execute an operation that's likely to fail.</span></span> <span data-ttu-id="ea6ab-122">Разрешите ему продолжить выполнение, не ожидая устранения ошибки или расхода ресурсов процессора на определение того, что предполагается долгий сбой.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-122">Allowing it to continue without waiting for the fault to be fixed or wasting CPU cycles while it determines that the fault is long lasting.</span></span> <span data-ttu-id="ea6ab-123">Шаблон автоматического выключения также позволяет приложению определять, была ли устранена неисправность.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-123">The Circuit Breaker pattern also enables an application to detect whether the fault has been resolved.</span></span> <span data-ttu-id="ea6ab-124">Если проблема устранена, приложение может попытаться вызвать операцию.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-124">If the problem appears to have been fixed, the application can try to invoke the operation.</span></span>

> <span data-ttu-id="ea6ab-125">У шаблона автоматического выключения и шаблона повторов разные цели.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-125">The purpose of the Circuit Breaker pattern is different than the Retry pattern.</span></span> <span data-ttu-id="ea6ab-126">Шаблон повторов позволяет приложению повторять операцию, ожидая, что она будет успешного выполнена.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-126">The Retry pattern enables an application to retry an operation in the expectation that it'll succeed.</span></span> <span data-ttu-id="ea6ab-127">Шаблон автоматического выключения в приложении предотвращает выполнение операции, которая, вероятнее всего, завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-127">The Circuit Breaker pattern prevents an application from performing an operation that is likely to fail.</span></span> <span data-ttu-id="ea6ab-128">Приложение может сочетать оба шаблона, используя шаблон повтора для вызова операции через автоматическое выключение.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-128">An application can combine these two patterns by using the Retry pattern to invoke an operation through a circuit breaker.</span></span> <span data-ttu-id="ea6ab-129">Однако логика повторения должна быть чувствительной к любым исключениям, возвращаемым автоматическим выключением, и отказываться от повторных попыток, если автоматическое выключение указывает, что неисправность не является временной.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-129">However, the retry logic should be sensitive to any exceptions returned by the circuit breaker and abandon retry attempts if the circuit breaker indicates that a fault is not transient.</span></span>

<span data-ttu-id="ea6ab-130">Автоматическое выключение действует в качестве прокси-сервера операций, которые могут завершиться со сбоем.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-130">A circuit breaker acts as a proxy for operations that might fail.</span></span> <span data-ttu-id="ea6ab-131">Прокси-сервер должен отслеживать количество недавних сбоев и использовать эту информацию, чтобы решить, разрешить ли продолжение операции или же немедленно вернуть исключение.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-131">The proxy should monitor the number of recent failures that have occurred, and use this information to decide whether to allow the operation to proceed, or simply return an exception immediately.</span></span>

<span data-ttu-id="ea6ab-132">Прокси-сервер может быть реализован как компьютер со следующими состояниями, имитирующими возможности электрического автоматического выключателя:</span><span class="sxs-lookup"><span data-stu-id="ea6ab-132">The proxy can be implemented as a state machine with the following states that mimic the functionality of an electrical circuit breaker:</span></span>

- <span data-ttu-id="ea6ab-133">**Закрытый**. Запрос приложения перенаправляется на операцию.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-133">**Closed**: The request from the application is routed to the operation.</span></span> <span data-ttu-id="ea6ab-134">Прокси-сервер ведет подсчет числа недавних сбоев, и если вызов операции не завершился успешно, прокси-сервер увеличивает это число.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-134">The proxy maintains a count of the number of recent failures, and if the call to the operation is unsuccessful the proxy increments this count.</span></span> <span data-ttu-id="ea6ab-135">Если число недавних сбоев превышает заданный порог в течение заданного периода времени, прокси-сервер переводится в состояние **Открытый**.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-135">If the number of recent failures exceeds a specified threshold within a given time period, the proxy is placed into the **Open** state.</span></span> <span data-ttu-id="ea6ab-136">На этом этапе прокси-сервер запускает таймер времени ожидания, и по истечении времени этого таймера прокси-сервер переводится в состояние **Полуоткрытый**.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-136">At this point the proxy starts a timeout timer, and when this timer expires the proxy is placed into the **Half-Open** state.</span></span>

    > <span data-ttu-id="ea6ab-137">Цель таймера времени ожидания — дать системе время на исправление ошибки, которая вызвала сбой, прежде чем разрешить приложению попытаться выполнить операцию еще раз.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-137">The purpose of the timeout timer is to give the system time to fix the problem that caused the failure before allowing the application to try to perform the operation again.</span></span>

- <span data-ttu-id="ea6ab-138">**Открыто**. Запрос приложения немедленно завершается со сбоем, и исключение возвращается в приложение.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-138">**Open**: The request from the application fails immediately and an exception is returned to the application.</span></span>

- <span data-ttu-id="ea6ab-139">**Полуоткрытый**. Ограниченному числу запросов от приложения разрешено проходить через операцию и вызывать ее.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-139">**Half-Open**: A limited number of requests from the application are allowed to pass through and invoke the operation.</span></span> <span data-ttu-id="ea6ab-140">Если эти запросы выполняются успешно, предполагается, что ошибка, которая ранее вызывала сбой, устранена, а автоматический выключатель переходит в состояние **Закрытый** (счетчик сбоев сбрасывается).</span><span class="sxs-lookup"><span data-stu-id="ea6ab-140">If these requests are successful, it's assumed that the fault that was previously causing the failure has been fixed and the circuit breaker switches to the **Closed** state (the failure counter is reset).</span></span> <span data-ttu-id="ea6ab-141">Если какой-либо запрос завершается со сбоем, автоматическое выключение предполагает, что неисправность все еще присутствует, поэтому он возвращается в состояние **Открытый** и перезапускает таймер времени ожидания, чтобы дать системе дополнительное время на восстановление после сбоя.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-141">If any request fails, the circuit breaker assumes that the fault is still present so it reverts back to the **Open** state and restarts the timeout timer to give the system a further period of time to recover from the failure.</span></span>

    > <span data-ttu-id="ea6ab-142">Состояние **Полуоткрытый** полезно для предотвращения внезапного переполнения службы восстановления запросами.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-142">The **Half-Open** state is useful to prevent a recovering service from suddenly being flooded with requests.</span></span> <span data-ttu-id="ea6ab-143">По мере восстановления службы она может поддерживать ограниченный объем запросов до полного восстановления, но при восстановлении переполнение может привести к истечению времени ожидания службы или повторному сбою.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-143">As a service recovers, it might be able to support a limited volume of requests until the recovery is complete, but while recovery is in progress a flood of work can cause the service to time out or fail again.</span></span>

![Состояния автоматического выключения](./_images/circuit-breaker-diagram.png)

<span data-ttu-id="ea6ab-145">На рисунке показан счетчик сбоев на основе времени, используемый состоянием **Закрытый**.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-145">In the figure, the failure counter used by the **Closed** state is time based.</span></span> <span data-ttu-id="ea6ab-146">Он сбрасывается через периодические интервалы.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-146">It's automatically reset at periodic intervals.</span></span> <span data-ttu-id="ea6ab-147">Это позволяет предотвратить переход автоматического выключения в состояние **Открытый** при случайных ошибках.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-147">This helps to prevent the circuit breaker from entering the **Open** state if it experiences occasional failures.</span></span> <span data-ttu-id="ea6ab-148">Порог сбоев, который переводит автоматическое выключение в состояние **Открытый**, достигается, только если указанное количество сбоев произошло в течение заданного интервала.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-148">The failure threshold that trips the circuit breaker into the **Open** state is only reached when a specified number of failures have occurred during a specified interval.</span></span> <span data-ttu-id="ea6ab-149">Счетчик, используемый состоянием **Полуоткрытый**, записывает количество успешных попыток вызвать операцию.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-149">The counter used by the **Half-Open** state records the number of successful attempts to invoke the operation.</span></span> <span data-ttu-id="ea6ab-150">Автоматическое выключение возвращается в состояние **Закрытый** после определенного числа последовательных успешных вызовов операций.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-150">The circuit breaker reverts to the **Closed** state after a specified number of consecutive operation invocations have been successful.</span></span> <span data-ttu-id="ea6ab-151">Если вызов завершается со сбоем, автоматическое выключение немедленно переходит в состояние **Открытый**, а счетчик успешных выполнений будет сброшен до следующего раза, когда автоматический выключатель перейдет в состояние **Полуоткрытый**.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-151">If any invocation fails, the circuit breaker enters the **Open** state immediately and the success counter will be reset the next time it enters the **Half-Open** state.</span></span>

> <span data-ttu-id="ea6ab-152">Восстановление системы обрабатывается извне, возможно, путем восстановления или перезапуска неисправного компонента либо исправления сетевого соединения.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-152">How the system recovers is handled externally, possibly by restoring or restarting a failed component or repairing a network connection.</span></span>

<span data-ttu-id="ea6ab-153">Шаблон автоматического выключения обеспечивает стабильность, пока система восстанавливается после сбоя и снижает влияние на производительность.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-153">The Circuit Breaker pattern provides stability while the system recovers from a failure and minimizes the impact on performance.</span></span> <span data-ttu-id="ea6ab-154">Благодаря этому можно поддерживать определенный показатель времени отклика системы, быстро отклоняя запрос на операцию, которая, скорее всего, завершится со сбоем, вместо того чтобы ждать, пока не истечет время ожидания операции, или ждать в течение неопределенного времени (так как операция никогда не возвратится).</span><span class="sxs-lookup"><span data-stu-id="ea6ab-154">It can help to maintain the response time of the system by quickly rejecting a request for an operation that's likely to fail, rather than waiting for the operation to time out, or never return.</span></span> <span data-ttu-id="ea6ab-155">Если автоматическое выключение порождает событие каждый раз, когда оно меняет состояние, эта информация может использоваться для мониторинга работоспособности части системы, защищенной автоматическим выключением, или для оповещения администратора о переходе автоматического выключения в состояние **Открытый**.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-155">If the circuit breaker raises an event each time it changes state, this information can be used to monitor the health of the part of the system protected by the circuit breaker, or to alert an administrator when a circuit breaker trips to the **Open** state.</span></span>

<span data-ttu-id="ea6ab-156">Шаблон настраивается и может быть адаптирован в соответствии с типом возможного сбоя.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-156">The pattern is customizable and can be adapted according to the type of the possible failure.</span></span> <span data-ttu-id="ea6ab-157">Например, вы можете применить таймер увеличения времени ожидания к автоматическому выключателю.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-157">For example, you can apply an increasing timeout timer to a circuit breaker.</span></span> <span data-ttu-id="ea6ab-158">Вы можете перевести автоматическое выключение в состояние **Открытый** на несколько секунд, а затем, если сбой не был устранен, увеличить время ожидания до нескольких минут и так далее.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-158">You could place the circuit breaker in the **Open** state for a few seconds initially, and then if the failure hasn't been resolved increase the timeout to a few minutes, and so on.</span></span> <span data-ttu-id="ea6ab-159">В некоторых случаях вместо состояния **Открытый**, возвращающего сбой и вызывающего исключение, полезнее возвращать значение по умолчанию, которое было значимо для приложения.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-159">In some cases, rather than the **Open** state returning failure and raising an exception, it could be useful to return a default value that is meaningful to the application.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="ea6ab-160">Проблемы и рекомендации</span><span class="sxs-lookup"><span data-stu-id="ea6ab-160">Issues and considerations</span></span>

<span data-ttu-id="ea6ab-161">При выборе схемы реализации этого шаблона следует учитывать следующие моменты.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-161">You should consider the following points when deciding how to implement this pattern:</span></span>

<span data-ttu-id="ea6ab-162">**Обработка исключений.**</span><span class="sxs-lookup"><span data-stu-id="ea6ab-162">**Exception Handling**.</span></span> <span data-ttu-id="ea6ab-163">Приложение, вызывающее операцию через автоматический выключатель, должно быть подготовлено к обработке исключений, возникающих, если операция недоступна.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-163">An application invoking an operation through a circuit breaker must be prepared to handle the exceptions raised if the operation is unavailable.</span></span> <span data-ttu-id="ea6ab-164">Способ обработки исключения будет зависеть от приложения.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-164">The way exceptions are handled will be application specific.</span></span> <span data-ttu-id="ea6ab-165">Например, приложение может временно понизить функциональность, вызвать альтернативную операцию для выполнения той же задачи или получения тех же данных или сообщить об исключении пользователю и попросить его повторить попытку позже.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-165">For example, an application could temporarily degrade its functionality, invoke an alternative operation to try to perform the same task or obtain the same data, or report the exception to the user and ask them to try again later.</span></span>

<span data-ttu-id="ea6ab-166">**Типы исключений.**</span><span class="sxs-lookup"><span data-stu-id="ea6ab-166">**Types of Exceptions**.</span></span> <span data-ttu-id="ea6ab-167">Запрос может завершиться со сбоем по многим причинам. Некоторые из них могут указывать на более серьезные сбои, чем другие.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-167">A request might fail for many reasons, some of which might indicate a more severe type of failure than others.</span></span> <span data-ttu-id="ea6ab-168">Например, запрос может завершиться со сбоем, так как произошло аварийное завершение удаленной службы и требуется несколько минут для восстановления, или из-за истечения времени ожидания в связи с временной перегрузкой службы.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-168">For example, a request might fail because a remote service has crashed and will take several minutes to recover, or because of a timeout due to the service being temporarily overloaded.</span></span> <span data-ttu-id="ea6ab-169">Автоматическое выключение может исследовать типы возникающих исключений и корректировать свою стратегию в зависимости от характера этих исключений.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-169">A circuit breaker might be able to examine the types of exceptions that occur and adjust its strategy depending on the nature of these exceptions.</span></span> <span data-ttu-id="ea6ab-170">Например, может потребоваться большее количество исключений времени ожидания для перевода автоматического выключения в состояние **Открытый** по сравнению с количеством ошибок из-за того, что служба полностью недоступна.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-170">For example, it might require a larger number of timeout exceptions to trip the circuit breaker to the **Open** state compared to the number of failures due to the service being completely unavailable.</span></span>

<span data-ttu-id="ea6ab-171">**Ведение журналов.**</span><span class="sxs-lookup"><span data-stu-id="ea6ab-171">**Logging**.</span></span> <span data-ttu-id="ea6ab-172">При автоматическом выключении должны регистрироваться все невыполненные запросы (и возможно, успешные запросы), чтобы позволить администратору выполнять мониторинг работоспособности операции.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-172">A circuit breaker should log all failed requests (and possibly successful requests) to enable an administrator to monitor the health of the operation.</span></span>

<span data-ttu-id="ea6ab-173">**Возможность восстановления.**</span><span class="sxs-lookup"><span data-stu-id="ea6ab-173">**Recoverability**.</span></span> <span data-ttu-id="ea6ab-174">Автоматическое выключение нужно настроить в соответствии с вероятным шаблоном восстановления защищаемой операции.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-174">You should configure the circuit breaker to match the likely recovery pattern of the operation it's protecting.</span></span> <span data-ttu-id="ea6ab-175">Например, если автоматическое выключение остается в состоянии **Открытый** в течение длительного периода времени, оно может создавать исключения, даже если сбой был устранен.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-175">For example, if the circuit breaker remains in the **Open** state for a long period, it could raise exceptions even if the reason for the failure has been resolved.</span></span> <span data-ttu-id="ea6ab-176">Аналогично автоматическое выключение может меняться и уменьшать время отклика приложений, если оно переключится из состояния **Открытый** в состояние **Полуоткрытый** слишком быстро.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-176">Similarly, a circuit breaker could fluctuate and reduce the response times of applications if it switches from the **Open** state to the **Half-Open** state too quickly.</span></span>

<span data-ttu-id="ea6ab-177">**Тестирование неудачных операций.**</span><span class="sxs-lookup"><span data-stu-id="ea6ab-177">**Testing Failed Operations**.</span></span> <span data-ttu-id="ea6ab-178">В состоянии **Открытый** вместо использования таймера для определения момента перехода в состояние **Полуоткрытый** автоматическое выключение может периодически проверять удаленную службу или ресурс, чтобы определить, когда они снова станут доступны.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-178">In the **Open** state, rather than using a timer to determine when to switch to the **Half-Open** state, a circuit breaker can instead periodically ping the remote service or resource to determine whether it's become available again.</span></span> <span data-ttu-id="ea6ab-179">Проверка связи может принимать форму попытки вызвать операцию, которая ранее завершилась со сбоем, или она может использовать специальную операцию, предоставляемую удаленной службой специально для проверки работоспособности службы, как описано в шаблоне [мониторинга конечной точки работоспособности](./health-endpoint-monitoring.md).</span><span class="sxs-lookup"><span data-stu-id="ea6ab-179">This ping could take the form of an attempt to invoke an operation that had previously failed, or it could use a special operation provided by the remote service specifically for testing the health of the service, as described by the [Health Endpoint Monitoring pattern](./health-endpoint-monitoring.md).</span></span>

<span data-ttu-id="ea6ab-180">**Ручное переопределение.**</span><span class="sxs-lookup"><span data-stu-id="ea6ab-180">**Manual Override**.</span></span> <span data-ttu-id="ea6ab-181">В системе, где время восстановления завершившейся сбоем операции чрезвычайно изменчиво, можно предоставить вариант ручного сброса, который позволяет администратору закрыть автоматическое выключение (и сбросить счетчик сбоев).</span><span class="sxs-lookup"><span data-stu-id="ea6ab-181">In a system where the recovery time for a failing operation is extremely variable, it's beneficial to provide a manual reset option that enables an administrator to close a circuit breaker (and reset the failure counter).</span></span> <span data-ttu-id="ea6ab-182">Аналогично администратор может принудительно отключить автоматическое выключение в состоянии **Открытый** (и перезапустить таймер времени ожидания), если операция, защищенная автоматическим выключением, временно недоступна.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-182">Similarly, an administrator could force a circuit breaker into the **Open** state (and restart the timeout timer) if the operation protected by the circuit breaker is temporarily unavailable.</span></span>

<span data-ttu-id="ea6ab-183">**Параллелизм.**</span><span class="sxs-lookup"><span data-stu-id="ea6ab-183">**Concurrency**.</span></span> <span data-ttu-id="ea6ab-184">К одному автоматическому выключению может обращаться множество параллельных экземпляров приложения.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-184">The same circuit breaker could be accessed by a large number of concurrent instances of an application.</span></span> <span data-ttu-id="ea6ab-185">Реализация не должна блокировать параллельные запросы или добавлять слишком большие нагрузки для каждого вызова операции.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-185">The implementation shouldn't block concurrent requests or add excessive overhead to each call to an operation.</span></span>

<span data-ttu-id="ea6ab-186">**Различия между ресурсами.**</span><span class="sxs-lookup"><span data-stu-id="ea6ab-186">**Resource Differentiation**.</span></span> <span data-ttu-id="ea6ab-187">Будьте внимательны при использовании одного автоматического выключения для одного типа ресурсов, если может быть несколько базовых независимых поставщиков.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-187">Be careful when using a single circuit breaker for one type of resource if there might be multiple underlying independent providers.</span></span> <span data-ttu-id="ea6ab-188">Например, в хранилище данных, которое содержит несколько сегментов, один сегмент может быть полностью доступен, в то время как другой может испытывать временные проблемы.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-188">For example, in a data store that contains multiple shards, one shard might be fully accessible while another is experiencing a temporary issue.</span></span> <span data-ttu-id="ea6ab-189">Если сообщения об ошибках в этих сценариях объединены, приложение может попытаться получить доступ к некоторым сегментам даже при высокой вероятности сбоя, в то время как другие сегменты могут быть заблокированы, несмотря на то что они могут быть успешно выполнены.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-189">If the error responses in these scenarios are merged, an application might try to access some shards even when failure is highly likely, while access to other shards might be blocked even though it's likely to succeed.</span></span>

<span data-ttu-id="ea6ab-190">**Ускорение автоматического выключения.**</span><span class="sxs-lookup"><span data-stu-id="ea6ab-190">**Accelerated Circuit Breaking**.</span></span> <span data-ttu-id="ea6ab-191">Иногда сообщение о сбое может содержать достаточно информации для активации и работы автоматического выключения в течение минимального количества времени.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-191">Sometimes a failure response can contain enough information for the circuit breaker to trip immediately and stay tripped for a minimum amount of time.</span></span> <span data-ttu-id="ea6ab-192">Например, сообщение об ошибке перегруженного общего ресурса может указывать на то, что выполнение немедленной повторной попытки не рекомендуется и приложению следует повторить попытку через несколько минут.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-192">For example, the error response from a shared resource that's overloaded could indicate that an immediate retry isn't recommended and that the application should instead try again in a few minutes.</span></span>

> [!NOTE]
> <span data-ttu-id="ea6ab-193">Служба может возвращать код ошибки HTTP 429 (слишком много запросов), если регулируется количество запросов клиента, или ошибку HTTP 503 (служба недоступна), если служба недоступна в данный момент.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-193">A service can return HTTP 429 (Too Many Requests) if it is throttling the client, or HTTP 503 (Service Unavailable) if the service is not currently available.</span></span> <span data-ttu-id="ea6ab-194">Сообщение может включать дополнительные сведения, например, предполагаемую длительность задержки.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-194">The response can include additional information, such as the anticipated duration of the delay.</span></span>

<span data-ttu-id="ea6ab-195">**Воспроизведение неудачных запросов.**</span><span class="sxs-lookup"><span data-stu-id="ea6ab-195">**Replaying Failed Requests**.</span></span> <span data-ttu-id="ea6ab-196">В состоянии **Открытый**, вместо того, чтобы просто быстро выполнить завершение со сбоем, автоматическое выключение может также записывать сведения о каждом запросе к журналу и подготавливать эти запросы для воспроизведения, когда удаленный ресурс или служба станут доступны.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-196">In the **Open** state, rather than simply failing quickly, a circuit breaker could also record the details of each request to a journal and arrange for these requests to be replayed when the remote resource or service becomes available.</span></span>

<span data-ttu-id="ea6ab-197">**Неподходящее время ожидания внешних служб.**</span><span class="sxs-lookup"><span data-stu-id="ea6ab-197">**Inappropriate Timeouts on External Services**.</span></span> <span data-ttu-id="ea6ab-198">Автоматическое выключение может оказаться не в состоянии полностью защитить приложения от операций, завершающихся со сбоем во внешних службах, настроенных с длительным периодом ожидания.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-198">A circuit breaker might not be able to fully protect applications from operations that fail in external services that are configured with a lengthy timeout period.</span></span> <span data-ttu-id="ea6ab-199">Если время ожидания слишком велико, поток, выполняющий автоматическое выключение, может быть заблокирован в течение длительного периода времени, прежде чем автоматическое выключение покажет, что операция не выполнена.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-199">If the timeout is too long, a thread running a circuit breaker might be blocked for an extended period before the circuit breaker indicates that the operation has failed.</span></span> <span data-ttu-id="ea6ab-200">В это время множество других экземпляров приложений могут также попытаться вызвать службу через автоматическое выключение и связать значительное количество потоков, прежде чем все они завершатся со сбоем.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-200">In this time, many other application instances might also try to invoke the service through the circuit breaker and tie up a significant number of threads before they all fail.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="ea6ab-201">Когда следует использовать этот шаблон</span><span class="sxs-lookup"><span data-stu-id="ea6ab-201">When to use this pattern</span></span>

<span data-ttu-id="ea6ab-202">Используйте этот шаблон в следующих случаях:</span><span class="sxs-lookup"><span data-stu-id="ea6ab-202">Use this pattern:</span></span>

- <span data-ttu-id="ea6ab-203">Чтобы предотвратить попытки вызова приложением удаленной службы или получения доступа к общему ресурсу, если эта операция, скорее всего, завершится со сбоем.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-203">To prevent an application from trying to invoke a remote service or access a shared resource if this operation is highly likely to fail.</span></span>

<span data-ttu-id="ea6ab-204">Этот шаблон не рекомендуется использовать в следующих случаях:</span><span class="sxs-lookup"><span data-stu-id="ea6ab-204">This pattern isn't recommended:</span></span>

- <span data-ttu-id="ea6ab-205">Для обработки доступа к локальным закрытым ресурсам в приложении, например, в структуре данных в памяти.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-205">For handling access to local private resources in an application, such as in-memory data structure.</span></span> <span data-ttu-id="ea6ab-206">В этой среде при использовании автоматического выключения нагрузка в системе возрастет.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-206">In this environment, using a circuit breaker would add overhead to your system.</span></span>
- <span data-ttu-id="ea6ab-207">В качестве замены для обработки исключений в бизнес-логике приложений.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-207">As a substitute for handling exceptions in the business logic of your applications.</span></span>

## <a name="example"></a><span data-ttu-id="ea6ab-208">Пример</span><span class="sxs-lookup"><span data-stu-id="ea6ab-208">Example</span></span>

<span data-ttu-id="ea6ab-209">В веб-приложении несколько страниц заполняются данными, полученными из внешней службы.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-209">In a web application, several of the pages are populated with data retrieved from an external service.</span></span> <span data-ttu-id="ea6ab-210">Если система реализует минимальное кэширование, большинство обращений к этим страницам вызовет переход в службу.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-210">If the system implements minimal caching, most hits to these pages will cause a round trip to the service.</span></span> <span data-ttu-id="ea6ab-211">Для подключений из веб-приложения в службу может быть настроено время ожидания (обычно 60 секунд). Если служба не отвечает за это время, логика на каждой веб-странице предполагает, что служба недоступна, и вызовет исключение.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-211">Connections from the web application to the service could be configured with a timeout period (typically 60 seconds), and if the service doesn't respond in this time the logic in each web page will assume that the service is unavailable and throw an exception.</span></span>

<span data-ttu-id="ea6ab-212">Однако, если служба завершается со сбоем и система очень занята, пользователи могут быть вынуждены ждать в течение минуты до возникновения исключения.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-212">However, if the service fails and the system is very busy, users could be forced to wait for up to 60 seconds before an exception occurs.</span></span> <span data-ttu-id="ea6ab-213">В конечном итоге ресурсы, такие как память, подключения и потоки, могут быть исчерпаны, из-за чего другие пользователи не смогут подключаться к системе, даже если они не обращаются к страницам, которые извлекают данные из службы.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-213">Eventually resources such as memory, connections, and threads could be exhausted, preventing other users from connecting to the system, even if they aren't accessing pages that retrieve data from the service.</span></span>

<span data-ttu-id="ea6ab-214">Масштабирование системы путем добавления дополнительных веб-серверов и реализации балансировки нагрузки может вызвать задержку при исчерпании ресурсов. Однако проблема не будет решена, так как на запросы пользователей по-прежнему нет ответов, а все веб-серверы все еще могут в конечном итоге исчерпать ресурсы.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-214">Scaling the system by adding further web servers and implementing load balancing might delay when resources become exhausted, but it won't resolve the issue because user requests will still be unresponsive and all web servers could still eventually run out of resources.</span></span>

<span data-ttu-id="ea6ab-215">Поместив логику, которая подключается к службе и извлекает данные, в автоматическое выключение можно решить эту проблему и более эффективно обработать отказ службы.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-215">Wrapping the logic that connects to the service and retrieves the data in a circuit breaker could help to solve this problem and handle the service failure more elegantly.</span></span> <span data-ttu-id="ea6ab-216">Запросы пользователей будут по-прежнему завершаться со сбоем, но это будет происходить быстрее, а ресурсы не будут блокироваться.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-216">User requests will still fail, but they'll fail more quickly and the resources won't be blocked.</span></span>

<span data-ttu-id="ea6ab-217">Класс `CircuitBreaker` сохраняет информацию о состоянии автоматического выключения в объекте, который реализует интерфейс `ICircuitBreakerStateStore`, как показано в следующем коде.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-217">The `CircuitBreaker` class maintains state information about a circuit breaker in an object that implements the `ICircuitBreakerStateStore` interface shown in the following code.</span></span>

```csharp
interface ICircuitBreakerStateStore
{
  CircuitBreakerStateEnum State { get; }

  Exception LastException { get; }

  DateTime LastStateChangedDateUtc { get; }

  void Trip(Exception ex);

  void Reset();

  void HalfOpen();

  bool IsClosed { get; }
}
```

<span data-ttu-id="ea6ab-218">Свойство `State` указывает на текущее состояние автоматического выключения (**Открытый**, **Полуоткрытый** и **Закрытый**, как определено в соответствии с перечислением `CircuitBreakerStateEnum`).</span><span class="sxs-lookup"><span data-stu-id="ea6ab-218">The `State` property indicates the current state of the circuit breaker, and will be either **Open**, **HalfOpen**, or **Closed** as defined by the `CircuitBreakerStateEnum` enumeration.</span></span> <span data-ttu-id="ea6ab-219">Свойство `IsClosed` должно иметь значение true, если автоматическое выключение закрыто, и false, если оно открыто или полуоткрыто.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-219">The `IsClosed` property should be true if the circuit breaker is closed, but false if it's open or half open.</span></span> <span data-ttu-id="ea6ab-220">Метод `Trip` переводит автоматическое выключение в состояние "Открытый" и записывает исключение, которое вызывает изменения в состоянии, а также время и дату создания исключения.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-220">The `Trip` method switches the state of the circuit breaker to the open state and records the exception that caused the change in state, together with the date and time that the exception occurred.</span></span> <span data-ttu-id="ea6ab-221">Свойства `LastException` и `LastStateChangedDateUtc` возвращают эти сведения.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-221">The `LastException` and the `LastStateChangedDateUtc` properties return this information.</span></span> <span data-ttu-id="ea6ab-222">Метод `Reset` закрывает автоматическое выключение, а `HalfOpen` — переводит его в состояние "Полуоткрытый".</span><span class="sxs-lookup"><span data-stu-id="ea6ab-222">The `Reset` method closes the circuit breaker, and the `HalfOpen` method sets the circuit breaker to half open.</span></span>

<span data-ttu-id="ea6ab-223">Класс `InMemoryCircuitBreakerStateStore` в примере содержит реализацию интерфейса `ICircuitBreakerStateStore`.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-223">The `InMemoryCircuitBreakerStateStore` class in the example contains an implementation of the `ICircuitBreakerStateStore` interface.</span></span> <span data-ttu-id="ea6ab-224">Класс `CircuitBreaker` создает экземпляр этого класса для хранения состояния автоматического выключения.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-224">The `CircuitBreaker` class creates an instance of this class to hold the state of the circuit breaker.</span></span>

<span data-ttu-id="ea6ab-225">Метод `ExecuteAction` в классе `CircuitBreaker` помещает операцию, указанную как делегат `Action`, в оболочку.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-225">The `ExecuteAction` method in the `CircuitBreaker` class wraps an operation, specified as an `Action` delegate.</span></span> <span data-ttu-id="ea6ab-226">Если автоматическое выключение закрыто, `ExecuteAction` вызывает делегат `Action`.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-226">If the circuit breaker is closed, `ExecuteAction` invokes the `Action` delegate.</span></span> <span data-ttu-id="ea6ab-227">Если операция завершается со сбоем, обработчик исключений вызывает `TrackException`, который устанавливает автоматическое выключение в состояние "Открытый".</span><span class="sxs-lookup"><span data-stu-id="ea6ab-227">If the operation fails, an exception handler calls `TrackException`, which sets the circuit breaker state to open.</span></span> <span data-ttu-id="ea6ab-228">Эта процедура представлена в следующем примере кода.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-228">The following code example highlights this flow.</span></span>

```csharp
public class CircuitBreaker
{
  private readonly ICircuitBreakerStateStore stateStore =
    CircuitBreakerStateStoreFactory.GetCircuitBreakerStateStore();

  private readonly object halfOpenSyncObject = new object ();
  ...
  public bool IsClosed { get { return stateStore.IsClosed; } }

  public bool IsOpen { get { return !IsClosed; } }

  public void ExecuteAction(Action action)
  {
    ...
    if (IsOpen)
    {
      // The circuit breaker is Open.
      ... (see code sample below for details)
    }

    // The circuit breaker is Closed, execute the action.
    try
    {
      action();
    }
    catch (Exception ex)
    {
      // If an exception still occurs here, simply
      // retrip the breaker immediately.
      this.TrackException(ex);

      // Throw the exception so that the caller can tell
      // the type of exception that was thrown.
      throw;
    }
  }

  private void TrackException(Exception ex)
  {
    // For simplicity in this example, open the circuit breaker on the first exception.
    // In reality this would be more complex. A certain type of exception, such as one
    // that indicates a service is offline, might trip the circuit breaker immediately.
    // Alternatively it might count exceptions locally or across multiple instances and
    // use this value over time, or the exception/success ratio based on the exception
    // types, to open the circuit breaker.
    this.stateStore.Trip(ex);
  }
}
```

<span data-ttu-id="ea6ab-229">В следующем примере показан код (отсутствующий в предыдущем примере), который выполняется, если автоматическое выключение не закрыто.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-229">The following example shows the code (omitted from the previous example) that is executed if the circuit breaker isn't closed.</span></span> <span data-ttu-id="ea6ab-230">Сначала в нем проверяется, было ли открыто автоматическое выключение в течение периода, большего, чем задано в локальном поле `OpenToHalfOpenWaitTime` в классе `CircuitBreaker`.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-230">It first checks if the circuit breaker has been open for a period longer than the time specified by the local `OpenToHalfOpenWaitTime` field in the `CircuitBreaker` class.</span></span> <span data-ttu-id="ea6ab-231">Если это так, метод `ExecuteAction` задает автоматическому выключению состояние "Полуоткрытый", а затем пытается выполнить операцию, заданную делегатом `Action`.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-231">If this is the case, the `ExecuteAction` method sets the circuit breaker to half open, then tries to perform the operation specified by the `Action` delegate.</span></span>

<span data-ttu-id="ea6ab-232">Если операция выполнена успешно, автоматическое выключение сбрасывается до закрытого состояния.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-232">If the operation is successful, the circuit breaker is reset to the closed state.</span></span> <span data-ttu-id="ea6ab-233">Если операция завершается со сбоем, автоматическое выключение возвращается в открытое состояние, а время, когда произошло исключение, обновляется, чтобы автоматическое выключение ожидало еще некоторое время, прежде чем пытаться выполнить операцию еще раз.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-233">If the operation fails, it is tripped back to the open state and the time the exception occurred is updated so that the circuit breaker will wait for a further period before trying to perform the operation again.</span></span>

<span data-ttu-id="ea6ab-234">Если автоматическое выключение находилось в открытом состоянии в течение короткого времени (меньшем, чем значение `OpenToHalfOpenWaitTime`), метод `ExecuteAction` просто вызывает исключение `CircuitBreakerOpenException` и возвращает сообщение об ошибке, которая вызвала переход автоматического выключения в состояние "Открытый".</span><span class="sxs-lookup"><span data-stu-id="ea6ab-234">If the circuit breaker has only been open for a short time, less than the `OpenToHalfOpenWaitTime` value, the `ExecuteAction` method simply throws a `CircuitBreakerOpenException` exception and returns the error that caused the circuit breaker to transition to the open state.</span></span>

<span data-ttu-id="ea6ab-235">Кроме того, метод использует блокировку для предотвращения попыток выполнения параллельных вызовов автоматического выключения, пока оно находится в состоянии "Полуоткрытый".</span><span class="sxs-lookup"><span data-stu-id="ea6ab-235">Additionally, it uses a lock to prevent the circuit breaker from trying to perform concurrent calls to the operation while it's half open.</span></span> <span data-ttu-id="ea6ab-236">Одновременная попытка вызвать операцию будет обрабатываться так, как если бы автоматическое выключение было открыто, и она завершится с исключением, как описано ниже.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-236">A concurrent attempt to invoke the operation will be handled as if the circuit breaker was open, and it'll fail with an exception as described later.</span></span>

```csharp
    ...
    if (IsOpen)
    {
      // The circuit breaker is Open. Check if the Open timeout has expired.
      // If it has, set the state to HalfOpen. Another approach might be to
      // check for the HalfOpen state that had be set by some other operation.
      if (stateStore.LastStateChangedDateUtc + OpenToHalfOpenWaitTime < DateTime.UtcNow)
      {
        // The Open timeout has expired. Allow one operation to execute. Note that, in
        // this example, the circuit breaker is set to HalfOpen after being
        // in the Open state for some period of time. An alternative would be to set
        // this using some other approach such as a timer, test method, manually, and
        // so on, and check the state here to determine how to handle execution
        // of the action.
        // Limit the number of threads to be executed when the breaker is HalfOpen.
        // An alternative would be to use a more complex approach to determine which
        // threads or how many are allowed to execute, or to execute a simple test
        // method instead.
        bool lockTaken = false;
        try
        {
          Monitor.TryEnter(halfOpenSyncObject, ref lockTaken);
          if (lockTaken)
          {
            // Set the circuit breaker state to HalfOpen.
            stateStore.HalfOpen();

            // Attempt the operation.
            action();

            // If this action succeeds, reset the state and allow other operations.
            // In reality, instead of immediately returning to the Closed state, a counter
            // here would record the number of successful operations and return the
            // circuit breaker to the Closed state only after a specified number succeed.
            this.stateStore.Reset();
            return;
          }
        }
        catch (Exception ex)
        {
          // If there's still an exception, trip the breaker again immediately.
          this.stateStore.Trip(ex);

          // Throw the exception so that the caller knows which exception occurred.
          throw;
        }
        finally
        {
          if (lockTaken)
          {
            Monitor.Exit(halfOpenSyncObject);
          }
        }
      }
      // The Open timeout hasn't yet expired. Throw a CircuitBreakerOpen exception to
      // inform the caller that the call was not actually attempted,
      // and return the most recent exception received.
      throw new CircuitBreakerOpenException(stateStore.LastException);
    }
    ...
```

<span data-ttu-id="ea6ab-237">Чтобы использовать объект `CircuitBreaker` для защиты операции приложение создает экземпляр класса `CircuitBreaker` и вызывает метод `ExecuteAction`, указывая операцию, выполняемую в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-237">To use a `CircuitBreaker` object to protect an operation, an application creates an instance of the `CircuitBreaker` class and invokes the `ExecuteAction` method, specifying the operation to be performed as the parameter.</span></span> <span data-ttu-id="ea6ab-238">Приложение следует подготовить для перехвата исключения `CircuitBreakerOpenException`, если операция завершится со сбоем из-за того, что автоматическое выключение открыто.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-238">The application should be prepared to catch the `CircuitBreakerOpenException` exception if the operation fails because the circuit breaker is open.</span></span> <span data-ttu-id="ea6ab-239">Пример кода приведен ниже.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-239">The following code shows an example:</span></span>

```csharp
var breaker = new CircuitBreaker();

try
{
  breaker.ExecuteAction(() =>
  {
    // Operation protected by the circuit breaker.
    ...
  });
}
catch (CircuitBreakerOpenException ex)
{
  // Perform some different action when the breaker is open.
  // Last exception details are in the inner exception.
  ...
}
catch (Exception ex)
{
  ...
}
```

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="ea6ab-240">Связанные шаблоны и рекомендации</span><span class="sxs-lookup"><span data-stu-id="ea6ab-240">Related patterns and guidance</span></span>

<span data-ttu-id="ea6ab-241">Следующие шаблоны также могут быть полезными при реализации этого шаблона:</span><span class="sxs-lookup"><span data-stu-id="ea6ab-241">The following patterns might also be useful when implementing this pattern:</span></span>

- <span data-ttu-id="ea6ab-242">[Шаблон повторов](./retry.md).</span><span class="sxs-lookup"><span data-stu-id="ea6ab-242">[Retry pattern](./retry.md).</span></span> <span data-ttu-id="ea6ab-243">Описывает механизм обработки ожидаемых временных сбоев, при котором приложение может повторно подключаться к службе или сетевому ресурсу, обращение к которым завершилось сбоем, не прерывая потока событий.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-243">Describes how an application can handle anticipated temporary failures when it tries to connect to a service or network resource by transparently retrying an operation that has previously failed.</span></span>

- <span data-ttu-id="ea6ab-244">[Шаблон мониторинга конечных точек работоспособности](./health-endpoint-monitoring.md).</span><span class="sxs-lookup"><span data-stu-id="ea6ab-244">[Health Endpoint Monitoring pattern](./health-endpoint-monitoring.md).</span></span> <span data-ttu-id="ea6ab-245">Автоматическое выключение может проверить работоспособность службы, отправив запрос в конечную точку, открытую службой.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-245">A circuit breaker might be able to test the health of a service by sending a request to an endpoint exposed by the service.</span></span> <span data-ttu-id="ea6ab-246">Служба должна вернуть информацию о своем состоянии.</span><span class="sxs-lookup"><span data-stu-id="ea6ab-246">The service should return information indicating its status.</span></span>

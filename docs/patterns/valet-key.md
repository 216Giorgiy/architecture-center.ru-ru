---
title: Шаблон ключа камердинера
titleSuffix: Cloud Design Patterns
description: Использование токена или ключа, который предоставляет клиентам ограниченный доступ к определенному ресурсу или службе.
keywords: Конструктивный шаблон
author: dragon119
ms.date: 06/23/2017
ms.custom: seodec18
ms.openlocfilehash: 09173717d499d524d4d5dad2c1202c1bf361b1e5
ms.sourcegitcommit: 680c9cef945dff6fee5e66b38e24f07804510fa9
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/04/2019
ms.locfileid: "54009871"
---
# <a name="valet-key-pattern"></a>Шаблон ключа камердинера

[!INCLUDE [header](../_includes/header.md)]

Используйте токен, который предоставляет клиентам ограниченный прямой доступ к определенному ресурсу, чтобы разгрузить передачу данных из приложения. Это особенно полезно в приложениях, которые используют системы облачных хранилищ или очередей и могут снизить затраты до минимума, а также повысить масштабируемость и производительность до максимума.

## <a name="context-and-problem"></a>Контекст и проблема

Клиентским программам и веб-браузерам часто приходится читать и записывать файлы или потоки данных в хранилище приложений и из него. Как правило, приложение будет обрабатывать перемещение данных &mdash; либо путем получения их из хранилища и потоковой передачи клиенту, либо путем считывания отправленного потока из клиента и сохранения его в хранилище данных. Однако при этом подходе поглощаются ценные ресурсы, такие как вычисления, память и пропускная способность.

Хранилища данных имеют возможность обрабатывать отправленные и скачанные данные напрямую, не требуя, чтобы приложение выполняло какую-либо обработку для перемещения этих данных. Однако для этого обычно требуется, чтобы клиент имел доступ к учетным данным безопасности хранилища. Это может быть полезным методом, позволяющим минимизировать затраты на передачу данных и требования по масштабированию, а также повысить производительность приложения. Однако это означает, что приложение больше не будет управлять безопасностью данных. После того как у клиента появилось подключение к хранилищу данных для прямого доступа, приложение не может выступать в роли привратника. Оно больше не контролирует процесс и не может предотвратить последующие отправки или скачивания из хранилища данных.

Это не реалистичный подход в распределенных системах, которым необходимо обслуживать ненадежных клиентов. Вместо этого приложения должны иметь возможность безопасно и точно управлять доступом, но при этом уменьшать нагрузку на сервер, настраивая это подключение и позволяя клиенту напрямую связываться с хранилищем данных для выполнения необходимых операций чтения или записи.

## <a name="solution"></a>Решение

Необходимо решить проблему управления доступом к хранилищу данных, в котором хранилище не может управлять проверкой подлинности и авторизацией клиентов. Одним из распространенных решений является ограничение доступа к общедоступному подключению хранилища данных и предоставление клиенту ключа или токена, которые можно проверить в хранилище данных.

Этот ключ или токен обычно называют ключом камердинера. Он обеспечивает ограниченный по времени доступ к определенным ресурсам и позволяет выполнять только предопределенные операции, такие как чтение и запись в хранилище или очереди, а также отправку и скачивание в веб-браузере. Приложения могут быстро и легко создавать и выдавать ключи камердинера клиентским устройствам и веб-браузерам, что позволяет клиентам выполнять требуемые операции, не требуя от приложения напрямую обрабатывать передачу данных. Это убирает дополнительные нагрузки, а также влияние на производительность и масштабируемость приложения и сервера.

Клиент использует этот токен для доступа к определенному ресурсу в хранилище данных только на определенный период и с конкретными ограничениями на разрешения доступа, как показано на рисунке. По истечении указанного периода ключ становится недействительным и больше не предоставляет доступ к ресурсу.

![Рисунок 1. Общие сведения о шаблоне](./_images/valet-key-pattern.png)

Кроме того, можно настроить ключ с другими зависимостями, например область данных. Например, в зависимости от возможностей хранилища данных ключ может указывать полную таблицу в хранилище данных или только определенные строки в таблице. В облачных системах хранения ключ может указывать контейнер или только определенный элемент в контейнере.

Ключ также может стать недействительным для приложения. Это удобный подход, если клиент уведомляет сервер о завершении операции передачи данных. Затем сервер может сделать недействительным этот ключ, чтобы предотвратить дальнейший доступ.

Использование этого шаблона может упростить управление доступом к ресурсам, так как не нужно создавать пользователя и проверять его подлинность, предоставлять разрешения, а затем снова удалять пользователя. Это также упрощает ограничение расположения, разрешения и периода действия за счет создания ключа в среде выполнения. Важными факторами являются максимальное ограничение срока действия и в особенности расположения ресурса, чтобы получатель мог использовать его только по назначению.

## <a name="issues-and-considerations"></a>Проблемы и рекомендации

При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.

**Управляйте состоянием допустимости и периодом действия ключа.** При утечке или нарушении безопасности ключ эффективно разблокирует целевой элемент и сделает его доступным для использования злоумышленником в течение срока действия. Ключ обычно можно отозвать или отключить, в зависимости от того, как он был выдан. Политики на стороне сервера могут быть изменены или ключ сервера, с помощью которого они были подписаны, может быть аннулирован. Укажите короткий срок действия, чтобы свести к минимуму риск несанкционированных операций в хранилище данных. Однако, если период действия слишком короткий, клиент может не успеть завершить операцию до истечения срока действия ключа. Разрешите авторизованным пользователям обновлять ключ до истечения срока действия, если требуется несколько обращений к защищенному ресурсу.

**Управляйте уровнем доступа, который предоставляет ключ.** Как правило, ключ должен позволять пользователю выполнять только действия, необходимые для завершения операции, такие как доступ только для чтения, если клиент не должен иметь возможности отправлять данные в хранилище данных. Для отправки файлов обычно указывается ключ, предоставляющий разрешение только на запись, а также расположение и срок действия. Очень важно точно указать ресурс или набор ресурсов, к которым применяется ключ.

**Выберите способ управления поведением пользователей.** Реализация этого шаблона означает некоторую потерю контроля над ресурсами, к которым предоставляется доступ пользователям. Уровень контроля, который может быть применен, ограничен возможностями политик и разрешений, доступных для службы или целевого хранилища данных. Например, обычно невозможно создать ключ, ограничивающий размер данных, записываемых в хранилище, или то, сколько раз ключ может использоваться для доступа к файлу. Это может привести к огромным непредвиденным расходам на передачу данных даже при использовании предполагаемым клиентом и может быть вызвано ошибкой в ​​коде, вызывающей повторную отправку или скачивание. Чтобы ограничить количество отправок файла, по возможности настройте клиент для принудительного уведомления приложения после завершения одной операции. Например, некоторые хранилища данных вызывают события, которые код приложения может использовать для мониторинга операций и управления поведением пользователя. Однако это затрудняет принудительное использование квот для отдельных пользователей в сценарии с несколькими клиентами, в котором один и тот же ключ используется всеми пользователями одного клиента.

**Проверяйте и при необходимости очищайте все отправленные данные.** Злоумышленник, который получает доступ к ключу, может отправлять данные, предназначенные для компрометации системы. Кроме того, авторизованные пользователи могут отправлять недопустимые данные, которые при обработке могут привести к ошибке или сбою системы. Чтобы избежать этого перед использованием, убедитесь, что все отправленные данные проверены на наличие вредоносного содержимого.

**Выполняйте аудит всех операций.** Многие механизмы, основанные на использовании ключей, могут записывать в журналы операции, такие как отправка и скачивание, а также сбои. Эти журналы обычно можно включить в процесс аудита, а также использовать для выставления счетов, если плата взимается с пользователя на основе размера файлов и объема данных. Используйте журналы для обнаружения ошибок проверки подлинности, которые могут быть вызваны проблемами с поставщиком ключей или случайным удалением хранимой политики доступа.

**Доставляйте ключи безопасным образом.** Ключ может быть встроен в URL-адрес, который пользователь активирует на веб-странице, или использоваться в операции перенаправления на сервере для автоматического скачивания. Всегда используйте HTTPS для доставки ключа по безопасному каналу.

**Защищайте конфиденциальные данные во время передачи.** Передача конфиденциальных данных через приложение обычно выполняется с помощью SSL или TLS. Этот подход должен применяться к клиентам, обращающимся непосредственно к хранилищу данных.

Ниже приведены другие проблемы, которые необходимо учитывать при реализации данного шаблона:

- Если клиент не уведомляет или не может уведомить сервер о завершении операции, а единственным ограничением является срок действия ключа, приложение не сможет выполнять операции аудита, такие как подсчет операций отправки или скачивания, или предотвращать множественные отправки или скачивания.

- Гибкость основных политик, которые могут быть созданы, может быть ограничена. Например, некоторые механизмы разрешают использование только временного периода истечения срока действия, а другие не могут задать достаточную степень детализации разрешений на чтение или запись.

- Если указано время начала периода действия ключа или токена, убедитесь, что оно немного предшествует текущему времени сервера, позволяя работать часам клиента, которые могут быть немного рассинхронизированы. По умолчанию, если не задано, обычно это текущее время сервера.

- URL-адрес, содержащий ключ, записывается в файлы журналов сервера. Хотя срок действия ключа, как правило, истекает, прежде чем файлы журнала будут использованы для анализа, ограничьте доступ к ним. Если данные журнала передаются в систему мониторинга или хранятся в другом расположении, рассмотрите возможность применения задержки во избежание утечки ключей до истечения срока их действия.

- Если код клиента выполняется в веб-браузере, браузер может поддержать общий доступ к ресурсам независимо от источника (CORS), чтобы включить код, который выполняется в веб-браузере, и получить доступ к данным в другом домене из того, который обслуживал страницу. Некоторые старые браузеры и хранилища данных не поддерживают CORS, а код в этих браузерах может использовать ключ камердинера для обеспечения доступа к данным в другом домене, таком как облачная учетная запись хранения.

## <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон

Этот шаблон будет полезен в следующих сценариях:

- Чтобы свести к минимуму нагрузку ресурсов и обеспечить максимальную производительность и масштабируемость. Использование ключа камердинера не требует блокировки ресурса или удаленного вызова сервера, нет ограничений на количество выдаваемых ключей камердинера. Это позволяет избежать единой точки отказа, возникающей из-за передачи данных через код приложения. Создание ключа камердинера — это обычно простая криптографическая операция подписи строки с ключом.

- Чтобы свести к минимуму операционные расходы. Включение прямого доступа к хранилищам и очередям — выгодный в отношении ресурсов и экономически обоснованный подход, который может уменьшить количество круговых путей в сети, а также сократить количество требуемых вычислительных ресурсов.

- Когда клиенты регулярно отправляют или скачивают большие объемы данных или когда в каждой операции используются большие файлы.

- Когда в приложении ограничены вычислительные ресурсы, либо из-за ограничений узла, либо из соображений стоимости. В этом сценарии шаблон будет еще более полезен, если есть много параллельных отправок или скачиваний данных, так как он освобождает приложение от обработки передачи данных.

- Когда данные хранятся в удаленном хранилище данных или в другом центре данных. Если приложение должно было выступать в качестве привратника, за передачу данных между центрами обработки данных или между общедоступными и частными сетями, между клиентом и приложением, а затем между приложением и хранилищем данных может взиматься дополнительная плата за использование пропускной способности.

Этот шаблон неприменим в следующих случаях:

- Если приложение должно выполнить некоторую задачу на основе данных перед ее сохранением или до ее отправки клиенту. Например, если приложение должно выполнить проверку, успешно получить доступ к журналу или выполнить преобразование данных. Однако некоторые хранилища данных и клиенты могут согласовывать действия и выполнять простые преобразования, такие как сжатие и распаковка (например, веб-браузер обычно может обрабатывать форматы GZIP).

- Если структура имеющегося приложения затрудняет внедрение шаблона. Использование этого шаблона обычно требует другого архитектурного подхода к доставке и приему данных.

- Если необходимо обслуживать журнал аудита или управлять количеством выполнений операции передачи данных, а используемый механизм ключа камердинера не поддерживает уведомления, которые сервер может использовать для управления этими операциями.

- При необходимости ограничьте объем данных, особенно во время операций отправки. Единственным решением является проверка в приложении размера данных после завершения операции или проверка размера отправок через определенный период или по расписанию.

## <a name="example"></a>Пример

Azure поддерживает подписанный URL-адрес в службе хранилища Azure для детального контроля доступа к данным в больших двоичных объектах, таблицах и очередях, а также для очередей и разделов служебной шины. Маркер подписанного URL-адреса можно настроить, чтобы предоставлять определенные права доступа, такие как чтение, запись, обновление и удаление в конкретной таблице; диапазон ключей внутри таблицы; очередь; большой двоичный объект; контейнер большого двоичного объекта. Срок действия может быть указанным периодом времени или не иметь ограничения по времени.

Подписанные URL-адреса Azure также поддерживают хранимые сервером политики доступа, которые могут быть связаны с определенным ресурсом, таким как таблица или большой двоичный объект. Эта функция обеспечивает дополнительный контроль и гибкость по сравнению с создаваемыми приложением маркерами подписанного URL-адреса и должна по возможности использоваться. Параметры, определенные в хранимой на сервере политике, можно изменить и отразить в токене без необходимости выпускать новый токен, но параметры, определенные в токене, нельзя изменить без выдачи нового токена. Этот подход также позволяет отменить допустимый маркер подписанного URL-адреса до истечения срока его действия.

> Дополнительные сведения см. в записи блога MSDN [Introducing Table SAS (Shared Access Signature), Queue SAS and update to Blob SAS](https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/) (Знакомство с SAS таблиц, SAS очередей и изменениями SAS больших двоичных объектов) и статье [Использование подписанных URL-адресов (SAS)](/azure/storage/common/storage-dotnet-shared-access-signature-part-1).

В следующем коде показано, как создать маркер подписанного URL-адреса, действительного в течение пяти минут. Метод `GetSharedAccessReferenceForUpload` возвращает маркер подписанного URL-адреса, который можно использовать для отправки файла в хранилище BLOB-объектов Azure.

```csharp
public class ValuesController : ApiController
{
  private readonly CloudStorageAccount account;
  private readonly string blobContainer;
  ...
  /// <summary>
  /// Return a limited access key that allows the caller to upload a file
  /// to this specific destination for a defined period of time.
  /// </summary>
  private StorageEntitySas GetSharedAccessReferenceForUpload(string blobName)
  {
    var blobClient = this.account.CreateCloudBlobClient();
    var container = blobClient.GetContainerReference(this.blobContainer);

    var blob = container.GetBlockBlobReference(blobName);

    var policy = new SharedAccessBlobPolicy
    {
      Permissions = SharedAccessBlobPermissions.Write,

      // Specify a start time five minutes earlier to allow for client clock skew.
      SharedAccessStartTime = DateTime.UtcNow.AddMinutes(-5),

      // Specify a validity period of five minutes starting from now.
      SharedAccessExpiryTime = DateTime.UtcNow.AddMinutes(5)
    };

    // Create the signature.
    var sas = blob.GetSharedAccessSignature(policy);

    return new StorageEntitySas
    {
      BlobUri = blob.Uri,
      Credentials = sas,
      Name = blobName
    };
  }

  public struct StorageEntitySas
  {
    public string Credentials;
    public Uri BlobUri;
    public string Name;
  }
}
```

> Полный пример доступен в решении ValetKey, которое доступно для скачивания с [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/valet-key). Проект ValetKey.Web в этом решении содержит веб-приложение, которое включает в себя класс `ValuesController`, показанный выше. Пример клиентского приложения, использующего это веб-приложение для получения ключа подписанного URL-адреса и отправки файла в хранилище больших двоичных объектов, доступен в проекте ValetKey.Client.

## <a name="next-steps"></a>Дополнительная информация

При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.

- Пример, демонстрирующий этот шаблон, можно найти на сайте [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/valet-key).
- [Шаблон привратника](./gatekeeper.md). Этот шаблон можно использовать в сочетании с шаблоном ключа камердинера для защиты приложений и служб с помощью выделенного экземпляра узла, который выполняет роль брокера между клиентами и приложением или службой. Привратник проверяет и очищает запросы, а также передает запросы и данные между клиентом и приложением. Обеспечивает дополнительный уровень защиты и уменьшает степень влияния атаки на систему.
- [Шаблон размещения статического содержимого](./static-content-hosting.md). Здесь описано, как развертывать статические ресурсы в облачной службе хранения, которая может доставлять эти ресурсы непосредственно клиенту, чтобы уменьшить потребность в дорогостоящих экземплярах вычислений. Если ресурсы не предназначены для публичного доступа, шаблон ключа камердинера можно использовать для их защиты.
- [Introducing Table SAS (Shared Access Signature), Queue SAS and update to Blob SAS](https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/) (Знакомство с SAS таблиц, SAS очередей и изменениями SAS больших двоичных объектов).
- [Использование подписанных URL-адресов (SAS)](/azure/storage/common/storage-dotnet-shared-access-signature-part-1).
- [Проверка подлинности подписи при общем доступе с помощью служебной шины](/azure/service-bus-messaging/service-bus-sas)

---
title: Шаблон выбора лидера
titleSuffix: Cloud Design Patterns
description: 'Метод координации действий для коллекции экземпляров, объединенных совместной задачей в распределенном приложении: один экземпляр выбирается в качестве лидера, который отвечает за управление другими экземплярами.'
keywords: Конструктивный шаблон
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 1b74228fcceecb350d8df9b7ca2327b5de329a07
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/23/2019
ms.locfileid: "54486129"
---
# <a name="leader-election-pattern"></a>Шаблон выбора лидера

[!INCLUDE [header](../_includes/header.md)]

Выбор одного экземпляра как лидера, который несет ответственность за управление другими экземплярами для координации действий, выполняемых экземплярами, объединенными совместной задачей в распределенном приложении. Это позволяет обеспечить, чтобы экземпляры не конфликтовали друг с другом, не было конфликта между совместно используемыми ресурсами и не возникало непреднамеренного вмешательства в работу, выполняемую другими экземплярами.

## <a name="context-and-problem"></a>Контекст и проблема

В типичном облачном приложении согласованно выполняется множество задач. Все эти задачи могут быть экземплярами, которые выполняются одним и тем же кодом и которым требуется доступ к тем же ресурсам. Или могут работать вместе в параллельном режиме и выполнять отдельные части сложного вычисления.

Большую часть времени экземпляры задач могут выполняться отдельно, но также может потребоваться координация действий каждого экземпляра, чтобы гарантировать отсутствие конфликтов между ними и между совместно используемыми ресурсами, а также чтобы случайно не возникло вмешательства в работу других экземпляров.

Например: 

- В облачной системе, реализующей горизонтальное масштабирование, одновременно может выполняться несколько экземпляров одной задачи, при этом каждый экземпляр может обслуживать другого пользователя. Если эти экземпляры выполняют запись в общий ресурс, то необходимо координировать их действия, чтобы каждый экземпляр не перезаписывал изменения, внесенные другими экземплярами.
- Если задачи параллельно выполняют отдельные элементы сложного вычисления, то результаты должны вычисляться после их полного завершения.

Все экземпляры задач являются кэширующими узлами, поэтому среди них нет естественного лидера, который бы действовал как координатор или агрегатор.

## <a name="solution"></a>Решение

В качестве лидера необходимо выбрать один экземпляр задачи, и этот экземпляр будет координировать действия других подчиненных экземпляров задач. Если все экземпляры задач выполняются одним и тем же кодом, то все они могут выступать в качестве лидера. Поэтому процесс выбора должен тщательно контролироваться, чтобы два или более экземпляров не получили роль лидера одновременно.

Система должна предоставлять надежный механизм для выбора лидера. Этот метод должен справляться с такими событиями, как сбои сети или сбои рабочего процесса. Во многих решениях подчиненные экземпляры задач выполняют мониторинг лидера посредством так называемого метода пульса или с помощью опроса. Если назначенный лидер неожиданно завершает работу, или если сбой сети делает лидера недоступным для подчиненных экземпляров задач, то им необходимо выбрать нового лидера.

Существует несколько стратегий выбора лидера среди набора задач в распределенной среде, а именно:

- Выбор экземпляра задачи с самым низким рангом или наименьшим значением идентификатора процесса.
- Состязание для получения общего распределенного мьютекса. Первый экземпляр задачи, который получит мьютекс, становится лидером. При этом системе необходимо убедиться, что если лидер завершает работу или отключается от остальной части системы, то мьютекс отменяется, чтобы другой экземпляр задачи мог стать лидером.
- Реализация одного из распространенных алгоритмов выбора лидера, таких как [алгоритм Bully](https://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/BullyExample.html) или [алгоритм Ring](https://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/RingElectExample.html). Эти алгоритмы предполагают, что каждый кандидат при выборе имеет уникальный идентификатор, и что он может надежно взаимодействовать с другими кандидатами.

## <a name="issues-and-considerations"></a>Проблемы и рекомендации

При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.

- Процесс выбора лидера должен быть устойчивым к временным и постоянным сбоям.
- Должна быть возможность выявления ситуаций, когда в лидере произошел сбой или он стал недоступным по другой причине (например, из-за ошибки связи). Необходимая скорость выявления зависит от системы. Некоторые системы способны какое-то время функционировать без лидера. В этот период временная ошибка может быть исправлена. В других случаях может потребоваться немедленно обнаружить сбой лидера и запустить новый процесс выбора.
- В системе, в которой реализовано горизонтальное автомасштабирование, лидер может выйти из строя, если система выполнит обратное масштабирование и, как следствие, завершит работу некоторых вычислительных ресурсов.
- Использование общего распределенного мьютекса вводит зависимость от внешней службы, которая предоставляет мьютекс. Служба представляет собой единую точку отказа. Если она станет недоступной по какой-либо причине, система не сможет выбрать лидера.
- Использование одного выделенного процесса в качестве лидера является простым подходом. Тем не менее, в случае сбоя процесса может возникать значительная задержка при его перезапуске. Эта задержка может негативно влиять на производительность и время отклика других процессов, если они ожидают действий лидера по координации операции.
- Реализация одного из алгоритмов выбора лидера вручную обеспечивает наибольшую гибкость для настройки и оптимизации кода.

## <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон

Используйте этот шаблон, когда задачи в распределенном приложении (например, размещенном в облаке решении) нуждаются в тщательной координации, а естественный лидер отсутствует.

> Старайтесь не делать лидером узкое место в системе. Предназначение лидера &mdash; координировать работу подчиненных задач. Он не обязан сам участвовать в этой работе, хотя он должен иметь возможность это сделать, если задача не выбрана в качестве лидера.

Этот шаблон может оказаться неэффективным в следующих случаях:

- Существует естественный лидер или выделенный процесс, который всегда может выступить в качестве лидера. Например, может быть возможность реализовать одноэлементный процесс, координирующий экземпляры задач. Если произойдет сбой этого процесса или он станет неработоспособным, то система может завершить его работу и перезапустить его.
- Координация между задачами может достигаться с помощью более упрощенного метода. Например, если нескольким экземплярам задач просто требуется координируемый доступ к общему ресурсу, то лучшим решением для управления доступом является использование оптимистической или пессимистической блокировки.
- Стороннее решение является более подходящим. Например, служба Microsoft Azure HDInsight (на основе Apache Hadoop) использует службы, предоставляемые Apache Zookeeper, чтобы координировать задачи map и reduce, собирающие и сводящие данные.

## <a name="example"></a>Пример

Проект DistributedMutex в решении LeaderElection (пример, демонстрирующий этот шаблон, можно найти на портале [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/leader-election)) показывает, как использовать аренду с большим двоичным объектом службы хранилища Azure для обеспечения механизма реализации общего распределенного мьютекса. Этот мьютекс можно использовать для выбора лидера среди группы экземпляров ролей в облачной службе Azure. Первый экземпляр роли, который получит аренду, выбирается в качестве лидера и остается лидером, пока не освободит аренду или будет не в состоянии возобновить аренду. Другие экземпляры роли могут продолжать отслеживать аренду большого двоичного объекта, если лидер станет недоступным.

> Аренда большого двоичного объекта — это блокировка на запись в большой двоичный объект. Один большой двоичный объект может быть субъектом только одной аренды в любой момент времени. Экземпляр роли может запросить аренду указанного большого двоичного объекта, и аренда будет ему предоставлена, если какой-то другой экземпляр роли не арендует этот же большой двоичный объект. В противном случае запрос вызовет исключение.
>
> Чтобы избежать ситуации, когда неисправный экземпляр роли удерживает аренду неограниченное время, укажите время существования аренды. По истечении этого срока аренда станет доступной. Тем не менее, пока экземпляр роли обладает арендой, он может запросить ее продление. В этом случае ему будет предоставлена аренда на последующий период времени. Экземпляр роли может постоянно повторять этот процесс, чтобы сохранить аренду.
> Дополнительные сведения об аренде большого двоичного объекта см. в статье [Lease Blob](https://msdn.microsoft.com/library/azure/ee691972.aspx) (Аренда большого двоичного объекта).

Класс `BlobDistributedMutex` в приведенном ниже примере C# содержит метод `RunTaskWhenMutexAquired`, который предоставляет экземпляру роли возможность получить аренду указанного большого двоичного объекта. Сведения о большом двоичном объекте (имя, контейнер и учетная запись хранения) передаются в конструктор в объекте `BlobSettings`, когда создается объект `BlobDistributedMutex` (этот объект является простой структурой, включенной в пример кода). Конструктор также принимает объект `Task`, ссылающийся на код, который должен выполнять экземпляр роли, если он успешно получил аренду большого двоичного объекта и был выбран лидером. Обратите внимание, что код, который обрабатывает низкоуровневые сведения о получении аренды, реализован в отдельном вспомогательном классе `BlobLeaseManager`.

```csharp
public class BlobDistributedMutex
{
  ...
  private readonly BlobSettings blobSettings;
  private readonly Func<CancellationToken, Task> taskToRunWhenLeaseAcquired;
  ...

  public BlobDistributedMutex(BlobSettings blobSettings,
           Func<CancellationToken, Task> taskToRunWhenLeaseAquired)
  {
    this.blobSettings = blobSettings;
    this.taskToRunWhenLeaseAquired = taskToRunWhenLeaseAquired;
  }

  public async Task RunTaskWhenMutexAcquired(CancellationToken token)
  {
    var leaseManager = new BlobLeaseManager(blobSettings);
    await this.RunTaskWhenBlobLeaseAcquired(leaseManager, token);
  }
  ...
```

Метод `RunTaskWhenMutexAquired` в приведенном выше примере кода вызывает метод `RunTaskWhenBlobLeaseAcquired`, который показан в следующем примере кода. Это фактически и есть приобретение аренды. Метод `RunTaskWhenBlobLeaseAcquired` выполняется асинхронно. Если аренда успешно получена, то экземпляр роли выбран лидером. Делегат `taskToRunWhenLeaseAcquired` предназначен для выполнения работы, координирующей другие экземпляры роли. Если аренда не получена, значит лидером выбран другой экземпляр роли, а текущий экземпляр роли остается подчиненным. Обратите внимание, что `TryAcquireLeaseOrWait` — это вспомогательный метод, который использует объект `BlobLeaseManager` для получения аренды.

```csharp
  private async Task RunTaskWhenBlobLeaseAcquired(
    BlobLeaseManager leaseManager, CancellationToken token)
  {
    while (!token.IsCancellationRequested)
    {
      // Try to acquire the blob lease.
      // Otherwise wait for a short time before trying again.
      string leaseId = await this.TryAquireLeaseOrWait(leaseManager, token);

      if (!string.IsNullOrEmpty(leaseId))
      {
        // Create a new linked cancellation token source so that if either the
        // original token is canceled or the lease can't be renewed, the
        // leader task can be canceled.
        using (var leaseCts =
          CancellationTokenSource.CreateLinkedTokenSource(new[] { token }))
        {
          // Run the leader task.
          var leaderTask = this.taskToRunWhenLeaseAquired.Invoke(leaseCts.Token);
          ...
        }
      }
    }
    ...
  }
```

Задача, запускаемая лидером, также выполняется асинхронно. Пока выполняется эта задача, метод `RunTaskWhenBlobLeaseAquired`, показанный в следующем примере кода, периодически пытается возобновить аренду. Тем самым гарантируется, что экземпляр роли остается лидером. В примере решения задержка между запросами на возобновление меньше, чем время, указанное как продолжительность аренды. Это сделано для того, чтобы другой экземпляр роли не был выбран лидером. Если по какой-то причине при возобновлении происходит сбой, то задача отменяется.

Если не удается возобновить аренду, или если задача отменяется (это может произойти в результате завершения работы экземпляра роли), то аренда прекращается. На данном этапе этот или другой экземпляр роли можно выбрать в качестве лидера. В приведенном ниже фрагменте кода показана эта часть процесса.

```csharp
  private async Task RunTaskWhenBlobLeaseAcquired(
    BlobLeaseManager leaseManager, CancellationToken token)
  {
    while (...)
    {
      ...
      if (...)
      {
        ...
        using (var leaseCts = ...)
        {
          ...
          // Keep renewing the lease in regular intervals.
          // If the lease can't be renewed, then the task completes.
          var renewLeaseTask =
            this.KeepRenewingLease(leaseManager, leaseId, leaseCts.Token);

          // When any task completes (either the leader task itself or when it
          // couldn't renew the lease) then cancel the other task.
          await CancelAllWhenAnyCompletes(leaderTask, renewLeaseTask, leaseCts);
        }
      }
    }
  }
  ...
}
```

`KeepRenewingLease` — это еще один вспомогательный метод, который использует объект `BlobLeaseManager` для возобновления аренды. Метод `CancelAllWhenAnyCompletes` отменяет задачи, указанные в качестве первых двух параметров. На следующей схеме показано, как с помощью класса `BlobDistributedMutex` выбирается лидер и запускается задача, которая координирует операции.

![Рисунок 1, демонстрирующий функции класса BlobDistributedMutex](./_images/leader-election-diagram.png)

В следующем примере кода показано использование класса `BlobDistributedMutex` в рабочей роли. Этот код получает аренду большого двоичного объекта с именем `MyLeaderCoordinatorTask`, помещая ее в контейнер аренды в хранилище разработки, а также указывает, что код, определенный в методе `MyLeaderCoordinatorTask`, должен выполняться, если экземпляр роли выбирается в качестве лидера.

```csharp
var settings = new BlobSettings(CloudStorageAccount.DevelopmentStorageAccount,
  "leases", "MyLeaderCoordinatorTask");
var cts = new CancellationTokenSource();
var mutex = new BlobDistributedMutex(settings, MyLeaderCoordinatorTask);
mutex.RunTaskWhenMutexAcquired(this.cts.Token);
...

// Method that runs if the role instance is elected the leader
private static async Task MyLeaderCoordinatorTask(CancellationToken token)
{
  ...
}
```

Обратите внимание на следующие аспекты, касающиеся примера решения:

- Большой двоичный объект — это потенциальная единая точка отказа. Если служба BLOB-объектов становится недоступной, или в нее не удается войти, то лидер не сможет возобновить аренду. И никакой другой экземпляр роли не сможет получить аренду. В таком случае никакой экземпляр роли не сможет выступать в качестве лидера. Однако служба BLOB-объектов обладает отказоустойчивостью, поэтому полный сбой этой службы является крайне маловероятным.
- Если задача, выполняемая лидером, останавливается, то лидер может по-прежнему возобновить аренду. При этом никакой другой экземпляр не сможет получить аренду и занять роль лидера для координации задач. В реальной среде работоспособность лидера должна проверяться достаточно часто.
- Процесс выбора является недетерминированным. Вы не можете допустить каких-либо предположений о том, какой экземпляр роли получит аренду большого двоичного объекта и станет лидером.
- Большой двоичный объект, используемый в качестве целевого объекта аренды большого двоичного объекта, не должен использоваться ни для какой иной цели. Если экземпляр роли попытается сохранить данные в большой двоичный объект, то эти данные не станут доступными, пока экземпляр роли не станет лидером и не получит аренду большого двоичного объекта.

## <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации

При реализации этого шаблона следует принять во внимание следующие рекомендации:

- Этот шаблон содержит доступный для скачивания [пример приложения](https://github.com/mspnp/cloud-design-patterns/tree/master/leader-election).
- [Руководство по автоматическому масштабированию](https://msdn.microsoft.com/library/dn589774.aspx). Существует возможность запускать и останавливать экземпляры узлов задач, так как нагрузка на приложение варьируется. Автомасштабирование может быть полезным для поддержания пропускной способности и производительности во время максимальной нагрузки.
- [Рекомендации по разделению вычислений](https://msdn.microsoft.com/library/dn589773.aspx). В этом руководстве описывается выделение задач для узлов в облачной службе, которое позволяет свести к минимуму эксплуатационные расходы при сохранении масштабируемости, производительности, доступности и безопасности службы.
- [Task-based Asynchronous Pattern ](https://msdn.microsoft.com/library/hh873175.aspx) (Асинхронная модель на основе задач).
- Пример, демонстрирующий [алгоритм Bully](https://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/BullyExample.html).
- Пример, демонстрирующий [алгоритм Ring](https://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/RingElectExample.html).
- [Apache Curator](https://curator.apache.org/) — клиентская библиотека для Apache ZooKeeper.
- Статья [Lease Blob](https://msdn.microsoft.com/library/azure/ee691972.aspx) (Аренда большого двоичного объекта) на сайте MSDN.

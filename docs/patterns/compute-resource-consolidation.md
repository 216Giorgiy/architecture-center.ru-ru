---
title: Шаблон консолидации вычислительных ресурсов
titleSuffix: Cloud Design Patterns
description: Вы можете объединить несколько задач и операций в единый вычислительный блок.
keywords: Конструктивный шаблон
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 4cd9b7f02ba3b2a9766a2493353da6b6488ba8a2
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/23/2019
ms.locfileid: "54485347"
---
# <a name="compute-resource-consolidation-pattern"></a>Шаблон консолидации вычислительных ресурсов

[!INCLUDE [header](../_includes/header.md)]

Вы можете объединить несколько задач и операций в единый вычислительный блок. Это повысит эффективность использования вычислительных ресурсов и сократит расходы на выполнение вычислительной обработки в облачных приложениях и управление ею.

## <a name="context-and-problem"></a>Контекст и проблема

В облачных приложениях часто реализованы сразу несколько разных операций. В некоторых решениях следует с самого начала применить принцип разделения функций, выделяя разные операции в отдельные вычислительные блоки для раздельного хранения и развертывания (например, в виде отдельных веб-приложений службы приложений, на отдельных виртуальных машинах или в отдельных ролях облачной службы). Такая стратегия упрощает логическую структуру решения, но развертывание большого числа вычислительных блоков повышает затраты на размещение среды для приложения и усложняет управление системой.

На приведенном выше рисунке представлен упрощенный пример структуры облачного решения с несколькими вычислительными блоками. Каждый вычислительный блок выполняется в собственной виртуальной среде. Каждая функция реализована как отдельная задача (обозначены буквами от A до E), которая выполняется в своем вычислительном блоке.

![Выполнение задач в облачной среде с помощью набора выделенных вычислительных блоков](./_images/compute-resource-consolidation-diagram.png)

Для каждого вычислительного блока используются оплачиваемые ресурсы, даже в периоды простоя или низкой нагрузки. Это означает, что такое решение может оказаться не самым экономичным.

В Azure эта проблема касается ролей облачной службы и службы приложений, а также виртуальных машин. Эти элементы выполняются в виртуальной среде. Эффективность использования ресурсов будет невысока, если в рамках одного решения выполняется большая коллекция отдельных ролей, веб-сайтов и (или) виртуальных машин, которые отвечают за четко разделенные операции, но вынуждены взаимодействовать и обмениваться информацией.

## <a name="solution"></a>Решение

Чтобы снизить затраты, повысить эффективность использования ресурсов и скорость обмена данными, а также упростить управление, вы можете объединять группы задач и операций в вычислительные блоки.

Задачи можно группировать по разным критериям в зависимости от возможностей, предоставляемых средой, и их стоимости. Часто объединяются задачи со схожими профилями по масштабируемости, периодам существования и требованиям к обработке. Такое группирование позволяет масштабировать задачи как единый блок. Гибкость многих облачных сред дает возможность легко запускать и останавливать экземпляры вычислительных блоков в соответствии с текущей нагрузкой. Например, Azure поддерживает автомасштабирование для виртуальных машин, ролей облачной службы и службы приложений. Дополнительные сведения см. в [руководстве по автомасштабированию](https://msdn.microsoft.com/library/dn589774.aspx).

Масштабируемость позволяет определить, какие операции не следует группировать. В качестве примера давайте рассмотрим следующие две задачи.

- В задаче 1 выполняется опрос очереди, чтобы определить сообщения, которые поступают редко и не требуют срочной обработки.
- В задаче 2 обрабатываются большие объемы внезапно возникающего сетевого трафика.

Вторая задача требует эластичности, то есть возможности запускать и останавливать большое число экземпляров вычислительных блоков. Если применить такой же принцип масштабирования к первой задаче, мы просто получим большое число одинаковых задач ожидания для редко поступающих сообщений в одной и той же очереди. Это очевидно бесполезная трата ресурсов.

В многих облачных средах можно найти ресурсы, которые следует поместить в один вычислительный блок, со схожими требованиями к числу ядер ЦП, памяти, дисковому пространству и т. д. Как правило, стоимость растет в прямой зависимости от объема ресурсов. Чтобы сократить затраты, важно максимально загрузить дорогостоящие вычислительные блоки и не допускать для них продолжительного простоя.

Если у вас есть задачи, для которых требуется значительная мощность процессора на короткие периоды времени, попробуйте объединить их в отдельный вычислительный блок, который предоставит необходимую мощность. Но в такой ситуации важно еще и защитить дорогостоящие ресурсы от проблем, связанных с состоянием состязания при чрезмерной нагрузке на них. Например, не следует располагать в одном вычислительном блоке задачи, для которых длительно используется значительная вычислительная мощность.

## <a name="issues-and-considerations"></a>Проблемы и рекомендации

Реализуя этот шаблон, учитывайте указанные ниже факторы.

**Масштабируемость и эластичность.** Многие облачные решения поддерживают масштабируемость и эластичность на уровне вычислительного блока, запуская и останавливая его дополнительные экземпляры. Старайтесь не группировать в одном вычислительном блоке задачи с противоречивыми требованиями к масштабируемости.

**Время существования.** В облачной инфраструктуре периодически удаляются виртуальные среды, в которых размещены вычислительные блоки. Если в одном вычислительном блоке выполняется сразу несколько длительных задач, укажите дополнительные настройки для защиты этого блока от удаления до завершения всех задач. Еще один вариант решения такой проблемы: используйте принцип контрольных точек, который позволит правильно завершать выполнение задач и возобновлять его с того же момента, когда вычислительный блок будет перезапущен.

**Частота изменений.** Если у вас часто меняется способ реализации или конфигурация задач, для обновления кода и (или) изменения настроек вам придется часто останавливать и перезапускать соответствующий вычислительный блок. Это означает, что остановка, развертывание и повторный запуск коснутся и всех других задач в том же вычислительном блоке.

**Безопасность**. Задачи в одном вычислительном блоке могут иметь одинаковый контекст безопасности и обращаться к одним и тем же ресурсам. Требуется высокий уровень доверия между задачами и уверенность в том, что ни одна из них не будет препятствовать другим или негативно на них влиять. Кроме того, увеличение числа задач в вычислительном блоке повышает его уязвимость для атак. Каждая из задач в блоке будет иметь тот же уровень безопасности, что и задача с самой высокой степенью уязвимости.

**Отказоустойчивость.** Если любая задача в вычислительном блоке завершится сбоем или в ее рамках будут выполнены некорректные действия, это может повлиять на другие задачи в том же вычислительном блоке. Например, если одна из задач не запускается корректным образом, нарушается вся логика запуска в этом вычислительном блоке. Это может помешать запуску остальных задач в блоке.

**Состязание.** Избегайте ситуаций состязания за ресурсы между задачами в одном вычислительном блоке. Очень желательно, чтобы в одном вычислительном блоке размещались задачи с разными характеристики по использованию ресурсов. Например, не стоит группировать в один вычислительный блок две задачи с высокой вычислительной нагрузкой или потреблением памяти. Но неплохим вариантом станет объединение задачи с большим объемом вычислений и задачи, требующей большого объема памяти.

> [!NOTE]
> Объединение вычислительных ресурсов следует применять только к системам, которые уже значительное время действуют в рабочей среде. Это важно для того, чтобы операторы и разработчики накопили достаточно статистических данных мониторинга для достоверной _тепловой карты_, в которой описано потребление разных ресурсов каждой задачей. Такая карта позволит определить, какие задачи целесообразно размещать в общих вычислительных ресурсах.

**Сложность.** Объединение нескольких задач в один вычислительный блок усложняет код этого блока, что может затруднить тестирование, отладку и поддержку.

**Стабильная логическая архитектура.** Проектируйте и создавайте код каждой задачи так, чтобы его не нужно было изменять даже при изменениях физической среды, в которой выполняется задача.

**Другие стратегии.** Группирование вычислительных ресурсов — лишь один из многих способов снижения затрат, связанных с параллельным выполнением большого числа задач. Чтобы этот подход сохранил эффективность, его нужно тщательно планировать и постоянно контролировать. Возможно, другие стратегии будут более эффективными, учитывая характер ваших задач и местонахождение пользователей. Например, оптимальным решением может оказаться функциональная декомпозиция рабочей нагрузки (как описано в [руководстве по секционированию вычислений](https://msdn.microsoft.com/library/dn589773.aspx)).

## <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон

Этот шаблон применим для задач, которые недостаточно экономичны при выполнении в отдельном вычислительном блоке. Если задача значительное время находится в состоянии простоя, отдельный вычислительный блок для такой задачи будет дорогостоящим решением.

Этот шаблон не слишком подходит для задач, в рамках которых выполняются операции с критически важным уровнем отказоустойчивости или обрабатываются крайне важные и конфиденциальные данные, то есть для задач, требующих особого контекста безопасности. Такие задачи следует выполнять в собственной изолированной среде, помещенной в отдельный вычислительный блок.

## <a name="example"></a>Пример

Создавая облачную службу в Azure, вы можете объединить в одну роль вычислительные процессы нескольких задач. Обычно для этого используется рабочая роль с задачами фоновой или асинхронной обработки.

> В некоторых случаях задачи асинхронной или фоновой обработки можно включить в веб-роль. Это позволит сократить затраты и упростить развертывание, но негативно повлияет на масштабируемость и скорость реагирования общедоступного веб-интерфейса, который реализован в этой веб-роли.

Используемая роль отвечает за запуск и остановку задач. Когда контроллер структуры Azure загружает такую роль, он вызывает для нее событие `Start`. Вы можете переопределить метод `OnStart` в классе `WebRole` или `WorkerRole`, чтобы обработать это событие, например инициализировать данные и другие ресурсы для задач в этом методе.

После выполнения метода `OnStart` роль будет готова отвечать на запросы. Дополнительные сведения и рекомендации по использованию методов роли `OnStart` и `Run` вы найдете в разделе [Процессы запуска приложения](https://msdn.microsoft.com/library/ff803371.aspx#sec16) из руководства по шаблонам и методикам [переноса приложений в облако](https://msdn.microsoft.com/library/ff728592.aspx).

> Старайтесь применять в методе `OnStart` максимально компактный код. В Azure не применяются ограничения на время, необходимое для выполнения этого метода. Но пока он не завершится, роль не будет реагировать на сетевые запросы.

Когда завершается метод `OnStart`, в роли выполняется метод `Run`. Только в этот момент контроллер структуры начинает передачу запросов к роли.

Весь код, при помощи которого фактически создаются задачи, следует помещать в метод `Run`. Обратите внимание, что метод `Run` определяет время существования экземпляра роли. Когда завершается выполнение этого метода, контроллер структуры завершает работу всей роли.

При отключении или удалении роли контроллер структуры останавливает прием запросов от подсистемы балансировки нагрузки и вызывает событие `Stop`. Чтобы перехватить это событие, переопределите метод роли `OnStop` и выполните в нем все необходимые очистки перед завершением работы роли.

> Действия, которые выполняются в методе `OnStop`, должны завершиться не более чем через пять минут (или 30 секунд, если вы используете эмулятор Azure на локальном компьютере). Иначе контроллер структуры Azure определяет, что выполнение роли остановлено, и принудительно завершает ее работу.

Задачи запускаются при помощи метода `Run`, который ожидает их завершения. В этих задачах реализуется бизнес-логика облачной службы. Кроме того, они отвечают на сообщения, переданные через подсистему балансировки нагрузки Azure. На этой схеме представлен жизненный цикл задач и ресурсов в роли облачной службы Azure.

![Жизненный цикл задач и ресурсов в роли облачной службы Azure](./_images/compute-resource-consolidation-lifecycle.png)

Файл _WorkerRole.cs_ из проекта _ComputeResourceConsolidation.Worker_ содержит пример реализации этого шаблона в облачной службе Azure.

> Проект _ComputeResourceConsolidation.Worker_ является частью решения _ComputeResourceConsolidation_, которое можно скачать из репозитория [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/compute-resource-consolidation).

Методы `MyWorkerTask1` и `MyWorkerTask2` демонстрируют, как выполнять разные задачи в одной рабочей роли. При помощи приведенного ниже кода выполняется задача `MyWorkerTask1`. В рамках этой простой задачи в течение 30 секунд не выполняются никакие действия, а затем выводится сообщение трассировки. Этот процесс повторяется, пока задача не будет отменена. Для `MyWorkerTask2` используется аналогичный код.

```csharp
// A sample worker role task.
private static async Task MyWorkerTask1(CancellationToken ct)
{
  // Fixed interval to wake up and check for work and/or do work.
  var interval = TimeSpan.FromSeconds(30);

  try
  {
    while (!ct.IsCancellationRequested)
    {
      // Wake up and do some background processing if not canceled.
      // TASK PROCESSING CODE HERE
      Trace.TraceInformation("Doing Worker Task 1 Work");

      // Go back to sleep for a period of time unless asked to cancel.
      // Task.Delay will throw an OperationCanceledException when canceled.
      await Task.Delay(interval, ct);
    }
  }
  catch (OperationCanceledException)
  {
    // Expect this exception to be thrown in normal circumstances or check
    // the cancellation token. If the role instances are shutting down, a
    // cancellation request will be signaled.
    Trace.TraceInformation("Stopping service, cancellation requested");

    // Rethrow the exception.
    throw;
  }
}
```

> Этот пример кода содержит стандартную реализацию фонового процесса. Вы можете использовать эту структуру в реальных приложениях, разместив собственную логику обработки в теле цикла, который ожидает запроса на отмену.

Сначала в роли инициализируются используемые ресурсы, а затем применяется метод `Run` для параллельного запуска двух задач, как показано в этом примере.

```csharp
/// <summary>
/// The cancellation token source use to cooperatively cancel running tasks
/// </summary>
private readonly CancellationTokenSource cts = new CancellationTokenSource();

/// <summary>
/// List of running tasks on the role instance
/// </summary>
private readonly List<Task> tasks = new List<Task>();

// RoleEntry Run() is called after OnStart().
// Returning from Run() will cause a role instance to recycle.
public override void Run()
{
  // Start worker tasks and add to the task list
  tasks.Add(MyWorkerTask1(cts.Token));
  tasks.Add(MyWorkerTask2(cts.Token));

  foreach (var worker in this.workerTasks)
  {
      this.tasks.Add(worker);
  }

  Trace.TraceInformation("Worker host tasks started");
  // The assumption is that all tasks should remain running and not return,
  // similar to role entry Run() behavior.
  try
  {
    Task.WaitAll(tasks.ToArray());
  }
  catch (AggregateException ex)
  {
    Trace.TraceError(ex.Message);

    // If any of the inner exceptions in the aggregate exception
    // are not cancellation exceptions then re-throw the exception.
    ex.Handle(innerEx => (innerEx is OperationCanceledException));
  }

  // If there wasn't a cancellation request, stop all tasks and return from Run()
  // An alternative to canceling and returning when a task exits would be to
  // restart the task.
  if (!cts.IsCancellationRequested)
  {
    Trace.TraceInformation("Task returned without cancellation request");
    Stop(TimeSpan.FromMinutes(5));
  }
}
...
```

Здесь метод `Run` ожидает завершения задачи. Если задача отменяется, метод `Run` определяет, что роль должна завершить работу. Он ожидает отмены остальных задач. Затем работа завершается (если период ожидания достигает пяти минут, завершение работы выполняется принудительно). Если задача завершается ожидаемым исключением, метод `Run` отменяет эту задачу.

> Вы можете реализовать в методе `Run` расширенные стратегии мониторинга и обработки исключений, например повторно запускать завершившиеся сбоем задачи или предоставить код для остановки и запуска отдельных задач.

Метод `Stop` из следующего примера кода вызывается, когда контроллер структуры завершает работу экземпляра роли (из метода `OnStop`). Этот код позволяет корректно завершить все задачи, отправляя им запросы на отмену. Если выполнение любой из задач потребует более пяти минут, механизм отмены обработки из метода `Stop` прекращает ожидание и работа роли принудительно завершается.

```csharp
// Stop running tasks and wait for tasks to complete before returning
// unless the timeout expires.
private void Stop(TimeSpan timeout)
{
  Trace.TraceInformation("Stop called. Canceling tasks.");
  // Cancel running tasks.
  cts.Cancel();

  Trace.TraceInformation("Waiting for canceled tasks to finish and return");

  // Wait for all the tasks to complete before returning. Note that the
  // emulator currently allows 30 seconds and Azure allows five
  // minutes for processing to complete.
  try
  {
    Task.WaitAll(tasks.ToArray(), timeout);
  }
  catch (AggregateException ex)
  {
    Trace.TraceError(ex.Message);

    // If any of the inner exceptions in the aggregate exception
    // are not cancellation exceptions then rethrow the exception.
    ex.Handle(innerEx => (innerEx is OperationCanceledException));
  }
}
```

## <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации

При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.

- [Руководство по автоматическому масштабированию](https://msdn.microsoft.com/library/dn589774.aspx). Автомасштабирование позволяет запускать и останавливать экземпляры службы, в которой размещаются вычислительные ресурсы, в зависимости от ожидаемой потребности в обработке.

- [Compute Partitioning Guidance](https://msdn.microsoft.com/library/dn589773.aspx) (Рекомендации по секционированию вычислений). В этом руководстве описан метод выделения служб и компонентов в облачной службе, который позволяет снизить эксплуатационные расходы при сохранении всех важных характеристик службы: масштабируемости, производительности, доступности и безопасности.

- Этот шаблон содержит доступный для скачивания [пример приложения](https://github.com/mspnp/cloud-design-patterns/tree/master/compute-resource-consolidation).

---
title: Шаблон источников событий
titleSuffix: Cloud Design Patterns
description: Использование инкрементируемого хранилища для сохранения всей последовательности событий, то есть всех действий с данными в домене.
keywords: Конструктивный шаблон
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 0183342257c676538aedc073f4f31a1c38ffdeef
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/20/2019
ms.locfileid: "58248799"
---
# <a name="event-sourcing-pattern"></a>Шаблон источников событий

[!INCLUDE [header](../_includes/header.md)]

Вместо сохранения текущего состояния данных в домене используйте инкрементируемое хранилище для записи полных серий действий с этими данными.
Хранилище действует как система записи, и его можно использовать для материализации объектов домена. Это позволяет упростить задачи в сложных доменах, устраняя необходимость синхронизации модели данных и домена для бизнеса при одновременном повышении производительности, масштабируемости и скорости реагирования. Кроме того, обеспечивается совместимость транзакционных данных и сохранение всех журналов аудита и истории, с помощью которых можно использовать компенсирующие действия.

## <a name="context-and-problem"></a>Контекст и проблема

Большинство приложений работают с данными, и типичный подход, используемый в приложении, — поддержка текущего состояния данных за счет обновления по мере работы с ними. Например, в традиционной модели создания, чтения, обновления и удаления (CRUD) типичная обработка данных представляет собой считывание данных из хранилища, внесение в них определенных изменений и обновление их текущего состояния с помощью новых значений (часто с помощью транзакций блокирования данных).

Для такого подхода CRUD предусмотрены некоторые ограничения:

- Системы CRUD выполняют операции обновления непосредственно в хранилище данных, которые могут замедлять производительность и скорость реагирования и ограничивать масштабируемость — все это из-за требуемой дополнительной нагрузки.

- В домене для совместной работы с большим количеством параллельных подключений пользователей более вероятны возникновения конфликтов обновления данных, так как операции обновления выполняются для отдельного элемента данных.

- Если отсутствует дополнительный механизм аудита, записывающий подробности каждой операции в отдельный журнал, история не сохраняется.

> Чтобы лучше понять ограничения, связанные с архитектурой CRUD, ознакомьтесь с [этой](https://blogs.msdn.microsoft.com/maarten_mullender/2004/07/23/crud-only-when-you-can-afford-it-revisited/) записью блога.

## <a name="solution"></a>Решение

Шаблон источника событий определяет подход к обработке операций с данными на основе последовательности событий, каждое из которых записывается в инкрементируемое хранилище. Код приложения отправляет ряд событий, которые принудительно описывают каждое действие с данными в хранилище событий, где они сохраняются. Каждое событие обозначает некоторый набор изменений в данных (например, `AddedItemToOrder`).

События сохраняются в хранилище событий, которое выступает в качестве системы записи (заслуживающий доверие источник данных) текущего состояния данных. Хранилище событий обычно публикует эти события для оповещения потребителей и при необходимости предоставления им возможности обрабатывать эти события. Потребители могут, например, запустить задачи, применяющие операции в событиях к другим системам, или выполнить любое другое связанное действие, необходимое для завершения операции. Обратите внимание, что код приложения, создающий события, никак не связан с системами, подписанными на эти события.

Стандартное использование событий, опубликованных хранилищем событий, включает поддержку материализованных представлений сущностей по мере их изменения в приложении с помощью действий, а также интеграцию с внешними системами. Например, система может поддерживать материализованное представление всех заказов клиента, используемых для заполнения частей пользовательского интерфейса. По мере добавления новых заказов, добавления или удаления позиций в заказе или добавления сведений о доставке в приложении события, описывающие эти изменения, можно обрабатывать, а также использовать для обновления [материализованного представления](./materialized-view.md).

Кроме того, приложения могут в любой момент считать историю событий и использовать ее для материализации текущего состояния сущности за счет воспроизведения и использования всех событий, которые относятся к этой сущности. Это можно сделать по запросу для материализации объекта домена при обработке запроса или в запланированной задаче для сохранения состояния сущности в виде материализованного представления для поддержки уровня представления.

На схеме ниже представлен обзор шаблона, включая некоторые варианты использования потока событий, например создание материализованного представления, интеграцию событий с внешними приложениями и системами, а также воспроизведение событий для создания проекций текущего состояния определенных сущностей.

![Обзор и пример шаблона источника событий](./_images/event-sourcing-overview.png)

Шаблон источника событий предоставляет следующие преимущества.

- События являются неизменяемыми, и их можно сохранить с помощью инкрементируемой операции. Вы можете не завершать работу источника, с помощью которого было активировано событие (пользовательский интерфейс, рабочий процесс или любой другой процесс), а задачи, обрабатывающие события, могут выполняться в фоновом режиме. Таким образом, с учетом отсутствия конкурирующих процессов во время обработки транзакций может значительно улучшиться производительность и масштабируемость приложений, особенно для уровня презентации или интерфейса пользователя.

- События представляют собой простые объекты, которые описывают некоторые выполненные действия, а также связанные данные, необходимые для описания действия, представленного событием. События не имеют прямого отношения к обновлению хранилища данных. Они просто записываются для обработки в соответствующее время. Это позволяет упростить управление и реализацию.

- События представляют определенную ценность для специалиста по работе с доменами, а [объектно-реляционная несогласованность](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch) может усложнить понимание сложных таблиц базы данных. Таблицы представляют собой искусственные конструкции, отображающие текущее состояние системы, а не произошедшие события.

- Источник событий может помочь предотвратить возникновение конфликтов, вызванных параллельными обновлениями, так как исключает необходимость непосредственного обновления объектов в хранилище данных. Однако модель домена по-прежнему должна быть разработана для собственной защиты от запросов, которые могут вызвать несогласованное состояние.

- Инкрементируемое хранилище событий предоставляет журнал аудита, который можно использовать для мониторинга событий, произошедших в хранилище данных, повторного создания текущего состояния в виде материализованного представления или проекций путем воспроизведения событий в любое время, а также упрощения тестирования и отладки системы. Кроме того, необходимость использовать компенсирующие события для отмены изменений предоставляет журнал изменений, которые были отменены, чего можно было бы избежать, если бы модель просто сохранила текущее состояние. Список событий можно также использовать для анализа производительности приложения и выявления тенденций поведения пользователя или получения других полезных бизнес-сведений.

- Хранилище событий вызывает события, а задачи выполняют операции в ответ на эти события. Это разделение задач и событий обеспечивает гибкость и расширяемость. Задачи "знают" о типе и данных события, но не об операции, вызвавшей это событие. Кроме того, каждое событие могут обрабатывать несколько задач. Это обеспечивает простую интеграцию с другими службами и системами, которые только прослушивают новые события, вызванные хранилищем событий. Однако события источника событий зачастую являются низкоуровневыми, из-за чего может потребоваться создание определенных событий интеграции.

> Источник событий часто сочетается с шаблоном CQRS за счет выполнения задач управления данными в ответ на события, а также материализации представления из хранимых событий.

## <a name="issues-and-considerations"></a>Проблемы и рекомендации

При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.

Система будет согласованной в конечном счете только при создании материализованных представлений или проекций данных путем воспроизведения событий. Между добавлением событий приложения в хранилище событий (в результате обработки запроса), публикацией событий и обработкой событий потребителями есть некоторая задержка. В течение этого периода в хранилище событий могли попасть новые события, описывающие дальнейшие изменения сущностей.

> [!NOTE]
> Дополнительные сведения о реализации итоговой согласованности см. в [руководстве по согласованности данных](https://msdn.microsoft.com/library/dn589800.aspx).

Хранилище событий представляет собой постоянный источник данных и таким образом исключает необходимость обновления данных событий. Единственный способ обновить сущность для отмены изменения — добавить компенсирующее событие в хранилище событий. Если необходимо изменить формат (а не данные) сохраненных событий (возможно, во время миграции), может возникнуть сложность при объединении имеющихся событий в хранилище с новой версией. Может потребоваться выполнить итерацию всех событий, внеся изменения для соответствия событий новому формату, или добавить новые события, использующие новый формат. Рассмотрите возможность использования штампа версии в каждой версии схемы события для поддержки прежнего и нового форматов событий.

Многопоточные приложения и несколько экземпляров приложений могут сохранять события в хранилище событий. Согласованность событий в хранилище событий крайне важна, так как представляет собой порядок событий, влияющих на определенную сущность (порядок событий, который вызывает изменения в отношении сущности, влияет на ее текущее состояние). Добавление метки времени для каждого события может помочь избежать проблем. Другой распространенной практикой является добавление заметок для каждого события, вызванного запросом с добавочным идентификатором. Если два действия пытаются добавить события для одной сущности одновременно, хранилище событий может отклонить событие, которое соответствует идентификатору имеющейся сущности и идентификатору события.

Для считывания событий с целью получения сведений отсутствует стандартный подход или имеющиеся механизмы, например SQL-запросы. Единственные данные, которые можно извлечь, — это поток событий, использующий идентификатор события в качестве условия. Идентификатор события обычно сопоставляется с отдельными сущностями. Текущее состояние сущности можно определить только путем воспроизведения всех событий, связанных с ней в отношении исходного состояния этой сущности.

Продолжительность каждого потока события влияет на управление системой и ее обновление. Если потоки объемные, можно создать моментальные снимки через определенные интервалы, например указанное количество событий. Текущее состояние сущности можно получить из моментального снимка и за счет воспроизведения любого события, произошедшего после этой точки во времени. Дополнительные сведения о создании моментальных снимков данных см. на страницах, посвященных [моментальному снимку](https://martinfowler.com/eaaDev/Snapshot.html) и [репликации моментального снимка](https://msdn.microsoft.com/library/ff650012.aspx).

Несмотря на то что источник событий снижает вероятность конфликта из-за обновления данных, приложение все равно должно устранить несоответствия, возникшие в результате итоговой согласованности и недостатка транзакций. Например, событие, указывающее на сокращение складских запасов, может поступить в хранилище данных во время размещения заказа для этой позиции, вызывая необходимость согласования двух операций: с помощью уведомления клиента или создания обратного заказа.

Возможна как минимум одна публикация события, поэтому потребители событий должны быть идемпотентными. Они не должны повторно применять обновление, описанное в событии, если событие обрабатывается несколько раз. Например, если несколько экземпляров потребителя поддерживают статистическую обработку свойства сущности, например общее количество размещенных заказов, только для одного экземпляра успешно завершится добавление статистического выражения при возникновении события размещения заказа. Это не основная характеристика источника событий, а обычное решение реализации.

## <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон

Используйте этот шаблон в следующих сценариях:

- Когда в данные необходимо записать намерение, цель или причину. Например, изменения в сущности клиента можно записать как ряд определенных типов событий, таких как _Возвращение к исходному_, _Закрытая учетная запись_ или _Недействительные_.

- Когда крайне важно свести к минимуму или полностью избежать конфликта операций обновления данных.

- Если требуется записать происходящие события и иметь возможность воспроизвести их для восстановления состояния системы, отката изменений или сохранения истории и журнала аудита. Например, если задача включает несколько шагов, необходимых для восстановления обновлений и последующего воспроизведения некоторых действий для восстановления согласованного состояния данных.

- Когда использование событий представляет собой стандартную возможность операции приложения и требует некоторой дополнительной разработки или усилий в отношении реализации.

- Если нужно разбить процесс ввода или обновления данных из задач, необходимых для применения этих действий. Это может быть в целях улучшения производительности пользовательского интерфейса или распределения событий в другие прослушиватели, выполняющие определенные действия при возникновении событий. Например, интеграция платежной системы с веб-сайтом о расходах требуется для того, чтобы события, вызванные с помощью хранилища событий в ответ на обновления данных, реализованные для веб-сайта, использовались как веб-сайтом, так и платежной системой.

- Если необходима гибкость для изменения формата материализованных моделей и данных сущности при изменении требований или &mdash;использовании в сочетании с CQRS&mdash;, необходимо адаптировать модель чтения или представления с данными.

- Если используется в сочетании с CQRS, итоговая согласованность допустима при обновлении модели чтения или допустимо влияние на производительность при восстановленных сущностях и данных из потока события.

Этот шаблон неприменим в следующих случаях:

- Для небольших или простых доменов, систем, которым не достает бизнес-логики или она и вовсе отсутствует, систем, не имеющих отношения к домену, которые обычно хорошо взаимодействуют со стандартными механизмами управления данных CRUD.

- Систем, где для представления данных требуются согласованность и обновления в режиме реального времени.

- Систем, где для действий отката и воспроизведения не требуются определенные функции, история и журналы аудита.

- Систем, где имеется незначительный конфликт обновлений в базовых данных. Например, это системы, которые преимущественно добавляют данные, а не обновляют их.

## <a name="example"></a>Пример

Система управления конференцией должна отслеживать количество завершенных резервирований для конференц-связи, чтобы проверить наличие доступных мест при попытке потенциального участника зарезервировать место. Имеется по крайней мере два способа хранения общего числа заявок на бронирование для конференции в системе:

- Она может хранить сведения об общем количестве зарезервированных мест в качестве отдельной сущности в базе данных, содержащей данные о резервировании. После резервирования мест или отмены резервирования система может соответствующим образом регулировать это количество. Этот подход прост в теории, но может привести к проблемам с масштабируемостью, если большое количество участников попытается зарезервировать места за короткий период времени. Например, в последний день или перед непосредственным завершением периода резервирования.

- Система может хранить сведения о резервировании и отменах по мере выполнения событий в хранилище событий. Затем путем воспроизведения этих событий она может рассчитать количество доступных мест. Из-за неизменяемости событий этот подход может оказаться более масштабируемым. Системе необходимо только считывать данные из хранилища событий или добавлять их в это хранилище. Сведения события о резервировании и отменах никогда не изменяются.

На схеме ниже показано, как с помощью источника событий можно реализовать подсистему резервирования мест системы управления конференцией.

![Использование источника событий для записи сведений о резервировании мест в системе управления конференцией](./_images/event-sourcing-bounded-context.png)

Последовательность действий для резервирования двух мест выглядит следующим образом:

1. Пользовательский интерфейс выдает команду для резервирования мест для двух участников. Команда обрабатывается отдельным обработчиком команд. Часть логики, отделенная от пользовательского интерфейса и отвечающая за обработку запросов, записывается в виде команд.

2. Статистическое выражение, содержащее сведения о всех местах резервирования для конференции, создается с помощью запроса событий, описывающих операции резервирования и отмены. Это статистическое выражение называется `SeatAvailability` и содержится в модели домена, предоставляющей методы для запроса и изменения данных в статистической обработке.

    > Некоторые способы оптимизации, которые можно рассмотреть, включают использование моментальных снимков (таким образом, вам не нужно выполнять запрос и воспроизводить полный список событий для получения текущего состояния статистической обработки), а также сохранение кэшированной копии статистической обработки в памяти.

3. Для выполнения резервирования обработчик команд вызывает метод, предоставляемый моделью домена.

4. Статистическая функция `SeatAvailability` записывает событие, содержащее количество зарезервированных мест. При очередном применении событий статистической функцией все зарезервированные места будут использоваться для вычисления оставшихся мест.

5. Система добавляет новое событие в список событий в хранилище событий.

Если пользователь отменяет резервирование, в системе выполняется аналогичный процесс, за исключением того, что обработчик команд выдает команду, которая создает событие отмены места и добавляет это событие в хранилище событий.

Кроме предоставления дополнительных областей масштабируемости с помощью хранилища событий вы также получаете полный журнал или журнал аудита резервирования и отмены для конференции. События в хранилище событий представляют собой точные записи. Сохранять статистические функции любым другим способом не нужно, так как система способна легко воспроизводить события и восстанавливать состояние до любой точки во времени.

> Дополнительные сведения об этом примере можно найти в руководстве, посвященном [обзору источника событий](https://msdn.microsoft.com/library/jj591559.aspx).

## <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации

При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.

- [Шаблон выделения ответственности команды и запроса (CQRS)](./cqrs.md). В хранилище записи, предоставляющее постоянный источник информации для реализации CQRS, часто используется реализация шаблона источника событий. В этом шаблоне описывается, как отделить операции, считывающие данные в приложении, от операций обновления данных с помощью отдельных интерфейсов.

- [Materialized View Pattern](./materialized-view.md) (Шаблон материализованного представления). Хранилище данных, используемое в системе на основе источника событий, для создания запросов обычно не подходит. Вместо этого наиболее распространенным подходом является создание предварительно заполненных представлений данных через регулярные интервалы или при изменении данных. Здесь можно рассмотреть реализацию.

- [Шаблон компенсирующих транзакций](./compensating-transaction.md). Имеющиеся данные в хранилище источника событий не обновляются, вместо этого добавляются новые записи, которые преобразуют состояние сущностей в новые значения. Чтобы отменить изменение, используются компенсирующие записи, так как невозможно просто отменить предыдущее изменение. Этот шаблон описывает, как отменить задачи, выполненные с помощью предыдущей операции.

- [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx) (Руководство по обеспечению согласованности данных). При использовании источника событий с отдельным хранилищем чтения или материализованными представлениями данные для считывания не будут сразу согласованными, они будут только согласованными в конечном счете. В руководстве приведена сводка проблем, возникающих при обеспечении согласованности распределенных данных.

- [Data Partitioning Guidance](https://msdn.microsoft.com/library/dn589795.aspx) (Руководство по секционированию данных). При использовании источника событий данные часто секционируются, чтобы улучшить масштабируемость, снизить число конфликтов и оптимизировать производительность. В этом руководстве описывается, как разделить данные на дискретные секции, а также проблемы, с которыми можно столкнуться.

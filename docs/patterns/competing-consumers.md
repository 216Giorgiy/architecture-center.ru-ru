---
title: Шаблон конкурирующих потребителей
titleSuffix: Cloud Design Patterns
description: Несколько конкурирующих потребителей обрабатывают сообщения, полученные в одном канале обмена сообщениями.
keywords: Конструктивный шаблон
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: ea3f48971a78f59ad6575b055278aab449fa26a1
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/23/2019
ms.locfileid: "54485236"
---
# <a name="competing-consumers-pattern"></a>Шаблон конкурирующих потребителей

[!INCLUDE [header](../_includes/header.md)]

Несколько конкурирующих потребителей обрабатывают сообщения, полученные в одном канале обмена сообщениями. Это позволяет обрабатывать несколько сообщений одновременно, чтобы оптимизировать пропускную способность для повышения масштабируемости и доступности, а также для распределения рабочей нагрузки в системе.

## <a name="context-and-problem"></a>Контекст и проблема

Приложение, работающее в облаке, должно обрабатывать большое количество запросов. Вместо того чтобы обрабатывать каждый запрос синхронно, обычно приложение передает их через систему обмена сообщениями в другую службу (служба потребителя), которая обрабатывает их асинхронно. Эта стратегия позволяет гарантировать, что бизнес-логика в приложении не будет блокироваться во время обработки запросов.

Количество запросов может существенно варьироваться со временем по многим причинам. Внезапное увеличение активности пользователей или агрегированных запросов в нескольких клиентах может вызвать непредсказуемую рабочую нагрузку. В часы максимальной нагрузки системе может потребоваться обрабатывать сотни запросов в секунду. Однако в другое время количество запросов может быть небольшим. Кроме того, характер выполняемой работы для обработки этих запросов может сильно изменяться. Использование одного экземпляра службы потребителя может привести к тому, что экземпляр будет переполнен запросами или система обмена сообщениями может быть перегружена из-за потока сообщений из приложения. Для обработки этой изменяющейся рабочей нагрузки система может выполнить несколько экземпляров службы потребителя. Однако этих потребителей необходимо скоординировать, чтобы обеспечить доставку каждого сообщения отдельному потребителю. Необходимо также сбалансировать рабочую нагрузку среди потребителей, чтобы экземпляр не вызывал проблемы с производительностью.

## <a name="solution"></a>Решение

С помощью очереди сообщений можно реализовать коммуникационный канал между приложением и экземплярами службы потребителя. Приложение отправляет запросы в виде сообщения в очередь. Экземпляры службы потребителя получают сообщения из очереди и обрабатывают их. Такой подход позволяет одному пулу экземпляров службы потребителя обрабатывать сообщения из любого экземпляра приложения. На рисунке ниже показано использование очереди сообщений для распределения нагрузки в экземплярах службы.

![Использование очереди сообщений для распределения нагрузки в экземплярах службы](./_images/competing-consumers-diagram.png)

Это решение имеет следующие преимущества:

- Оно предоставляет систему с выровненной нагрузкой, которая может обрабатывать большое число запросов, отправленных экземплярами приложения. Очередь выступает в качестве буфера между экземплярами приложения и экземплярами службы потребителя. Это может помочь минимизировать влияние на доступность и скорость реагирования экземпляров приложения и службы, как описано в статье [Queue-Based Load Leveling pattern](./queue-based-load-leveling.md) (Шаблон балансировки нагрузки на основе очередей). Длительная обработка сообщений не предотвращает параллельную обработку других сообщений другими экземплярами службы потребителя.

- Это повышает надежность. Если производитель взаимодействует с потребителем напрямую, вместо того чтобы использовать этот шаблон, но не отслеживает его, существует высокая вероятность того, что сообщения могут быть утеряны или их не удастся обработать, если произойдет сбой потребителя. В этом шаблоне сообщения не отправляются в конкретный экземпляр службы. Поврежденный экземпляр службы не будет блокировать производителя, и сообщения можно обрабатывать с помощью любого рабочего экземпляра службы.

- Это не требует комплексной координации между потребителями или между производителем и экземплярами потребителя. Очередь сообщений гарантирует, что каждое сообщение будет доставлено не менее одного раза.

- Оно масштабируемое. Система может динамически увеличивать или уменьшать количество экземпляров службы потребителя, так как объем сообщений может изменяться.

- Оно может улучшить устойчивость, если очередь сообщения предоставляет транзакционные операции считывания. Если экземпляр службы потребителя считывает и обрабатывает сообщение как часть транзакционной операции и происходит его сбой, этот шаблон может гарантировать, что сообщение будет возвращено в очередь, чтобы другой экземпляр службы потребителя мог выбрать его для обработки.

## <a name="issues-and-considerations"></a>Проблемы и рекомендации

При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.

- **Упорядочивание сообщений.** Порядок, в котором экземпляры службы потребителя получают сообщения, ненадежный и не обязательно должен совпадать с порядком создания сообщений. Разработайте систему, чтобы гарантировать идемпотентную обработку сообщений. Это поможет исключить любые зависимости в порядке обработки сообщений. Дополнительные сведения см. в статье, посвященной [шаблонам идемпотентности](https://blog.jonathanoliver.com/idempotency-patterns/) в блоге Джонатана Оливера (Jonathan Oliver).

    > Очереди служебной шины Microsoft Azure могут реализовать гарантированную доставку сообщений по методу FIFO ("первым прибыл, первым обслужен") с помощью сеансов обмена сообщениями. Дополнительные сведения см. в статье [Microsoft Azure Service Bus: шаблоны обмена сообщениями с использованием сеансов](https://msdn.microsoft.com/magazine/jj863132.aspx).

- **Разработка служб для обеспечения устойчивости.** Если система разработана, чтобы определять и перезапускать неработоспособные экземпляры служб, может понадобиться реализовать обработку, выполненную экземплярами службы в качестве отдельной операции, чтобы снизить воздействие одного сообщения, которое извлекается и обрабатывается более одного раза.

- **Определение сообщений о сбое.** Неправильно сформированные сообщения или задачи, которым требуется доступ к недоступным ресурсам, могут вызвать сбой экземпляра службы. Система должна предотвратить возвращение таких сообщений в очередь и вместо этого собрать и сохранить сведения об этих сообщениях в другом месте, чтобы при необходимости их можно было анализировать.

- **Обработка результатов.** Экземпляр службы, который обрабатывает сообщение, полностью отключен от логики приложения, которая создает сообщение. Они не могут взаимодействовать напрямую. Если экземпляр службы формирует результаты, которые должны быть переданы обратно в логику приложения, эти сведения должны храниться в доступном для них расположении. Чтобы логика приложения не получала неполные данные, система должна определять, когда обработка завершена.

     > Если вы используете Azure, рабочий процесс может передать результат обратно в логику приложения с помощью выделенной очереди ответов сообщения. Логика приложения должна секционировать эти результаты с исходным сообщением. Этот сценарий описан более подробно в [руководстве по асинхронному обмеру сообщениями](https://msdn.microsoft.com/library/dn589781.aspx).

- **Масштабирование системы обмена сообщениями.** В крупномасштабном решении одна очередь сообщений может быть переполненной количеством сообщений и может стать узким местом в системе. В этом случае попробуйте секционировать систему обмена сообщениями для отправки писем от конкретных поставщиков в определенные очереди. Вы также можете использовать балансировку нагрузки, чтобы распределить сообщения в нескольких очередях сообщений.

- **Обеспечение надежности системы обмена сообщениями.** Надежная система обмена сообщениями необходима, чтобы гарантировать, что сообщения не будут потеряны, когда приложение поставит их в очередь. Это важно, чтобы обеспечить доставку сообщений хотя бы раз.

## <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон

Используйте этот шаблон в следующих случаях:

- Рабочая нагрузка для приложения разделена на задачи, которые могут выполняться асинхронно.
- Задачи являются независимыми и могут выполняться параллельно.
- Объем работ может сильно изменяться, требуя масштабируемого решения.
- Решение должно предоставлять высокий уровень доступности и должно быть устойчивым в случае сбоя обработки задачи.

Этот шаблон может оказаться неэффективным в следующих случаях:

- Сложно разделить рабочую нагрузку приложения на дискретные задачи, или имеется высокий уровень зависимости между приложениями.
- Задачи необходимо выполнить синхронно, и логике приложения необходимо ждать завершения выполнения задачи, прежде чем продолжить.
- Задачи должны выполняться в определенной последовательности.

> Некоторые системы обмена сообщениями поддерживают сеансы, которые позволяют производителю группировать сообщения вместе и обеспечить их выполнение одним и тем же потребителем. Этот механизм можно использовать с приоритетными сообщениями (если они поддерживаются), чтобы реализовать вариант упорядочивания сообщений, который последовательно доставляет сообщения от производителя к одному потребителю.

## <a name="example"></a>Пример

Azure предоставляет очереди службы хранилища и очереди служебной шины, которые могут выступать в качестве механизма для реализации этого шаблона. Логика приложения может публиковать сообщения в очереди, а потребители, реализованные в качестве задач в одной или нескольких ролях, могут извлекать сообщения из этой очереди и обрабатывать их. Для обеспечения устойчивости очередь служебной шины позволяет потребителю использовать режим `PeekLock`, когда он извлекает сообщение из очереди. Этот режим фактически не удаляет сообщение, а просто скрывает его от других потребителей. Первоначальный потребитель может удалить сообщение по окончании его обработки. Если происходит сбой потребителя, срок блокировки просмотра истечет и сообщение снова станет видно. Другие потребители смогут его извлекать.

Дополнительные сведения об использовании очередей служебной шины Azure см. в статье [Очереди, разделы и подписки служебной шины](https://msdn.microsoft.com/library/windowsazure/hh367516.aspx).

Дополнительные сведения об использовании очередей хранилища Azure см. в статье [Приступая к работе с хранилищем очередей Azure с помощью .NET](/azure/storage/queues/storage-dotnet-how-to-use-queues).

В следующем примере кода из класса `QueueManager` в решении CompetingConsumers, доступном на сайте [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers), показано, как можно создать очередь с помощью экземпляра `QueueClient` в обработчике событий `Start` в веб-роли или рабочей роли.

```csharp
private string queueName = ...;
private string connectionString = ...;
...

public async Task Start()
{
  // Check if the queue already exists.
  var manager = NamespaceManager.CreateFromConnectionString(this.connectionString);
  if (!manager.QueueExists(this.queueName))
  {
    var queueDescription = new QueueDescription(this.queueName);

    // Set the maximum delivery count for messages in the queue. A message
    // is automatically dead-lettered after this number of deliveries. The
    // default value for dead letter count is 10.
    queueDescription.MaxDeliveryCount = 3;

    await manager.CreateQueueAsync(queueDescription);
  }
  ...

  // Create the queue client. By default the PeekLock method is used.
  this.client = QueueClient.CreateFromConnectionString(
    this.connectionString, this.queueName);
}
```

В следующем фрагменте кода показано, как приложение может создать пакет сообщений и отправить его в очередь.

```csharp
public async Task SendMessagesAsync()
{
  // Simulate sending a batch of messages to the queue.
  var messages = new List<BrokeredMessage>();

  for (int i = 0; i < 10; i++)
  {
    var message = new BrokeredMessage() { MessageId = Guid.NewGuid().ToString() };
    messages.Add(message);
  }
  await this.client.SendBatchAsync(messages);
}
```

В указанном ниже коде показано, как экземпляр службы потребителя может получать сообщения из очереди, используя подход на основе событий. Параметр `processMessageTask` метода `ReceiveMessages` является делегатом, который ссылается на код для выполнения во время получения сообщения. Этот код выполняется асинхронно.

```csharp
private ManualResetEvent pauseProcessingEvent;
...

public void ReceiveMessages(Func<BrokeredMessage, Task> processMessageTask)
{
  // Set up the options for the message pump.
  var options = new OnMessageOptions();

  // When AutoComplete is disabled it's necessary to manually
  // complete or abandon the messages and handle any errors.
  options.AutoComplete = false;
  options.MaxConcurrentCalls = 10;
  options.ExceptionReceived += this.OptionsOnExceptionReceived;

  // Use of the Service Bus OnMessage message pump.
  // The OnMessage method must be called once, otherwise an exception will occur.
  this.client.OnMessageAsync(
    async (msg) =>
    {
      // Will block the current thread if Stop is called.
      this.pauseProcessingEvent.WaitOne();

      // Execute processing task here.
      await processMessageTask(msg);
    },
    options);
}
...

private void OptionsOnExceptionReceived(object sender,
  ExceptionReceivedEventArgs exceptionReceivedEventArgs)
{
  ...
}
```

Обратите внимание, что функции автомасштабирования, например те, которые доступны в Azure, можно использовать для выполнения и остановки экземпляров роли при изменении длины очереди. Дополнительные сведения см. в [руководстве по автомасштабированию](https://msdn.microsoft.com/library/dn589774.aspx). Кроме того, нет необходимости обеспечивать прямое соответствие между экземплярами роли и рабочими процессами. Один экземпляр роли может реализовать несколько рабочих процессов. Дополнительные сведения см. в статье [Compute Resource Consolidation pattern](./compute-resource-consolidation.md) (Шаблон консолидации вычислительных ресурсов).

## <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации

При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.

- [Руководство по асинхронному обмену сообщениями](https://msdn.microsoft.com/library/dn589781.aspx). Очереди сообщений — это механизмы для асинхронного обмена данными. Если службе потребителя необходимо отправить ответ в приложение, может потребоваться реализовать некоторые варианты обмена сообщениями через ответы. Руководство по асинхронному обмену сообщениями предоставляет сведения о реализации обмена сообщениями через запрос или ответ с помощью очередей сообщения.

- [Руководство по автоматическому масштабированию](https://msdn.microsoft.com/library/dn589774.aspx). Вы можете выполнить и остановить экземпляры службы потребителя, так как длина очереди, в которой приложение публикует сообщения, отличается. Автомасштабирование может помочь поддерживать пропускную способность во время максимальной нагрузки.

- [Шаблон консолидации вычислительных ресурсов](./compute-resource-consolidation.md). Вы можете выполнить консолидацию нескольких экземпляров службы потребителя в один процесс, чтобы сократить расходы и затраты на управление. В статье Compute Resource Consolidation pattern (Шаблон консолидации вычислительных ресурсов) описаны преимущества и недостатки использования этого подхода.

- [Шаблон балансировки нагрузки на основе очередей](./queue-based-load-leveling.md). Добавление очереди сообщений может повысить устойчивость системы, позволить экземплярам службы обрабатывать разные объемы запросов из экземпляров приложения. Очередь сообщений работает как буфер, которой уравнивает нагрузку. Статья Queue-based Load Leveling pattern (Шаблон балансировки нагрузки на основе очередей) описывает этот сценарий более подробно.

- Этот шаблон имеет связанный с ним [образец приложения](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers).

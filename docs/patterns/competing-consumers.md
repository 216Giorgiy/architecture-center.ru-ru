---
title: Конкурирующие потребители
description: Несколько конкурирующих потребителей обрабатывают сообщения, полученные в одном канале обмена сообщениями.
keywords: Конструктивный шаблон
author: dragon119
ms.date: 06/23/2017
pnp.series.title: Cloud Design Patterns
pnp.pattern.categories:
- messaging
ms.openlocfilehash: aea172dcdb33c0d8513fb69715f1549b4a20f5e6
ms.sourcegitcommit: 94d50043db63416c4d00cebe927a0c88f78c3219
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/28/2018
ms.locfileid: "47428384"
---
# <a name="competing-consumers-pattern"></a><span data-ttu-id="434be-104">Шаблон конкурирующих потребителей</span><span class="sxs-lookup"><span data-stu-id="434be-104">Competing Consumers pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="434be-105">Несколько конкурирующих потребителей обрабатывают сообщения, полученные в одном канале обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="434be-105">Enable multiple concurrent consumers to process messages received on the same messaging channel.</span></span> <span data-ttu-id="434be-106">Это позволяет обрабатывать несколько сообщений одновременно, чтобы оптимизировать пропускную способность для повышения масштабируемости и доступности, а также для распределения рабочей нагрузки в системе.</span><span class="sxs-lookup"><span data-stu-id="434be-106">This enables a system to process multiple messages concurrently to optimize throughput, to improve scalability and availability, and to balance the workload.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="434be-107">Контекст и проблема</span><span class="sxs-lookup"><span data-stu-id="434be-107">Context and problem</span></span>

<span data-ttu-id="434be-108">Приложение, работающее в облаке, должно обрабатывать большое количество запросов.</span><span class="sxs-lookup"><span data-stu-id="434be-108">An application running in the cloud is expected to handle a large number of requests.</span></span> <span data-ttu-id="434be-109">Вместо того чтобы обрабатывать каждый запрос синхронно, обычно приложение передает их через систему обмена сообщениями в другую службу (служба потребителя), которая обрабатывает их асинхронно.</span><span class="sxs-lookup"><span data-stu-id="434be-109">Rather than process each request synchronously, a common technique is for the application to pass them through a messaging system to another service (a consumer service) that handles them asynchronously.</span></span> <span data-ttu-id="434be-110">Эта стратегия позволяет гарантировать, что бизнес-логика в приложении не будет блокироваться во время обработки запросов.</span><span class="sxs-lookup"><span data-stu-id="434be-110">This strategy helps to ensure that the business logic in the application isn't blocked while the requests are being processed.</span></span>

<span data-ttu-id="434be-111">Количество запросов может существенно варьироваться со временем по многим причинам.</span><span class="sxs-lookup"><span data-stu-id="434be-111">The number of requests can vary significantly over time for many reasons.</span></span> <span data-ttu-id="434be-112">Внезапное увеличение активности пользователей или агрегированных запросов в нескольких клиентах может вызвать непредсказуемую рабочую нагрузку.</span><span class="sxs-lookup"><span data-stu-id="434be-112">A sudden increase in user activity or aggregated requests coming from multiple tenants can cause an unpredictable workload.</span></span> <span data-ttu-id="434be-113">В часы максимальной нагрузки системе может потребоваться обрабатывать сотни запросов в секунду. Однако в другое время количество запросов может быть небольшим.</span><span class="sxs-lookup"><span data-stu-id="434be-113">At peak hours a system might need to process many hundreds of requests per second, while at other times the number could be very small.</span></span> <span data-ttu-id="434be-114">Кроме того, характер выполняемой работы для обработки этих запросов может сильно изменяться.</span><span class="sxs-lookup"><span data-stu-id="434be-114">Additionally, the nature of the work performed to handle these requests might be highly variable.</span></span> <span data-ttu-id="434be-115">Использование одного экземпляра службы потребителя может привести к тому, что экземпляр будет переполнен запросами или система обмена сообщениями может быть перегружена из-за потока сообщений из приложения.</span><span class="sxs-lookup"><span data-stu-id="434be-115">Using a single instance of the consumer service can cause that instance to become flooded with requests, or the messaging system might be overloaded by an influx of messages coming from the application.</span></span> <span data-ttu-id="434be-116">Для обработки этой изменяющейся рабочей нагрузки система может выполнить несколько экземпляров службы потребителя.</span><span class="sxs-lookup"><span data-stu-id="434be-116">To handle this fluctuating workload, the system can run multiple instances of the consumer service.</span></span> <span data-ttu-id="434be-117">Однако этих потребителей необходимо скоординировать, чтобы обеспечить доставку каждого сообщения отдельному потребителю.</span><span class="sxs-lookup"><span data-stu-id="434be-117">However, these consumers must be coordinated to ensure that each message is only delivered to a single consumer.</span></span> <span data-ttu-id="434be-118">Необходимо также сбалансировать рабочую нагрузку среди потребителей, чтобы экземпляр не вызывал проблемы с производительностью.</span><span class="sxs-lookup"><span data-stu-id="434be-118">The workload also needs to be load balanced across consumers to prevent an instance from becoming a bottleneck.</span></span>

## <a name="solution"></a><span data-ttu-id="434be-119">Решение</span><span class="sxs-lookup"><span data-stu-id="434be-119">Solution</span></span>

<span data-ttu-id="434be-120">С помощью очереди сообщений можно реализовать коммуникационный канал между приложением и экземплярами службы потребителя.</span><span class="sxs-lookup"><span data-stu-id="434be-120">Use a message queue to implement the communication channel between the application and the instances of the consumer service.</span></span> <span data-ttu-id="434be-121">Приложение отправляет запросы в виде сообщения в очередь. Экземпляры службы потребителя получают сообщения из очереди и обрабатывают их.</span><span class="sxs-lookup"><span data-stu-id="434be-121">The application posts requests in the form of messages to the queue, and the consumer service instances receive messages from the queue and process them.</span></span> <span data-ttu-id="434be-122">Такой подход позволяет одному пулу экземпляров службы потребителя обрабатывать сообщения из любого экземпляра приложения.</span><span class="sxs-lookup"><span data-stu-id="434be-122">This approach enables the same pool of consumer service instances to handle messages from any instance of the application.</span></span> <span data-ttu-id="434be-123">На рисунке ниже показано использование очереди сообщений для распределения нагрузки в экземплярах службы.</span><span class="sxs-lookup"><span data-stu-id="434be-123">The figure illustrates using a message queue to distribute work to instances of a service.</span></span>

![Использование очереди сообщений для распределения нагрузки в экземплярах службы](./_images/competing-consumers-diagram.png)

<span data-ttu-id="434be-125">Это решение имеет следующие преимущества:</span><span class="sxs-lookup"><span data-stu-id="434be-125">This solution has the following benefits:</span></span>

- <span data-ttu-id="434be-126">Оно предоставляет систему с выровненной нагрузкой, которая может обрабатывать большое число запросов, отправленных экземплярами приложения.</span><span class="sxs-lookup"><span data-stu-id="434be-126">It provides a load-leveled system that can handle wide variations in the volume of requests sent by application instances.</span></span> <span data-ttu-id="434be-127">Очередь выступает в качестве буфера между экземплярами приложения и экземплярами службы потребителя.</span><span class="sxs-lookup"><span data-stu-id="434be-127">The queue acts as a buffer between the application instances and the consumer service instances.</span></span> <span data-ttu-id="434be-128">Это может помочь минимизировать влияние на доступность и скорость реагирования экземпляров приложения и службы, как описано в статье [Queue-Based Load Leveling pattern](queue-based-load-leveling.md) (Шаблон балансировки нагрузки на основе очередей).</span><span class="sxs-lookup"><span data-stu-id="434be-128">This can help to minimize the impact on availability and responsiveness for both the application and the service instances, as described by the [Queue-based Load Leveling pattern](queue-based-load-leveling.md).</span></span> <span data-ttu-id="434be-129">Длительная обработка сообщений не предотвращает параллельную обработку других сообщений другими экземплярами службы потребителя.</span><span class="sxs-lookup"><span data-stu-id="434be-129">Handling a message that requires some long-running processing doesn't prevent other messages from being handled concurrently by other instances of the consumer service.</span></span>

- <span data-ttu-id="434be-130">Это повышает надежность.</span><span class="sxs-lookup"><span data-stu-id="434be-130">It improves reliability.</span></span> <span data-ttu-id="434be-131">Если производитель взаимодействует с потребителем напрямую, вместо того чтобы использовать этот шаблон, но не отслеживает его, существует высокая вероятность того, что сообщения могут быть утеряны или их не удастся обработать, если произойдет сбой потребителя.</span><span class="sxs-lookup"><span data-stu-id="434be-131">If a producer communicates directly with a consumer instead of using this pattern, but doesn't monitor the consumer, there's a high probability that messages could be lost or fail to be processed if the consumer fails.</span></span> <span data-ttu-id="434be-132">В этом шаблоне сообщения не отправляются в конкретный экземпляр службы.</span><span class="sxs-lookup"><span data-stu-id="434be-132">In this pattern, messages aren't sent to a specific service instance.</span></span> <span data-ttu-id="434be-133">Поврежденный экземпляр службы не будет блокировать производителя, и сообщения можно обрабатывать с помощью любого рабочего экземпляра службы.</span><span class="sxs-lookup"><span data-stu-id="434be-133">A failed service instance won't block a producer, and messages can be processed by any working service instance.</span></span>

- <span data-ttu-id="434be-134">Это не требует комплексной координации между потребителями или между производителем и экземплярами потребителя.</span><span class="sxs-lookup"><span data-stu-id="434be-134">It doesn't require complex coordination between the consumers, or between the producer and the consumer instances.</span></span> <span data-ttu-id="434be-135">Очередь сообщений гарантирует, что каждое сообщение будет доставлено не менее одного раза.</span><span class="sxs-lookup"><span data-stu-id="434be-135">The message queue ensures that each message is delivered at least once.</span></span>

- <span data-ttu-id="434be-136">Оно масштабируемое.</span><span class="sxs-lookup"><span data-stu-id="434be-136">It's scalable.</span></span> <span data-ttu-id="434be-137">Система может динамически увеличивать или уменьшать количество экземпляров службы потребителя, так как объем сообщений может изменяться.</span><span class="sxs-lookup"><span data-stu-id="434be-137">The system can dynamically increase or decrease the number of instances of the consumer service as the volume of messages fluctuates.</span></span>

- <span data-ttu-id="434be-138">Оно может улучшить устойчивость, если очередь сообщения предоставляет транзакционные операции считывания.</span><span class="sxs-lookup"><span data-stu-id="434be-138">It can improve resiliency if the message queue provides transactional read operations.</span></span> <span data-ttu-id="434be-139">Если экземпляр службы потребителя считывает и обрабатывает сообщение как часть транзакционной операции и происходит его сбой, этот шаблон может гарантировать, что сообщение будет возвращено в очередь, чтобы другой экземпляр службы потребителя мог выбрать его для обработки.</span><span class="sxs-lookup"><span data-stu-id="434be-139">If a consumer service instance reads and processes the message as part of a transactional operation, and the consumer service instance fails, this pattern can ensure that the message will be returned to the queue to be picked up and handled by another instance of the consumer service.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="434be-140">Проблемы и рекомендации</span><span class="sxs-lookup"><span data-stu-id="434be-140">Issues and considerations</span></span>

<span data-ttu-id="434be-141">При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.</span><span class="sxs-lookup"><span data-stu-id="434be-141">Consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="434be-142">**Упорядочивание сообщений.**</span><span class="sxs-lookup"><span data-stu-id="434be-142">**Message ordering**.</span></span> <span data-ttu-id="434be-143">Порядок, в котором экземпляры службы потребителя получают сообщения, ненадежный и не обязательно должен совпадать с порядком создания сообщений.</span><span class="sxs-lookup"><span data-stu-id="434be-143">The order in which consumer service instances receive messages isn't guaranteed, and doesn't necessarily reflect the order in which the messages were created.</span></span> <span data-ttu-id="434be-144">Разработайте систему, чтобы гарантировать идемпотентную обработку сообщений. Это поможет исключить любые зависимости в порядке обработки сообщений.</span><span class="sxs-lookup"><span data-stu-id="434be-144">Design the system to ensure that message processing is idempotent because this will help to eliminate any dependency on the order in which messages are handled.</span></span> <span data-ttu-id="434be-145">Дополнительные сведения см. в статье, посвященной [шаблонам идемпотентности](https://blog.jonathanoliver.com/idempotency-patterns/) в блоге Джонатана Оливера (Jonathan Oliver).</span><span class="sxs-lookup"><span data-stu-id="434be-145">For more information, see [Idempotency Patterns](https://blog.jonathanoliver.com/idempotency-patterns/) on Jonathon Oliver’s blog.</span></span>

    > <span data-ttu-id="434be-146">Очереди служебной шины Microsoft Azure могут реализовать гарантированную доставку сообщений по методу FIFO ("первым прибыл, первым обслужен") с помощью сеансов обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="434be-146">Microsoft Azure Service Bus Queues can implement guaranteed first-in-first-out ordering of messages by using message sessions.</span></span> <span data-ttu-id="434be-147">Дополнительные сведения см. в статье [Microsoft Azure Service Bus: шаблоны обмена сообщениями с использованием сеансов](https://msdn.microsoft.com/magazine/jj863132.aspx).</span><span class="sxs-lookup"><span data-stu-id="434be-147">For more information, see [Messaging Patterns Using Sessions](https://msdn.microsoft.com/magazine/jj863132.aspx).</span></span>

- <span data-ttu-id="434be-148">**Разработка служб для обеспечения устойчивости.**</span><span class="sxs-lookup"><span data-stu-id="434be-148">**Designing services for resiliency**.</span></span> <span data-ttu-id="434be-149">Если система разработана, чтобы определять и перезапускать неработоспособные экземпляры служб, может понадобиться реализовать обработку, выполненную экземплярами службы в качестве отдельной операции, чтобы снизить воздействие одного сообщения, которое извлекается и обрабатывается более одного раза.</span><span class="sxs-lookup"><span data-stu-id="434be-149">If the system is designed to detect and restart failed service instances, it might be necessary to implement the processing performed by the service instances as idempotent operations to minimize the effects of a single message being retrieved and processed more than once.</span></span>

- <span data-ttu-id="434be-150">**Определение сообщений о сбое.**</span><span class="sxs-lookup"><span data-stu-id="434be-150">**Detecting poison messages**.</span></span> <span data-ttu-id="434be-151">Неправильно сформированные сообщения или задачи, которым требуется доступ к недоступным ресурсам, могут вызвать сбой экземпляра службы.</span><span class="sxs-lookup"><span data-stu-id="434be-151">A malformed message, or a task that requires access to resources that aren't available, can cause a service instance to fail.</span></span> <span data-ttu-id="434be-152">Система должна предотвратить возвращение таких сообщений в очередь и вместо этого собрать и сохранить сведения об этих сообщениях в другом месте, чтобы при необходимости их можно было анализировать.</span><span class="sxs-lookup"><span data-stu-id="434be-152">The system should prevent such messages being returned to the queue, and instead capture and store the details of these messages elsewhere so that they can be analyzed if necessary.</span></span>

- <span data-ttu-id="434be-153">**Обработка результатов.**</span><span class="sxs-lookup"><span data-stu-id="434be-153">**Handling results**.</span></span> <span data-ttu-id="434be-154">Экземпляр службы, который обрабатывает сообщение, полностью отключен от логики приложения, которая создает сообщение. Они не могут взаимодействовать напрямую.</span><span class="sxs-lookup"><span data-stu-id="434be-154">The service instance handling a message is fully decoupled from the application logic that generates the message, and they might not be able to communicate directly.</span></span> <span data-ttu-id="434be-155">Если экземпляр службы формирует результаты, которые должны быть переданы обратно в логику приложения, эти сведения должны храниться в доступном для них расположении.</span><span class="sxs-lookup"><span data-stu-id="434be-155">If the service instance generates results that must be passed back to the application logic, this information must be stored in a location that's accessible to both.</span></span> <span data-ttu-id="434be-156">Чтобы логика приложения не получала неполные данные, система должна определять, когда обработка завершена.</span><span class="sxs-lookup"><span data-stu-id="434be-156">In order to prevent the application logic from retrieving incomplete data the system must indicate when processing is complete.</span></span>

     > <span data-ttu-id="434be-157">Если вы используете Azure, рабочий процесс может передать результат обратно в логику приложения с помощью выделенной очереди ответов сообщения.</span><span class="sxs-lookup"><span data-stu-id="434be-157">If you're using Azure, a worker process can pass results back to the application logic by using a dedicated message reply queue.</span></span> <span data-ttu-id="434be-158">Логика приложения должна секционировать эти результаты с исходным сообщением.</span><span class="sxs-lookup"><span data-stu-id="434be-158">The application logic must be able to correlate these results with the original message.</span></span> <span data-ttu-id="434be-159">Этот сценарий описан более подробно в [руководстве по асинхронному обмеру сообщениями](https://msdn.microsoft.com/library/dn589781.aspx).</span><span class="sxs-lookup"><span data-stu-id="434be-159">This scenario is described in more detail in the [Asynchronous Messaging Primer](https://msdn.microsoft.com/library/dn589781.aspx).</span></span>

- <span data-ttu-id="434be-160">**Масштабирование системы обмена сообщениями.**</span><span class="sxs-lookup"><span data-stu-id="434be-160">**Scaling the messaging system**.</span></span> <span data-ttu-id="434be-161">В крупномасштабном решении одна очередь сообщений может быть переполненной количеством сообщений и может стать узким местом в системе.</span><span class="sxs-lookup"><span data-stu-id="434be-161">In a large-scale solution, a single message queue could be overwhelmed by the number of messages and become a bottleneck in the system.</span></span> <span data-ttu-id="434be-162">В этом случае попробуйте секционировать систему обмена сообщениями для отправки писем от конкретных поставщиков в определенные очереди. Вы также можете использовать балансировку нагрузки, чтобы распределить сообщения в нескольких очередях сообщений.</span><span class="sxs-lookup"><span data-stu-id="434be-162">In this situation, consider partitioning the messaging system to send messages from specific producers to a particular queue, or use load balancing to distribute messages across multiple message queues.</span></span>

- <span data-ttu-id="434be-163">**Обеспечение надежности системы обмена сообщениями.**</span><span class="sxs-lookup"><span data-stu-id="434be-163">**Ensuring reliability of the messaging system**.</span></span> <span data-ttu-id="434be-164">Надежная система обмена сообщениями необходима, чтобы гарантировать, что сообщения не будут потеряны, когда приложение поставит их в очередь.</span><span class="sxs-lookup"><span data-stu-id="434be-164">A reliable messaging system is needed to guarantee that after the application enqueues a message it won't be lost.</span></span> <span data-ttu-id="434be-165">Это важно, чтобы обеспечить доставку сообщений хотя бы раз.</span><span class="sxs-lookup"><span data-stu-id="434be-165">This is essential for ensuring that all messages are delivered at least once.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="434be-166">Когда следует использовать этот шаблон</span><span class="sxs-lookup"><span data-stu-id="434be-166">When to use this pattern</span></span>

<span data-ttu-id="434be-167">Используйте этот шаблон в следующих случаях:</span><span class="sxs-lookup"><span data-stu-id="434be-167">Use this pattern when:</span></span>

- <span data-ttu-id="434be-168">Рабочая нагрузка для приложения разделена на задачи, которые могут выполняться асинхронно.</span><span class="sxs-lookup"><span data-stu-id="434be-168">The workload for an application is divided into tasks that can run asynchronously.</span></span>
- <span data-ttu-id="434be-169">Задачи являются независимыми и могут выполняться параллельно.</span><span class="sxs-lookup"><span data-stu-id="434be-169">Tasks are independent and can run in parallel.</span></span>
- <span data-ttu-id="434be-170">Объем работ может сильно изменяться, требуя масштабируемого решения.</span><span class="sxs-lookup"><span data-stu-id="434be-170">The volume of work is highly variable, requiring a scalable solution.</span></span>
- <span data-ttu-id="434be-171">Решение должно предоставлять высокий уровень доступности и должно быть устойчивым в случае сбоя обработки задачи.</span><span class="sxs-lookup"><span data-stu-id="434be-171">The solution must provide high availability, and must be resilient if the processing for a task fails.</span></span>

<span data-ttu-id="434be-172">Этот шаблон может оказаться неэффективным в следующих случаях:</span><span class="sxs-lookup"><span data-stu-id="434be-172">This pattern might not be useful when:</span></span>

- <span data-ttu-id="434be-173">Сложно разделить рабочую нагрузку приложения на дискретные задачи, или имеется высокий уровень зависимости между приложениями.</span><span class="sxs-lookup"><span data-stu-id="434be-173">It's not easy to separate the application workload into discrete tasks, or there's a high degree of dependence between tasks.</span></span>
- <span data-ttu-id="434be-174">Задачи необходимо выполнить синхронно, и логике приложения необходимо ждать завершения выполнения задачи, прежде чем продолжить.</span><span class="sxs-lookup"><span data-stu-id="434be-174">Tasks must be performed synchronously, and the application logic must wait for a task to complete before continuing.</span></span>
- <span data-ttu-id="434be-175">Задачи должны выполняться в определенной последовательности.</span><span class="sxs-lookup"><span data-stu-id="434be-175">Tasks must be performed in a specific sequence.</span></span>

> <span data-ttu-id="434be-176">Некоторые системы обмена сообщениями поддерживают сеансы, которые позволяют производителю группировать сообщения вместе и обеспечить их выполнение одним и тем же потребителем.</span><span class="sxs-lookup"><span data-stu-id="434be-176">Some messaging systems support sessions that enable a producer to group messages together and ensure that they're all handled by the same consumer.</span></span> <span data-ttu-id="434be-177">Этот механизм можно использовать с приоритетными сообщениями (если они поддерживаются), чтобы реализовать вариант упорядочивания сообщений, который последовательно доставляет сообщения от производителя к одному потребителю.</span><span class="sxs-lookup"><span data-stu-id="434be-177">This mechanism can be used with prioritized messages (if they are supported) to implement a form of message ordering that delivers messages in sequence from a producer to a single consumer.</span></span>

## <a name="example"></a><span data-ttu-id="434be-178">Пример</span><span class="sxs-lookup"><span data-stu-id="434be-178">Example</span></span>

<span data-ttu-id="434be-179">Azure предоставляет очереди службы хранилища и очереди служебной шины, которые могут выступать в качестве механизма для реализации этого шаблона.</span><span class="sxs-lookup"><span data-stu-id="434be-179">Azure provides storage queues and Service Bus queues that can act as a mechanism for implementing this pattern.</span></span> <span data-ttu-id="434be-180">Логика приложения может публиковать сообщения в очереди, а потребители, реализованные в качестве задач в одной или нескольких ролях, могут извлекать сообщения из этой очереди и обрабатывать их.</span><span class="sxs-lookup"><span data-stu-id="434be-180">The application logic can post messages to a queue, and consumers implemented as tasks in one or more roles can retrieve messages from this queue and process them.</span></span> <span data-ttu-id="434be-181">Для обеспечения устойчивости очередь служебной шины позволяет потребителю использовать режим `PeekLock`, когда он извлекает сообщение из очереди.</span><span class="sxs-lookup"><span data-stu-id="434be-181">For resiliency, a Service Bus queue enables a consumer to use `PeekLock` mode when it retrieves a message from the queue.</span></span> <span data-ttu-id="434be-182">Этот режим фактически не удаляет сообщение, а просто скрывает его от других потребителей.</span><span class="sxs-lookup"><span data-stu-id="434be-182">This mode doesn't actually remove the message, but simply hides it from other consumers.</span></span> <span data-ttu-id="434be-183">Первоначальный потребитель может удалить сообщение по окончании его обработки.</span><span class="sxs-lookup"><span data-stu-id="434be-183">The original consumer can delete the message when it's finished processing it.</span></span> <span data-ttu-id="434be-184">Если происходит сбой потребителя, срок блокировки просмотра истечет и сообщение снова станет видно. Другие потребители смогут его извлекать.</span><span class="sxs-lookup"><span data-stu-id="434be-184">If the consumer fails, the peek lock will time out and the message will become visible again, allowing another consumer to retrieve it.</span></span>

> <span data-ttu-id="434be-185">Дополнительные сведения об использовании очередей служебной шины Azure см. в статье [Очереди, разделы и подписки служебной шины](https://msdn.microsoft.com/library/windowsazure/hh367516.aspx).</span><span class="sxs-lookup"><span data-stu-id="434be-185">For detailed information on using Azure Service Bus queues, see [Service Bus queues, topics, and subscriptions](https://msdn.microsoft.com/library/windowsazure/hh367516.aspx).</span></span>
<span data-ttu-id="434be-186">Дополнительные сведения об использовании очередей хранилища Azure см. в статье [Приступая к работе с хранилищем очередей Azure с помощью .NET](https://azure.microsoft.com/documentation/articles/storage-dotnet-how-to-use-queues/).</span><span class="sxs-lookup"><span data-stu-id="434be-186">For information on using Azure storage queues, see [Get started with Azure Queue storage using .NET](https://azure.microsoft.com/documentation/articles/storage-dotnet-how-to-use-queues/).</span></span>

<span data-ttu-id="434be-187">В следующем примере кода из класса `QueueManager` в решении CompetingConsumers, доступном на сайте [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers), показано, как можно создать очередь с помощью экземпляра `QueueClient` в обработчике событий `Start` в веб-роли или рабочей роли.</span><span class="sxs-lookup"><span data-stu-id="434be-187">The following code from the `QueueManager` class in CompetingConsumers solution available on [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers) shows how you can create a queue by using a `QueueClient` instance in the `Start` event handler in a web or worker role.</span></span>

```csharp
private string queueName = ...;
private string connectionString = ...;
...

public async Task Start()
{
  // Check if the queue already exists.
  var manager = NamespaceManager.CreateFromConnectionString(this.connectionString);
  if (!manager.QueueExists(this.queueName))
  {
    var queueDescription = new QueueDescription(this.queueName);

    // Set the maximum delivery count for messages in the queue. A message
    // is automatically dead-lettered after this number of deliveries. The
    // default value for dead letter count is 10.
    queueDescription.MaxDeliveryCount = 3;

    await manager.CreateQueueAsync(queueDescription);
  }
  ...

  // Create the queue client. By default the PeekLock method is used.
  this.client = QueueClient.CreateFromConnectionString(
    this.connectionString, this.queueName);
}
```

<span data-ttu-id="434be-188">В следующем фрагменте кода показано, как приложение может создать пакет сообщений и отправить его в очередь.</span><span class="sxs-lookup"><span data-stu-id="434be-188">The next code snippet shows how an application can create and send a batch of messages to the queue.</span></span>

```csharp
public async Task SendMessagesAsync()
{
  // Simulate sending a batch of messages to the queue.
  var messages = new List<BrokeredMessage>();

  for (int i = 0; i < 10; i++)
  {
    var message = new BrokeredMessage() { MessageId = Guid.NewGuid().ToString() };
    messages.Add(message);
  }
  await this.client.SendBatchAsync(messages);
}
```

<span data-ttu-id="434be-189">В указанном ниже коде показано, как экземпляр службы потребителя может получать сообщения из очереди, используя подход на основе событий.</span><span class="sxs-lookup"><span data-stu-id="434be-189">The following code shows how a consumer service instance can receive messages from the queue by following an event-driven approach.</span></span> <span data-ttu-id="434be-190">Параметр `processMessageTask` метода `ReceiveMessages` является делегатом, который ссылается на код для выполнения во время получения сообщения.</span><span class="sxs-lookup"><span data-stu-id="434be-190">The `processMessageTask` parameter to the `ReceiveMessages` method is a delegate that references the code to run when a message is received.</span></span> <span data-ttu-id="434be-191">Этот код выполняется асинхронно.</span><span class="sxs-lookup"><span data-stu-id="434be-191">This code is run asynchronously.</span></span>

```csharp
private ManualResetEvent pauseProcessingEvent;
...

public void ReceiveMessages(Func<BrokeredMessage, Task> processMessageTask)
{
  // Set up the options for the message pump.
  var options = new OnMessageOptions();

  // When AutoComplete is disabled it's necessary to manually
  // complete or abandon the messages and handle any errors.
  options.AutoComplete = false;
  options.MaxConcurrentCalls = 10;
  options.ExceptionReceived += this.OptionsOnExceptionReceived;

  // Use of the Service Bus OnMessage message pump.
  // The OnMessage method must be called once, otherwise an exception will occur.
  this.client.OnMessageAsync(
    async (msg) =>
    {
      // Will block the current thread if Stop is called.
      this.pauseProcessingEvent.WaitOne();

      // Execute processing task here.
      await processMessageTask(msg);
    },
    options);
}
...

private void OptionsOnExceptionReceived(object sender,
  ExceptionReceivedEventArgs exceptionReceivedEventArgs)
{
  ...
}
```

<span data-ttu-id="434be-192">Обратите внимание, что функции автомасштабирования, например те, которые доступны в Azure, можно использовать для выполнения и остановки экземпляров роли при изменении длины очереди.</span><span class="sxs-lookup"><span data-stu-id="434be-192">Note that autoscaling features, such as those available in Azure, can be used to start and stop role instances as the queue length fluctuates.</span></span> <span data-ttu-id="434be-193">Дополнительные сведения см. в [руководстве по автомасштабированию](https://msdn.microsoft.com/library/dn589774.aspx).</span><span class="sxs-lookup"><span data-stu-id="434be-193">For more information, see [Autoscaling Guidance](https://msdn.microsoft.com/library/dn589774.aspx).</span></span> <span data-ttu-id="434be-194">Кроме того, нет необходимости обеспечивать прямое соответствие между экземплярами роли и рабочими процессами. Один экземпляр роли может реализовать несколько рабочих процессов.</span><span class="sxs-lookup"><span data-stu-id="434be-194">Also, it's not necessary to maintain a one-to-one correspondence between role instances and worker processes&mdash;a single role instance can implement multiple worker processes.</span></span> <span data-ttu-id="434be-195">Дополнительные сведения см. в статье [Compute Resource Consolidation pattern](compute-resource-consolidation.md) (Шаблон консолидации вычислительных ресурсов).</span><span class="sxs-lookup"><span data-stu-id="434be-195">For more information, see [Compute Resource Consolidation pattern](compute-resource-consolidation.md).</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="434be-196">Связанные шаблоны и рекомендации</span><span class="sxs-lookup"><span data-stu-id="434be-196">Related patterns and guidance</span></span>

<span data-ttu-id="434be-197">При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.</span><span class="sxs-lookup"><span data-stu-id="434be-197">The following patterns and guidance might be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="434be-198">[Руководство по асинхронному обмену сообщениями](https://msdn.microsoft.com/library/dn589781.aspx).</span><span class="sxs-lookup"><span data-stu-id="434be-198">[Asynchronous Messaging Primer](https://msdn.microsoft.com/library/dn589781.aspx).</span></span> <span data-ttu-id="434be-199">Очереди сообщений — это механизмы для асинхронного обмена данными.</span><span class="sxs-lookup"><span data-stu-id="434be-199">Message queues are an asynchronous communications mechanism.</span></span> <span data-ttu-id="434be-200">Если службе потребителя необходимо отправить ответ в приложение, может потребоваться реализовать некоторые варианты обмена сообщениями через ответы.</span><span class="sxs-lookup"><span data-stu-id="434be-200">If a consumer service needs to send a reply to an application, it might be necessary to implement some form of response messaging.</span></span> <span data-ttu-id="434be-201">Руководство по асинхронному обмену сообщениями предоставляет сведения о реализации обмена сообщениями через запрос или ответ с помощью очередей сообщения.</span><span class="sxs-lookup"><span data-stu-id="434be-201">The Asynchronous Messaging Primer provides information on how to implement request/reply messaging using message queues.</span></span>

- <span data-ttu-id="434be-202">[Руководство по автоматическому масштабированию](https://msdn.microsoft.com/library/dn589774.aspx).</span><span class="sxs-lookup"><span data-stu-id="434be-202">[Autoscaling Guidance](https://msdn.microsoft.com/library/dn589774.aspx).</span></span> <span data-ttu-id="434be-203">Вы можете выполнить и остановить экземпляры службы потребителя, так как длина очереди, в которой приложение публикует сообщения, отличается.</span><span class="sxs-lookup"><span data-stu-id="434be-203">It might be possible to start and stop instances of a consumer service since the length of the queue applications post messages on varies.</span></span> <span data-ttu-id="434be-204">Автомасштабирование может помочь поддерживать пропускную способность во время максимальной нагрузки.</span><span class="sxs-lookup"><span data-stu-id="434be-204">Autoscaling can help to maintain throughput during times of peak processing.</span></span>

- <span data-ttu-id="434be-205">[Compute Resource Consolidation pattern](compute-resource-consolidation.md) (Шаблон консолидации вычислительных ресурсов).</span><span class="sxs-lookup"><span data-stu-id="434be-205">[Compute Resource Consolidation Pattern](compute-resource-consolidation.md).</span></span> <span data-ttu-id="434be-206">Вы можете выполнить консолидацию нескольких экземпляров службы потребителя в один процесс, чтобы сократить расходы и затраты на управление.</span><span class="sxs-lookup"><span data-stu-id="434be-206">It might be possible to consolidate multiple instances of a consumer service into a single process to reduce costs and management overhead.</span></span> <span data-ttu-id="434be-207">В статье Compute Resource Consolidation pattern (Шаблон консолидации вычислительных ресурсов) описаны преимущества и недостатки использования этого подхода.</span><span class="sxs-lookup"><span data-stu-id="434be-207">The Compute Resource Consolidation pattern describes the benefits and tradeoffs of following this approach.</span></span>

- <span data-ttu-id="434be-208">[Queue-based Load Leveling Pattern](queue-based-load-leveling.md) (Шаблон балансировки нагрузки на основе очередей).</span><span class="sxs-lookup"><span data-stu-id="434be-208">[Queue-based Load Leveling Pattern](queue-based-load-leveling.md).</span></span> <span data-ttu-id="434be-209">Добавление очереди сообщений может повысить устойчивость системы, позволить экземплярам службы обрабатывать разные объемы запросов из экземпляров приложения.</span><span class="sxs-lookup"><span data-stu-id="434be-209">Introducing a message queue can add resiliency to the system, enabling service instances to handle widely varying volumes of requests from application instances.</span></span> <span data-ttu-id="434be-210">Очередь сообщений работает как буфер, которой уравнивает нагрузку.</span><span class="sxs-lookup"><span data-stu-id="434be-210">The message queue acts as a buffer, which levels the load.</span></span> <span data-ttu-id="434be-211">Статья Queue-based Load Leveling pattern (Шаблон балансировки нагрузки на основе очередей) описывает этот сценарий более подробно.</span><span class="sxs-lookup"><span data-stu-id="434be-211">The Queue-based Load Leveling pattern describes this scenario in more detail.</span></span>

- <span data-ttu-id="434be-212">Этот шаблон имеет связанный с ним [образец приложения](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers).</span><span class="sxs-lookup"><span data-stu-id="434be-212">This pattern has a [sample application](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers) associated with it.</span></span>

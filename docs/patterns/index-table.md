---
title: Шаблон таблицы индексов
titleSuffix: Cloud Design Patterns
description: Создание в хранилище данных индексов по полям, которые часто используются в запросах.
keywords: Конструктивный шаблон
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: e3373a50ba6298f7985182b7be244db5f6eaa703
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/23/2019
ms.locfileid: "54487191"
---
# <a name="index-table-pattern"></a><span data-ttu-id="d546a-104">Шаблон таблицы индексов</span><span class="sxs-lookup"><span data-stu-id="d546a-104">Index Table pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="d546a-105">Создание в хранилище данных индексов по полям, которые часто используются в запросах.</span><span class="sxs-lookup"><span data-stu-id="d546a-105">Create indexes over the fields in data stores that are frequently referenced by queries.</span></span> <span data-ttu-id="d546a-106">Этот шаблон может повысить производительность запросов, ускоряя поиск данных, которые нужно извлечь из хранилища.</span><span class="sxs-lookup"><span data-stu-id="d546a-106">This pattern can improve query performance by allowing applications to more quickly locate the data to retrieve from a data store.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="d546a-107">Контекст и проблема</span><span class="sxs-lookup"><span data-stu-id="d546a-107">Context and problem</span></span>

<span data-ttu-id="d546a-108">В многих хранилищах данные для коллекций сущностей организованы при помощи первичного ключа.</span><span class="sxs-lookup"><span data-stu-id="d546a-108">Many data stores organize the data for a collection of entities using the primary key.</span></span> <span data-ttu-id="d546a-109">Этот ключ может использоваться в приложении для поиска и извлечения данных.</span><span class="sxs-lookup"><span data-stu-id="d546a-109">An application can use this key to locate and retrieve data.</span></span> <span data-ttu-id="d546a-110">На рисунке представлен пример хранилища данных со сведениями о клиентах.</span><span class="sxs-lookup"><span data-stu-id="d546a-110">The figure shows an example of a data store holding customer information.</span></span> <span data-ttu-id="d546a-111">Первичный ключ — это идентификатор клиента.</span><span class="sxs-lookup"><span data-stu-id="d546a-111">The primary key is the Customer ID.</span></span> <span data-ttu-id="d546a-112">На рисунке представлены сведения о клиенте, упорядоченные по первичному ключу (идентификатору клиента).</span><span class="sxs-lookup"><span data-stu-id="d546a-112">The figure shows customer information organized by the primary key (Customer ID).</span></span>

![Рис. 1. Сведения о клиенте, упорядоченные по первичному ключу (идентификатору клиента)](./_images/index-table-figure-1.png)

<span data-ttu-id="d546a-114">Первичный ключ отлично подходит для запросов данных на основе его значения. Но если нужно получить данные на основе другого поля, первичный ключ не всегда можно использовать.</span><span class="sxs-lookup"><span data-stu-id="d546a-114">While the primary key is valuable for queries that fetch data based on the value of this key, an application might not be able to use the primary key if it needs to retrieve data based on some other field.</span></span> <span data-ttu-id="d546a-115">В приведенном выше примере для поиска клиентов в приложении нельзя использовать первичный ключ (идентификатор клиента), если данные запрашиваются исключительно по ссылке на значение какого-нибудь другого атрибута, например на название города, в котором находится клиент.</span><span class="sxs-lookup"><span data-stu-id="d546a-115">In the customers example, an application can't use the Customer ID primary key to retrieve customers if it queries data solely by referencing the value of some other attribute, such as the town in which the customer is located.</span></span> <span data-ttu-id="d546a-116">Для выполнения такого запроса приложению может потребоваться получить и изучить каждую запись клиента, что может занять довольно много времени.</span><span class="sxs-lookup"><span data-stu-id="d546a-116">To perform a query such as this, the application might have to fetch and examine every customer record, which could be a slow process.</span></span>

<span data-ttu-id="d546a-117">Многие системы управления реляционными базами данных поддерживают вторичные индексы.</span><span class="sxs-lookup"><span data-stu-id="d546a-117">Many relational database management systems support secondary indexes.</span></span> <span data-ttu-id="d546a-118">Вторичный индекс — это отдельная структура данных, упорядоченных по одному или нескольким вторичным (дополнительным) ключевым полям. Такой индекс указывает, где хранятся данные для каждого индексированного значения.</span><span class="sxs-lookup"><span data-stu-id="d546a-118">A secondary index is a separate data structure that's organized by one or more nonprimary (secondary) key fields, and it indicates where the data for each indexed value is stored.</span></span> <span data-ttu-id="d546a-119">Элементы вторичного индекса обычно сортируются по значению вторичных ключей, чтобы повысить скорость поиска данных.</span><span class="sxs-lookup"><span data-stu-id="d546a-119">The items in a secondary index are typically sorted by the value of the secondary keys to enable fast lookup of data.</span></span> <span data-ttu-id="d546a-120">Такие индексы, как правило, автоматически обслуживаются системой управления базами данных.</span><span class="sxs-lookup"><span data-stu-id="d546a-120">These indexes are usually maintained automatically by the database management system.</span></span>

<span data-ttu-id="d546a-121">Вы можете создать любое количество вторичных индексов для поддержки различных запросов, выполняемых в приложении.</span><span class="sxs-lookup"><span data-stu-id="d546a-121">You can create as many secondary indexes as you need to support the different queries that your application performs.</span></span> <span data-ttu-id="d546a-122">Например, в таблице со сведениями о клиентах в реляционной базе данных, где идентификатор клиента является первичным ключом, стоит добавить вторичный индекс над полем города, если в приложении часто выполняется поиск клиентов по городу, в котором они находятся.</span><span class="sxs-lookup"><span data-stu-id="d546a-122">For example, in a Customers table in a relational database where the Customer ID is the primary key, it's beneficial to add a secondary index over the town field if the application frequently looks up customers by the town where they reside.</span></span>

<span data-ttu-id="d546a-123">Вторичные индексы часто используются в реляционных системах, но большинство хранилищ данных NoSQL, которые используются в облачных приложениях, не предоставляют эквивалентную функцию.</span><span class="sxs-lookup"><span data-stu-id="d546a-123">However, although secondary indexes are common in relational systems, most NoSQL data stores used by cloud applications don't provide an equivalent feature.</span></span>

## <a name="solution"></a><span data-ttu-id="d546a-124">Решение</span><span class="sxs-lookup"><span data-stu-id="d546a-124">Solution</span></span>

<span data-ttu-id="d546a-125">Если хранилище данных не поддерживает вторичные индексы, их можно эмулировать вручную, создав собственные таблицы индексов.</span><span class="sxs-lookup"><span data-stu-id="d546a-125">If the data store doesn't support secondary indexes, you can emulate them manually by creating your own index tables.</span></span> <span data-ttu-id="d546a-126">В таблице индексов данные упорядочиваются по указанному ключу.</span><span class="sxs-lookup"><span data-stu-id="d546a-126">An index table organizes the data by a specified key.</span></span> <span data-ttu-id="d546a-127">Для структурирования таблицы индексов обычно используются три стратегии. Стратегию выбирают на основе требуемого числа вторичных индексов и характера запросов в приложении.</span><span class="sxs-lookup"><span data-stu-id="d546a-127">Three strategies are commonly used for structuring an index table, depending on the number of secondary indexes that are required and the nature of the queries that an application performs.</span></span>

<span data-ttu-id="d546a-128">Первая стратегия — данные дублируются в каждой таблице индексов, но упорядочиваются по разным ключам (полная денормализация).</span><span class="sxs-lookup"><span data-stu-id="d546a-128">The first strategy is to duplicate the data in each index table but organize it by different keys (complete denormalization).</span></span> <span data-ttu-id="d546a-129">На следующем рисунке представлены таблицы индексов, в которых одни и те же данные клиента упорядочены по городу и фамилии:</span><span class="sxs-lookup"><span data-stu-id="d546a-129">The next figure shows index tables that organize the same customer information by Town and LastName.</span></span>

![Рис. 2. Данные, которые дублируются в каждой таблице индексов](./_images/index-table-figure-2.png)

<span data-ttu-id="d546a-131">Эта стратегия подходит, если данные остаются относительно статическими при любом количестве запросов с помощью каждого ключа.</span><span class="sxs-lookup"><span data-stu-id="d546a-131">This strategy is appropriate if the data is relatively static compared to the number of times it's queried using each key.</span></span> <span data-ttu-id="d546a-132">Если данные более динамические, затраты на обслуживание каждой таблицы индексов слишком значительны и такой подход нецелесообразен.</span><span class="sxs-lookup"><span data-stu-id="d546a-132">If the data is more dynamic, the processing overhead of maintaining each index table becomes too large for this approach to be useful.</span></span> <span data-ttu-id="d546a-133">Кроме того, если объем данных очень велик, требуется значительное пространство для хранения дублируемых данных.</span><span class="sxs-lookup"><span data-stu-id="d546a-133">Also, if the volume of data is very large, the amount of space required to store the duplicate data is significant.</span></span>

<span data-ttu-id="d546a-134">Вторая стратегия — создаются нормализованные таблицы индексов, которые упорядочены по разным ключам, и добавляются ссылки на исходные данные с помощью первичного ключа (вместо их дублирования), как показано на приведенном ниже рисунке.</span><span class="sxs-lookup"><span data-stu-id="d546a-134">The second strategy is to create normalized index tables organized by different keys and reference the original data by using the primary key rather than duplicating it, as shown in the following figure.</span></span> <span data-ttu-id="d546a-135">Исходные данные называются таблицей фактов.</span><span class="sxs-lookup"><span data-stu-id="d546a-135">The original data is called a fact table.</span></span>

![Рис. 3. Данные, ссылка на которые добавляется для каждой таблицы индексов](./_images/index-table-figure-3.png)

<span data-ttu-id="d546a-137">Этот способ позволяет сэкономить место и сократить затраты на обслуживание дублируемых данных.</span><span class="sxs-lookup"><span data-stu-id="d546a-137">This technique saves space and reduces the overhead of maintaining duplicate data.</span></span> <span data-ttu-id="d546a-138">Недостатком такого подхода является то, что приложению требуется выполнять две операции поиска данных с использованием вторичного ключа.</span><span class="sxs-lookup"><span data-stu-id="d546a-138">The disadvantage is that an application has to perform two lookup operations to find data using a secondary key.</span></span> <span data-ttu-id="d546a-139">Сначала нужно найти первичный ключ для данных в таблице индексов, а затем использовать его для поиска данных в таблице фактов.</span><span class="sxs-lookup"><span data-stu-id="d546a-139">It has to find the primary key for the data in the index table, and then use the primary key to look up the data in the fact table.</span></span>

<span data-ttu-id="d546a-140">Третья стратегия — создаются частично нормализованные таблицы индексов, упорядоченные при помощи различных ключей. В таких таблицах дублируются часто извлекаемые поля.</span><span class="sxs-lookup"><span data-stu-id="d546a-140">The third strategy is to create partially normalized index tables organized by different keys that duplicate frequently retrieved fields.</span></span> <span data-ttu-id="d546a-141">Для доступа к редко используемым полям добавляются ссылки на таблицу фактов.</span><span class="sxs-lookup"><span data-stu-id="d546a-141">Reference the fact table to access less frequently accessed fields.</span></span> <span data-ttu-id="d546a-142">На следующем рисунке показано, как часто используемые данные дублируются в каждой таблице индексов:</span><span class="sxs-lookup"><span data-stu-id="d546a-142">The next figure shows how commonly accessed data is duplicated in each index table.</span></span>

![Рис. 4. Часто используемые данные, которые дублируются в каждой таблице индексов](./_images/index-table-figure-4.png)

<span data-ttu-id="d546a-144">Эта стратегия обеспечивает баланс между двумя первыми подходами.</span><span class="sxs-lookup"><span data-stu-id="d546a-144">With this strategy, you can strike a balance between the first two approaches.</span></span> <span data-ttu-id="d546a-145">Данные для часто выполняемых запросов можно быстро получить при помощи одной операции поиска, а занимаемое пространство и затраты на обслуживание не так значительны, как при дублировании всего набора данных.</span><span class="sxs-lookup"><span data-stu-id="d546a-145">The data for common queries can be retrieved quickly by using a single lookup, while the space and maintenance overhead isn't as significant as duplicating the entire data set.</span></span>

<span data-ttu-id="d546a-146">Если в приложении часто выполняются запросы данных с несколькими значениями (например, "Найти всех клиентов из Тамбова с фамилией Лоханкин"), можно реализовать ключи для элементов в таблице индексов с объединением атрибутов города и фамилии.</span><span class="sxs-lookup"><span data-stu-id="d546a-146">If an application frequently queries data by specifying a combination of values (for example, “Find all customers that live in Redmond and that have a last name of Smith”), you could implement the keys to the items in the index table as a concatenation of the Town attribute and the LastName attribute.</span></span> <span data-ttu-id="d546a-147">На приведенном ниже рисунке представлена таблица индексов на основе составных ключей.</span><span class="sxs-lookup"><span data-stu-id="d546a-147">The next figure shows an index table based on composite keys.</span></span> <span data-ttu-id="d546a-148">Ключи сортируются по городу, а затем — по фамилиям для записей с одинаковыми значениями города.</span><span class="sxs-lookup"><span data-stu-id="d546a-148">The keys are sorted by Town, and then by LastName for records that have the same value for Town.</span></span>

![Рис. 5. Таблица индексов на основе составных ключей](./_images/index-table-figure-5.png)

<span data-ttu-id="d546a-150">Таблицы индексов могут ускорить операции запросов для сегментированных данных и особенно полезны, когда ключ сегмента хэшируется.</span><span class="sxs-lookup"><span data-stu-id="d546a-150">Index tables can speed up query operations over sharded data, and are especially useful where the shard key is hashed.</span></span> <span data-ttu-id="d546a-151">На приведенном ниже рисунке показан пример, где ключ сегмента является хэшем идентификатора клиента.</span><span class="sxs-lookup"><span data-stu-id="d546a-151">The next figure shows an example where the shard key is a hash of the Customer ID.</span></span> <span data-ttu-id="d546a-152">В таблице индексов можно упорядочить данные по нехэшированному значению (город и фамилия) и указать хэшированный ключ как данные поиска.</span><span class="sxs-lookup"><span data-stu-id="d546a-152">The index table can organize data by the nonhashed value (Town and LastName), and provide the hashed shard key as the lookup data.</span></span> <span data-ttu-id="d546a-153">Это поможет предотвратить многократное вычисление хэш-ключей (ресурсоемкую операцию) в приложении, если требуется получить данные в пределах диапазона или в порядке нехэшированных ключей.</span><span class="sxs-lookup"><span data-stu-id="d546a-153">This can save the application from repeatedly calculating hash keys (an expensive operation) if it needs to retrieve data that falls within a range, or it needs to fetch data in order of the nonhashed key.</span></span> <span data-ttu-id="d546a-154">Например, запрос "Найти всех клиентов, которые живут в Тамбове" можно быстро выполнить, разместив соответствующие элементы в таблице индексов, где все они хранятся в связанном блоке.</span><span class="sxs-lookup"><span data-stu-id="d546a-154">For example, a query such as “Find all customers that live in Redmond” can be quickly resolved by locating the matching items in the index table, where they're all stored in a contiguous block.</span></span> <span data-ttu-id="d546a-155">Затем используйте ссылки на данные клиента с помощью ключей сегментов, которые хранятся в таблице индексов.</span><span class="sxs-lookup"><span data-stu-id="d546a-155">Then, follow the references to the customer data using the shard keys stored in the index table.</span></span>

![Рис. 6. Таблица индексов для быстрого поиска для сегментированных данных](./_images/index-table-figure-6.png)

## <a name="issues-and-considerations"></a><span data-ttu-id="d546a-157">Проблемы и рекомендации</span><span class="sxs-lookup"><span data-stu-id="d546a-157">Issues and considerations</span></span>

<span data-ttu-id="d546a-158">При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.</span><span class="sxs-lookup"><span data-stu-id="d546a-158">Consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="d546a-159">Затраты на обслуживание вторичных индексов могут оказаться достаточно велики.</span><span class="sxs-lookup"><span data-stu-id="d546a-159">The overhead of maintaining secondary indexes can be significant.</span></span> <span data-ttu-id="d546a-160">Необходимо иметь представление о запросах, которые используются в вашем приложении, и анализировать их.</span><span class="sxs-lookup"><span data-stu-id="d546a-160">You must analyze and understand the queries that your application uses.</span></span> <span data-ttu-id="d546a-161">Создавайте таблицы индексов, только если планируете использовать их регулярно.</span><span class="sxs-lookup"><span data-stu-id="d546a-161">Only create index tables when they're likely to be used regularly.</span></span> <span data-ttu-id="d546a-162">Не создавайте теоретические таблицы индексов для поддержки запросов, которые не выполняются в приложении или выполняются лишь время от времени.</span><span class="sxs-lookup"><span data-stu-id="d546a-162">Don't create speculative index tables to support queries that an application doesn't perform, or performs only occasionally.</span></span>
- <span data-ttu-id="d546a-163">Дублирование данных в таблице индексов может повлечь значительные дополнительные расходы на хранение и трудозатраты, так как при этом требуется обслуживание нескольких копий данных.</span><span class="sxs-lookup"><span data-stu-id="d546a-163">Duplicating data in an index table can add significant overhead in storage costs and the effort required to maintain multiple copies of data.</span></span>
- <span data-ttu-id="d546a-164">Для реализации таблицы индексов в виде нормализованной структуры, в которой добавляется ссылка на исходные данные, приложению требуется выполнить две операции поиска данных.</span><span class="sxs-lookup"><span data-stu-id="d546a-164">Implementing an index table as a normalized structure that references the original data requires an application to perform two lookup operations to find data.</span></span> <span data-ttu-id="d546a-165">Сначала выполняется поиск первичного ключа в таблице индексов, а затем этот ключ используется для получения данных.</span><span class="sxs-lookup"><span data-stu-id="d546a-165">The first operation searches the index table to retrieve the primary key, and the second uses the primary key to fetch the data.</span></span>
- <span data-ttu-id="d546a-166">Если система содержит несколько таблиц индексов для очень больших наборов данных, иногда трудно поддерживать согласованность между таблицами индексов и исходными данными.</span><span class="sxs-lookup"><span data-stu-id="d546a-166">If a system incorporates a number of index tables over very large data sets, it can be difficult to maintain consistency between index tables and the original data.</span></span> <span data-ttu-id="d546a-167">Можно разработать приложение на основе модели конечной согласованности.</span><span class="sxs-lookup"><span data-stu-id="d546a-167">It might be possible to design the application around the eventual consistency model.</span></span> <span data-ttu-id="d546a-168">Например, для вставки, обновления или удаления данных приложение может отправить сообщение в очередь и создать отдельную задачу для выполнения операции и обслуживания таблиц индексов, которые асинхронно ссылаются на эти данные.</span><span class="sxs-lookup"><span data-stu-id="d546a-168">For example, to insert, update, or delete data, an application could post a message to a queue and let a separate task perform the operation and maintain the index tables that reference this data asynchronously.</span></span> <span data-ttu-id="d546a-169">Сведения о реализации согласованности в конечном счете см. в [руководстве по обеспечению согласованности данных](https://msdn.microsoft.com/library/dn589800.aspx).</span><span class="sxs-lookup"><span data-stu-id="d546a-169">For more information about implementing eventual consistency, see the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span>

   >  <span data-ttu-id="d546a-170">Таблицы в хранилище Microsoft Azure поддерживают обновления транзакций для изменения данных в одной секции (также называются транзакциями группы сущностей).</span><span class="sxs-lookup"><span data-stu-id="d546a-170">Microsoft Azure storage tables support transactional updates for changes made to data held in the same partition (referred to as entity group transactions).</span></span> <span data-ttu-id="d546a-171">При хранении данных для таблицы фактов и одной или нескольких таблиц индексов в одной секции вы можете использовать эту функцию, чтобы обеспечить согласованность.</span><span class="sxs-lookup"><span data-stu-id="d546a-171">If you can store the data for a fact table and one or more index tables in the same partition, you can use this feature to help ensure consistency.</span></span>

- <span data-ttu-id="d546a-172">Собственно таблицы индексов также можно секционировать или сегментировать.</span><span class="sxs-lookup"><span data-stu-id="d546a-172">Index tables might themselves be partitioned or sharded.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="d546a-173">Когда следует использовать этот шаблон</span><span class="sxs-lookup"><span data-stu-id="d546a-173">When to use this pattern</span></span>

<span data-ttu-id="d546a-174">Этот шаблон используется для повышения производительности запросов, когда приложению часто требуется извлекать данные с помощью ключа, отличного от первичного (или ключа сегментов).</span><span class="sxs-lookup"><span data-stu-id="d546a-174">Use this pattern to improve query performance when an application frequently needs to retrieve data by using a key other than the primary (or shard) key.</span></span>

<span data-ttu-id="d546a-175">Этот шаблон может оказаться неэффективным в следующих случаях:</span><span class="sxs-lookup"><span data-stu-id="d546a-175">This pattern might not be useful when:</span></span>

- <span data-ttu-id="d546a-176">Данные нестабильны.</span><span class="sxs-lookup"><span data-stu-id="d546a-176">Data is volatile.</span></span> <span data-ttu-id="d546a-177">Таблица индексов может очень быстро стать неактуальной. В таком случае не стоит использовать ее, так как затраты на обслуживание таблицы могут превысить экономию от ее применения.</span><span class="sxs-lookup"><span data-stu-id="d546a-177">An index table can become out of date very quickly, making it ineffective or making the overhead of maintaining the index table greater than any savings made by using it.</span></span>
- <span data-ttu-id="d546a-178">Поле, выбранное в качестве вторичного ключа для таблицы индексов, недифференцировано и может иметь только небольшой набор значений (например, пол).</span><span class="sxs-lookup"><span data-stu-id="d546a-178">A field selected as the secondary key for an index table is nondiscriminating and can only have a small set of values (for example, gender).</span></span>
- <span data-ttu-id="d546a-179">Значения данных поля, выбранного в качестве вторичного ключа для таблицы индексов, очень разрознены.</span><span class="sxs-lookup"><span data-stu-id="d546a-179">The balance of the data values for a field selected as the secondary key for an index table are highly skewed.</span></span> <span data-ttu-id="d546a-180">Например, если для 90 % записей в поле содержатся одинаковые значения, создание и обслуживание таблицы индексов для поиска данных на основе этого поля может повлечь большие затраты, чем последовательный просмотр данных.</span><span class="sxs-lookup"><span data-stu-id="d546a-180">For example, if 90% of the records contain the same value in a field, then creating and maintaining an index table to look up data based on this field might create more overhead than scanning sequentially through the data.</span></span> <span data-ttu-id="d546a-181">Но если запросы часто обращаются к значениями, которые содержатся в оставшихся 10 % записей, этот индекс можно использовать.</span><span class="sxs-lookup"><span data-stu-id="d546a-181">However, if queries very frequently target values that lie in the remaining 10%, this index can be useful.</span></span> <span data-ttu-id="d546a-182">Следует иметь представление о запросах, которые выполняет приложение, и об их частоте.</span><span class="sxs-lookup"><span data-stu-id="d546a-182">You should understand the queries that your application is performing, and how frequently they're performed.</span></span>

## <a name="example"></a><span data-ttu-id="d546a-183">Пример</span><span class="sxs-lookup"><span data-stu-id="d546a-183">Example</span></span>

<span data-ttu-id="d546a-184">Таблицы хранилища Azure обеспечивают высокомасштабируемое хранилище ключей и значений для приложений в облаке.</span><span class="sxs-lookup"><span data-stu-id="d546a-184">Azure storage tables provide a highly scalable key/value data store for applications running in the cloud.</span></span> <span data-ttu-id="d546a-185">В приложениях можно хранить и извлекать значения, указав ключ.</span><span class="sxs-lookup"><span data-stu-id="d546a-185">Applications store and retrieve data values by specifying a key.</span></span> <span data-ttu-id="d546a-186">Значения данных могут содержать несколько полей, но структура элемента данных непрозрачна для хранилища таблиц, в котором элемент данных просто обрабатывается как массив байтов.</span><span class="sxs-lookup"><span data-stu-id="d546a-186">The data values can contain multiple fields, but the structure of a data item is opaque to table storage, which simply handles a data item as an array of bytes.</span></span>

<span data-ttu-id="d546a-187">Таблицы хранилища Azure также поддерживают сегментирование.</span><span class="sxs-lookup"><span data-stu-id="d546a-187">Azure storage tables also support sharding.</span></span> <span data-ttu-id="d546a-188">Ключ сегментирования включает два элемента: ключ секции и ключ строки.</span><span class="sxs-lookup"><span data-stu-id="d546a-188">The sharding key includes two elements, a partition key and a row key.</span></span> <span data-ttu-id="d546a-189">Элементы с одним ключом секции хранятся в одной секции (сегменте) в порядке ключей строк.</span><span class="sxs-lookup"><span data-stu-id="d546a-189">Items that have the same partition key are stored in the same partition (shard), and the items are stored in row key order within a shard.</span></span> <span data-ttu-id="d546a-190">Хранилище таблиц оптимизировано для выполнения запросов данных в непрерывном диапазоне значений для ключа строки в секции.</span><span class="sxs-lookup"><span data-stu-id="d546a-190">Table storage is optimized for performing queries that fetch data falling within a contiguous range of row key values within a partition.</span></span> <span data-ttu-id="d546a-191">Если вы создаете облачные приложения, в которых данные хранятся в таблицах Azure, структурируйте данные с учетом этой функции.</span><span class="sxs-lookup"><span data-stu-id="d546a-191">If you're building cloud applications that store information in Azure tables, you should structure your data with this feature in mind.</span></span>

<span data-ttu-id="d546a-192">Например, рассмотрим приложение со сведениями о фильмах.</span><span class="sxs-lookup"><span data-stu-id="d546a-192">For example, consider an application that stores information about movies.</span></span> <span data-ttu-id="d546a-193">В приложении часто выполняются запросы на фильмы по жанру (остросюжетный фильм, документальный фильм, исторический фильм, комедия, драма и т. д).</span><span class="sxs-lookup"><span data-stu-id="d546a-193">The application frequently queries movies by genre (action, documentary, historical, comedy, drama, and so on).</span></span> <span data-ttu-id="d546a-194">Можно создать таблицу Azure с секцией для каждого жанра, используя жанр в качестве ключа секции и указывая название фильма в качестве ключа строки, как показано на рисунке ниже:</span><span class="sxs-lookup"><span data-stu-id="d546a-194">You could create an Azure table with partitions for each genre by using the genre as the partition key, and specifying the movie name as the row key, as shown in the next figure.</span></span>

![Рис. 7. Данные фильмов в таблице Azure](./_images/index-table-figure-7.png)

<span data-ttu-id="d546a-196">Этот подход менее эффективен, если в приложении также нужно выполнять запросы по имени актеров.</span><span class="sxs-lookup"><span data-stu-id="d546a-196">This approach is less effective if the application also needs to query movies by starring actor.</span></span> <span data-ttu-id="d546a-197">В этом случае можно создать отдельную таблицу Azure, которая будет таблицей индексов.</span><span class="sxs-lookup"><span data-stu-id="d546a-197">In this case, you can create a separate Azure table that acts as an index table.</span></span> <span data-ttu-id="d546a-198">Ключ секции — это имя актера, а ключ строки — название фильма.</span><span class="sxs-lookup"><span data-stu-id="d546a-198">The partition key is the actor and the row key is the movie name.</span></span> <span data-ttu-id="d546a-199">Данные для каждого актера будут храниться в отдельной секции.</span><span class="sxs-lookup"><span data-stu-id="d546a-199">The data for each actor will be stored in separate partitions.</span></span> <span data-ttu-id="d546a-200">Если в фильме снимается несколько искомых актеров, его название будет содержаться в нескольких секциях.</span><span class="sxs-lookup"><span data-stu-id="d546a-200">If a movie stars more than one actor, the same movie will occur in multiple partitions.</span></span>

<span data-ttu-id="d546a-201">Можно дублировать данные фильма, содержащиеся в значениях в каждой секции, используя первый подход. Он описан выше в разделе "Решение".</span><span class="sxs-lookup"><span data-stu-id="d546a-201">You can duplicate the movie data in the values held by each partition by adopting the first approach described in the Solution section above.</span></span> <span data-ttu-id="d546a-202">Но есть вероятность, что каждый фильм будет реплицирован несколько раз (один раз для каждого актера). Поэтому лучше частично денормализовать данные для поддержки наиболее частых запросов (например, по именам других актеров). Также рекомендуем настроить приложение для получения всех оставшихся данных, включая ключ секции, необходимый для поиска подробной информации в секциях для жанра.</span><span class="sxs-lookup"><span data-stu-id="d546a-202">However, it's likely that each movie will be replicated several times (once for each actor), so it might be more efficient to partially denormalize the data to support the most common queries (such as the names of the other actors) and enable an application to retrieve any remaining details by including the partition key necessary to find the complete information in the genre partitions.</span></span> <span data-ttu-id="d546a-203">Этот подход описан как третий вариант в разделе "Решение".</span><span class="sxs-lookup"><span data-stu-id="d546a-203">This approach is described by the third option in the Solution section.</span></span> <span data-ttu-id="d546a-204">Он представлен на рисунке ниже.</span><span class="sxs-lookup"><span data-stu-id="d546a-204">The next figure shows this approach.</span></span>

![Рис. 8. Секции с именами актеров, служащие таблицами индексов для данных фильмов](./_images/index-table-figure-8.png)

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="d546a-206">Связанные шаблоны и рекомендации</span><span class="sxs-lookup"><span data-stu-id="d546a-206">Related patterns and guidance</span></span>

<span data-ttu-id="d546a-207">При реализации этого шаблона следует принять во внимание следующие шаблоны и рекомендации.</span><span class="sxs-lookup"><span data-stu-id="d546a-207">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="d546a-208">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx) (Руководство по обеспечению согласованности данных).</span><span class="sxs-lookup"><span data-stu-id="d546a-208">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span> <span data-ttu-id="d546a-209">Таблицы индексов должны обслуживаться, так как индексируемые данные могут измениться.</span><span class="sxs-lookup"><span data-stu-id="d546a-209">An index table must be maintained as the data that it indexes changes.</span></span> <span data-ttu-id="d546a-210">Иногда в облаке невозможно или нерентабельно обновлять индексы в рамках той же транзакции, в которой изменяются данные.</span><span class="sxs-lookup"><span data-stu-id="d546a-210">In the cloud, it might not be possible or appropriate to perform operations that update an index as part of the same transaction that modifies the data.</span></span> <span data-ttu-id="d546a-211">В этом случае подход конечной согласованности является более уместным.</span><span class="sxs-lookup"><span data-stu-id="d546a-211">In that case, an eventually consistent approach is more suitable.</span></span> <span data-ttu-id="d546a-212">Руководство содержит сведения о проблемах, которые касаются конечной согласованности.</span><span class="sxs-lookup"><span data-stu-id="d546a-212">Provides information on the issues surrounding eventual consistency.</span></span>
- <span data-ttu-id="d546a-213">[Шаблон сегментирования.](./sharding.md)</span><span class="sxs-lookup"><span data-stu-id="d546a-213">[Sharding pattern](./sharding.md).</span></span> <span data-ttu-id="d546a-214">Шаблон таблицы индексов часто используется с данными, которые секционированы с применением сегментов.</span><span class="sxs-lookup"><span data-stu-id="d546a-214">The Index Table pattern is frequently used in conjunction with data partitioned by using shards.</span></span> <span data-ttu-id="d546a-215">Шаблон сегментирования предоставляет дополнительные сведения о том, как преобразовать хранилище данных в набор сегментов.</span><span class="sxs-lookup"><span data-stu-id="d546a-215">The Sharding pattern provides more information on how to divide a data store into a set of shards.</span></span>
- <span data-ttu-id="d546a-216">[Materialized View Pattern](./materialized-view.md) (Шаблон материализованного представления).</span><span class="sxs-lookup"><span data-stu-id="d546a-216">[Materialized View pattern](./materialized-view.md).</span></span> <span data-ttu-id="d546a-217">Вместо индексирования данных для поддержки сводных запросов, возможно, целесообразнее создать материализованное представление данных.</span><span class="sxs-lookup"><span data-stu-id="d546a-217">Instead of indexing data to support queries that summarize data, it might be more appropriate to create a materialized view of the data.</span></span> <span data-ttu-id="d546a-218">Здесь описано, как реализовать эффективную поддержку сводных запросов, создав предварительно заполненные представления данных.</span><span class="sxs-lookup"><span data-stu-id="d546a-218">Describes how to support efficient summary queries by generating prepopulated views over data.</span></span>

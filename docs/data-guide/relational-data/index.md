---
title: Реляционные данные
description: ''
author: zoinerTejada
ms.date: 02/12/2018
ms.openlocfilehash: 0ed15bfe93c0cebffb377543eda9dd84e65d7c02
ms.sourcegitcommit: e7e0e0282fa93f0063da3b57128ade395a9c1ef9
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/05/2018
ms.locfileid: "52901421"
---
# <a name="traditional-relational-database-solutions"></a><span data-ttu-id="009de-102">Решения для традиционных реляционных баз данных</span><span class="sxs-lookup"><span data-stu-id="009de-102">Traditional relational database solutions</span></span>

<span data-ttu-id="009de-103">Реляционные данные — это данные, которые моделируются с помощью реляционной модели.</span><span class="sxs-lookup"><span data-stu-id="009de-103">Relational data is data modeled using the relational model.</span></span> <span data-ttu-id="009de-104">В этой модели данные представлены в виде кортежей.</span><span class="sxs-lookup"><span data-stu-id="009de-104">In this model, data is expressed as tuples.</span></span> <span data-ttu-id="009de-105">*Кортеж* — это набор пар "атрибут-значение".</span><span class="sxs-lookup"><span data-stu-id="009de-105">A *tuple* is a set of attribute/value pairs.</span></span> <span data-ttu-id="009de-106">Например, кортеж может быть таким: itemid = 5, orderid = 1, item = "Chair", amount = 200.</span><span class="sxs-lookup"><span data-stu-id="009de-106">For example, a tuple might be (itemid = 5, orderid = 1, item = "Chair", amount = 200.00).</span></span> <span data-ttu-id="009de-107">Набор кортежей, в которых совместно используются одни и те же атрибуты, называется *отношением*.</span><span class="sxs-lookup"><span data-stu-id="009de-107">A set of tuples that all share the same attributes is called a *relation*.</span></span> 

<span data-ttu-id="009de-108">Отношения представляются в виде таблиц, где каждый кортеж — это строка.</span><span class="sxs-lookup"><span data-stu-id="009de-108">Relations are naturally represented as tables, where each tuple is exposed as a row in the table.</span></span> <span data-ttu-id="009de-109">Но в отличие от кортежей, строки имеют явное упорядочение.</span><span class="sxs-lookup"><span data-stu-id="009de-109">However, rows have an explicit ordering, unlike tuples.</span></span> <span data-ttu-id="009de-110">Схема базы данных определяет столбцы (заголовки) для каждой таблицы.</span><span class="sxs-lookup"><span data-stu-id="009de-110">The database schema defines the columns (headings) of each table.</span></span> <span data-ttu-id="009de-111">Среди всех строк в таблице каждый столбец определяется именем и типом данных всех значений, хранящихся в нем.</span><span class="sxs-lookup"><span data-stu-id="009de-111">Each column is defined with a name and a data type for all values stored in that column across all rows in the table.</span></span>

![Пример, демонстрирующий данные, для которых используется реляционная база данных](../images/example-relational.png)

<span data-ttu-id="009de-113">Хранилище данных, в котором данные упорядочены с помощью реляционной модели, называется реляционной базой данных.</span><span class="sxs-lookup"><span data-stu-id="009de-113">A data store that organizes data using the relational model is referred to as a relational database.</span></span> <span data-ttu-id="009de-114">Первичные ключи однозначно определяют строки внутри таблицы.</span><span class="sxs-lookup"><span data-stu-id="009de-114">Primary keys uniquely identify rows within a table.</span></span> <span data-ttu-id="009de-115">Поля внешних ключей используются в одной таблице для ссылки на строку в другой таблице с помощью ссылки на первичный ключ другой таблицы.</span><span class="sxs-lookup"><span data-stu-id="009de-115">Foreign key fields are used in one table to refer to a row in another table by referencing the primary key of the other table.</span></span> <span data-ttu-id="009de-116">Внешние ключи используются для обеспечения целостности данных, которая гарантирует, что указанные строки не будут изменяться или удаляться, пока ссылающаяся строка зависит от них.</span><span class="sxs-lookup"><span data-stu-id="009de-116">Foreign keys are used to maintain referential integrity, ensuring that the referenced rows are not altered or deleted while the referencing row depends on them.</span></span> 

![Пример, демонстрирующий данные, для которых используется реляционная база данных](../images/example-relational2.png)

<span data-ttu-id="009de-118">Реляционные базы данных поддерживают ограничения различных типов, помогающие обеспечить целостность данных.</span><span class="sxs-lookup"><span data-stu-id="009de-118">Relational databases support various types of constraints that help to ensure data integrity:</span></span>

- <span data-ttu-id="009de-119">Ограничения уникальности гарантируют, что все значения в столбце являются уникальными.</span><span class="sxs-lookup"><span data-stu-id="009de-119">Unique constraints ensure that all values in a column are unique.</span></span> 

- <span data-ttu-id="009de-120">Ограничения внешнего ключа принудительно устанавливают связь между данными в двух таблицах.</span><span class="sxs-lookup"><span data-stu-id="009de-120">Foreign key constraints enforce a link between the data in two tables.</span></span> <span data-ttu-id="009de-121">Внешний ключ ссылается на первичный ключ или другой уникальный ключ в другой таблице.</span><span class="sxs-lookup"><span data-stu-id="009de-121">A foreign key references the primary key or another unique key from another table.</span></span> <span data-ttu-id="009de-122">Ограничение внешнего ключа обеспечивает целостность данных, запрещая вносить изменения, которые могут привести к недопустимым значениям внешнего ключа.</span><span class="sxs-lookup"><span data-stu-id="009de-122">A foreign key constraint enforces referential integrity, disallowing changes that cause invalid foreign key values.</span></span>

- <span data-ttu-id="009de-123">Ограничения проверки, также известные как ограничения целостности сущностей, применяются к значениям, которые могут храниться в одном столбце или быть связанными со значениями других столбцов той же строки.</span><span class="sxs-lookup"><span data-stu-id="009de-123">Check constraints, also known as entity integrity constraints, limit the values that can be stored within a single column, or in relationship to values in other columns of the same row.</span></span> 

<span data-ttu-id="009de-124">Для большинства реляционных баз данных используется язык SQL, который позволяет применять декларативный подход к выполнению запросов.</span><span class="sxs-lookup"><span data-stu-id="009de-124">Most relational databases use the Structured Query Language (SQL) language that enables a declarative approach to querying.</span></span> <span data-ttu-id="009de-125">В запросе описывается нужный результат, но не описываются действия для выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="009de-125">The query describes the desired result, but not the steps to execute the query.</span></span> <span data-ttu-id="009de-126">Лучший способ выполнения запроса выбирается обработчиком.</span><span class="sxs-lookup"><span data-stu-id="009de-126">The engine then decides the best way to execute the query.</span></span> <span data-ttu-id="009de-127">Этот подход отличается от процедурного, где в программе запроса явно указываются шаги обработки.</span><span class="sxs-lookup"><span data-stu-id="009de-127">This differs from a procedural approach, where the query program specifies the processing steps explicitly.</span></span> <span data-ttu-id="009de-128">Но в реляционных базах данных могут храниться подпрограммы исполняемого кода в виде хранимых процедур и функций. Эта возможность позволяет сочетать декларативный и процедурный подходы.</span><span class="sxs-lookup"><span data-stu-id="009de-128">However, relational databases can store executable code routines in the form of stored procedures and functions, which enables a mixture of declarative and procedural approaches.</span></span>

<span data-ttu-id="009de-129">Чтобы повысить производительность запросов, в реляционных базах данных используются *индексы*.</span><span class="sxs-lookup"><span data-stu-id="009de-129">To improve query performance, relational databases use *indexes*.</span></span> <span data-ttu-id="009de-130">Первичные индексы, используемые первичным ключом, определяют порядок размещения данных на диске.</span><span class="sxs-lookup"><span data-stu-id="009de-130">Primary indexes, which are used by the primary key, define the order of the data as it sits on disk.</span></span> <span data-ttu-id="009de-131">Вторичные индексы обеспечивают альтернативное сочетание полей, чтобы можно было эффективно подавать запросы на нужные строки без повторной сортировки всех данных на диске.</span><span class="sxs-lookup"><span data-stu-id="009de-131">Secondary indexes provide an alternative combination of fields, so the desired rows can be queried efficiently, without having to re-sort the entire data on disk.</span></span>

<span data-ttu-id="009de-132">Так как реляционные базы данных обеспечивают целостность данных, масштабирование реляционной базы данных может стать сложной задачей.</span><span class="sxs-lookup"><span data-stu-id="009de-132">Because relational databases enforce referential integrity, scaling a relational database can become challenging.</span></span> <span data-ttu-id="009de-133">Это связано с тем, что любая операция запроса или вставки может повлиять на любое количество таблиц.</span><span class="sxs-lookup"><span data-stu-id="009de-133">That's because any query or insert operation might touch any number of tables.</span></span> <span data-ttu-id="009de-134">Реляционную базу данных можно масштабировать с помощью *сегментирования* данных, но этот процесс требует тщательного проектирования.</span><span class="sxs-lookup"><span data-stu-id="009de-134">You can scale out a relational database by *sharding* the data, but this requires careful design of the schema.</span></span> <span data-ttu-id="009de-135">Дополнительные сведения см. в статье о [шаблоне сегментирования](../../patterns/sharding.md).</span><span class="sxs-lookup"><span data-stu-id="009de-135">For more information, see [Sharding pattern](../../patterns/sharding.md).</span></span>

<span data-ttu-id="009de-136">Для нереляционных данных или данных, требования которых не совместимы с реляционными базами данных, рекомендуем использовать [нереляционное хранилище данных или хранилище данных NoSQL](../big-data/non-relational-data.md).</span><span class="sxs-lookup"><span data-stu-id="009de-136">If data is non-relational or has requirements that are not suited to a relational database, consider a [Non-relational or NoSQL](../big-data/non-relational-data.md) data store.</span></span>

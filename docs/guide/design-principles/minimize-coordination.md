---
title: Минимизация координации
titleSuffix: Azure Application Architecture Guide
description: Сведите к минимуму координацию между службами приложений, чтобы обеспечить масштабируемость.
author: MikeWasson
ms.date: 08/30/2018
ms.custom: seojan19
ms.openlocfilehash: ec1a7a3de2be4954b07a87b774f8ae7c2bd1f736
ms.sourcegitcommit: 1f4cdb08fe73b1956e164ad692f792f9f635b409
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2019
ms.locfileid: "54113099"
---
# <a name="minimize-coordination"></a><span data-ttu-id="c4ff5-103">Минимизация координации</span><span class="sxs-lookup"><span data-stu-id="c4ff5-103">Minimize coordination</span></span>

## <a name="minimize-coordination-between-application-services-to-achieve-scalability"></a><span data-ttu-id="c4ff5-104">Сведите к минимуму координацию между службами приложений, чтобы обеспечить масштабируемость</span><span class="sxs-lookup"><span data-stu-id="c4ff5-104">Minimize coordination between application services to achieve scalability</span></span>

<span data-ttu-id="c4ff5-105">Большинство облачных приложений состоит из нескольких служб приложений и веб-интерфейсов, баз данных, бизнес-процессов, отчетов и аналитики и т. д.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-105">Most cloud applications consist of multiple application services &mdash; web front ends, databases, business processes, reporting and analysis, and so on.</span></span> <span data-ttu-id="c4ff5-106">Чтобы обеспечить масштабируемость и надежность, каждая из этих служб должна выполняться на нескольких экземплярах.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-106">To achieve scalability and reliability, each of those services should run on multiple instances.</span></span>

<span data-ttu-id="c4ff5-107">Что произойдет, если два экземпляра попытаются одновременно выполнить операции, влияющие на общее состояние?</span><span class="sxs-lookup"><span data-stu-id="c4ff5-107">What happens when two instances try to perform concurrent operations that affect some shared state?</span></span> <span data-ttu-id="c4ff5-108">В некоторых случаях требуется координация действий между узлами, например для поддержки гарантий ACID.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-108">In some cases, there must be coordination across nodes, for example to preserve ACID guarantees.</span></span> <span data-ttu-id="c4ff5-109">На этой схеме служба `Node2` ожидает, пока `Node1` снимет блокировку базы данных:</span><span class="sxs-lookup"><span data-stu-id="c4ff5-109">In this diagram, `Node2` is waiting for `Node1` to release a database lock:</span></span>

![Схема блокировки базы данных](./images/database-lock.svg)

<span data-ttu-id="c4ff5-111">Любая координация связана с ограничением возможностей, предоставляемых горизонтальным масштабированием, и определенными сложностями.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-111">Coordination limits the benefits of horizontal scale and creates bottlenecks.</span></span> <span data-ttu-id="c4ff5-112">В этом примере конфликты блокировки будут возникать все чаще по мере увеличения масштаба приложения и числа экземпляров.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-112">In this example, as you scale out the application and add more instances, you'll see increased lock contention.</span></span> <span data-ttu-id="c4ff5-113">В самом худшем случае экземпляры интерфейса будут находиться в состоянии блокировки большую часть времени.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-113">In the worst case, the front-end instances will spend most of their time waiting on locks.</span></span>

<span data-ttu-id="c4ff5-114">Еще одна распространенная причина, требующая координации, — семантика запроса "только один раз".</span><span class="sxs-lookup"><span data-stu-id="c4ff5-114">"Exactly once" semantics are another frequent source of coordination.</span></span> <span data-ttu-id="c4ff5-115">Например, каждый заказ должен быть обработан только один раз.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-115">For example, an order must be processed exactly once.</span></span> <span data-ttu-id="c4ff5-116">Два рабочих процесса ожидают появления новых заказов.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-116">Two workers are listening for new orders.</span></span> <span data-ttu-id="c4ff5-117">`Worker1` извлекает заказ для обработки.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-117">`Worker1` picks up an order for processing.</span></span> <span data-ttu-id="c4ff5-118">Теперь приложение должно гарантировать следующее: 1) `Worker2` не будет дублировать эту работу, 2) заказ не будет потерян в случае сбоя `Worker1`.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-118">The application must ensure that `Worker2` doesn't duplicate the work, but also if `Worker1` crashes, the order isn't dropped.</span></span>

![Схема координации](./images/coordination.svg)

<span data-ttu-id="c4ff5-120">Вы можете применить для координации рабочих потоков шаблон [Планировщик, агент, контролер][sas-pattern] Но в нашем примере удобнее будет секционировать работу.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-120">You can use a pattern such as [Scheduler Agent Supervisor][sas-pattern] to coordinate between the workers, but in this case a better approach might be to partition the work.</span></span> <span data-ttu-id="c4ff5-121">Каждой рабочей роли назначается некоторое число заказов (например, с привязкой к региону выставления счетов).</span><span class="sxs-lookup"><span data-stu-id="c4ff5-121">Each worker is assigned a certain range of orders (say, by billing region).</span></span> <span data-ttu-id="c4ff5-122">Если рабочий процесс завершится сбоем, его новый экземпляр начнет работу там, где остановился предыдущий, но соседние экземпляры не будут конкурировать.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-122">If a worker crashes, a new instance picks up where the previous instance left off, but multiple instances aren't contending.</span></span>

## <a name="recommendations"></a><span data-ttu-id="c4ff5-123">Рекомендации</span><span class="sxs-lookup"><span data-stu-id="c4ff5-123">Recommendations</span></span>

<span data-ttu-id="c4ff5-124">**Учитывайте итоговую согласованность**.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-124">**Embrace eventual consistency**.</span></span> <span data-ttu-id="c4ff5-125">Если данные распределяются между несколькими объектами, только координация между ними обеспечит строгую согласованность.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-125">When data is distributed, it takes coordination to enforce strong consistency guarantees.</span></span> <span data-ttu-id="c4ff5-126">Предположим, что определенная операция обновляет две базы данных.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-126">For example, suppose an operation updates two databases.</span></span> <span data-ttu-id="c4ff5-127">Вместо того, чтобы включать эту операцию в одну транзакцию, создайте в системе механизм обеспечения итоговой согласованности. Например, шаблон [компенсирующих транзакций][compensating-transaction] позволит выполнить логический откат в случае сбоя.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-127">Instead of putting it into a single transaction scope, it's better if the system can accommodate eventual consistency, perhaps by using the [Compensating Transaction][compensating-transaction] pattern to logically roll back after a failure.</span></span>

<span data-ttu-id="c4ff5-128">**Используйте события предметной области для синхронизации состояний**.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-128">**Use domain events to synchronize state**.</span></span> <span data-ttu-id="c4ff5-129">[Событие предметной области][domain-event] регистрируется, когда в пределах некоторой предметной области происходит что-то важное.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-129">A [domain event][domain-event] is an event that records when something happens that has significance within the domain.</span></span> <span data-ttu-id="c4ff5-130">Такие события могут прослушиваться всеми заинтересованными службами, что позволяет обойтись без глобальных транзакций для координации действий между несколькими службами.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-130">Interested services can listen for the event, rather than using a global transaction to coordinate across multiple services.</span></span> <span data-ttu-id="c4ff5-131">Чтобы применить такой подход, система должна поддерживать итоговую согласованность (см. предыдущий пункт).</span><span class="sxs-lookup"><span data-stu-id="c4ff5-131">If this approach is used, the system must tolerate eventual consistency (see previous item).</span></span>

<span data-ttu-id="c4ff5-132">**Изучите такие шаблоны, как CQRS и шаблон источников событий**.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-132">**Consider patterns such as CQRS and event sourcing**.</span></span> <span data-ttu-id="c4ff5-133">Эти два шаблона минимизируют вероятность конфликтов между рабочими нагрузками чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-133">These two patterns can help to reduce contention between read workloads and write workloads.</span></span>

- <span data-ttu-id="c4ff5-134">[Шаблон CQRS][cqrs-pattern] разделяет операции чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-134">The [CQRS pattern][cqrs-pattern] separates read operations from write operations.</span></span> <span data-ttu-id="c4ff5-135">В некоторых реализациях данные для чтения физически отделены от данных для записи.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-135">In some implementations, the read data is physically separated from the write data.</span></span>

- <span data-ttu-id="c4ff5-136">В [шаблоне источников событий][event-sourcing] все изменения состояния сохраняются в виде последовательности событий в хранилище постоянного пополнения.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-136">In the [Event Sourcing pattern][event-sourcing], state changes are recorded as a series of events to an append-only data store.</span></span> <span data-ttu-id="c4ff5-137">Добавление одного события в такой поток является атомарной операцией и требует минимальных блокировок.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-137">Appending an event to the stream is an atomic operation, requiring minimal locking.</span></span>

<span data-ttu-id="c4ff5-138">Эти два шаблона дополняют друг друга.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-138">These two patterns complement each other.</span></span> <span data-ttu-id="c4ff5-139">Если к хранилищу, которое в соответствии с шаблоном CQRS используется только для записи, применить источники событий, такое хранилище для чтения сможет ожидать те же события и воспроизводить моментальный снимок текущего состояния, оптимизированный для обработки запросов.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-139">If the write-only store in CQRS uses event sourcing, the read-only store can listen for the same events to create a readable snapshot of the current state, optimized for queries.</span></span> <span data-ttu-id="c4ff5-140">Но прежде, чем внедрять CQRS или источники событий, ознакомьтесь с особенностями такого подхода.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-140">Before adopting CQRS or event sourcing, however, be aware of the challenges of this approach.</span></span> <span data-ttu-id="c4ff5-141">Дополнительные сведения см. в статье о [стиле архитектуры CQRS][cqrs-style].</span><span class="sxs-lookup"><span data-stu-id="c4ff5-141">For more information, see [CQRS architecture style][cqrs-style].</span></span>

<span data-ttu-id="c4ff5-142">**Секционирование данных**.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-142">**Partition data**.</span></span>  <span data-ttu-id="c4ff5-143">Не включайте все данные в одну схему данных, которую используют сразу несколько служб приложения.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-143">Avoid putting all of your data into one data schema that is shared across many application services.</span></span> <span data-ttu-id="c4ff5-144">Архитектура микрослужб принудительно применяет этот принцип, назначая каждой службе собственное хранилище данных.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-144">A microservices architecture enforces this principle by making each service responsible for its own data store.</span></span> <span data-ttu-id="c4ff5-145">В пределах одной базы данных секционирование данных может оптимизировать параллелизм, так как запись в любой из сегментов никак не влияет на службы, использующие для записи другие сегменты.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-145">Within a single database, partitioning the data into shards can improve concurrency, because a service writing to one shard does not affect a service writing to a different shard.</span></span>

<span data-ttu-id="c4ff5-146">**Применяйте идемпотентные операции**.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-146">**Design idempotent operations**.</span></span> <span data-ttu-id="c4ff5-147">Везде, где это возможно, применяйте идемпотентные операции.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-147">When possible, design operations to be idempotent.</span></span> <span data-ttu-id="c4ff5-148">Это позволит всегда обрабатывать их с использованием семантики "как минимум один раз".</span><span class="sxs-lookup"><span data-stu-id="c4ff5-148">That way, they can be handled using at-least-once semantics.</span></span> <span data-ttu-id="c4ff5-149">Предположим, вы помещаете рабочие элементы в очередь.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-149">For example, you can put work items on a queue.</span></span> <span data-ttu-id="c4ff5-150">Если при выполнении операции рабочая роль завершится сбоем, следующая рабочая роль просто выберет тот же рабочий элемент.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-150">If a worker crashes in the middle of an operation, another worker simply picks up the work item.</span></span>

<span data-ttu-id="c4ff5-151">**Используйте параллельную и асинхронную обработку.**</span><span class="sxs-lookup"><span data-stu-id="c4ff5-151">**Use asynchronous parallel processing**.</span></span> <span data-ttu-id="c4ff5-152">Если для операция выполняется в несколько этапов, которые выполняются асинхронно (например, вызовы удаленных служб), вы можете вызывать их параллельно и объединять полученные результаты.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-152">If an operation requires multiple steps that are performed asynchronously (such as remote service calls), you might be able to call them in parallel, and then aggregate the results.</span></span> <span data-ttu-id="c4ff5-153">Такой подход предполагает, что каждый шаг никак не зависит от результатов выполнения предыдущего шага.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-153">This approach assumes that each step does not depend on the results of the previous step.</span></span>

<span data-ttu-id="c4ff5-154">**Используйте оптимистическую блокировку, если это возможно**.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-154">**Use optimistic concurrency when possible**.</span></span> <span data-ttu-id="c4ff5-155">Пессимистическое управление параллелизмом подразумевает блокировку базы данных для предотвращения конфликтов.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-155">Pessimistic concurrency control uses database locks to prevent conflicts.</span></span> <span data-ttu-id="c4ff5-156">Это может снижать производительность и доступность системы.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-156">This can cause poor performance and reduce availability.</span></span> <span data-ttu-id="c4ff5-157">Если применить оптимистическое управление параллелизмом, каждая транзакция изменит собственную копию (моментальный снимок) данных.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-157">With optimistic concurrency control, each transaction modifies a copy or snapshot of the data.</span></span> <span data-ttu-id="c4ff5-158">Когда транзакция будет зафиксирована, ядро СУБД проверит эту транзакцию и отклонит ее, если она может повлиять на согласованность базы данных.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-158">When the transaction is committed, the database engine validates the transaction and rejects any transactions that would affect database consistency.</span></span>

<span data-ttu-id="c4ff5-159">База данных SQL Azure и SQL Server поддерживают оптимистический параллелизм, выполняя [изоляцию моментальных снимков][sql-snapshot-isolation].</span><span class="sxs-lookup"><span data-stu-id="c4ff5-159">Azure SQL Database and SQL Server support optimistic concurrency through [snapshot isolation][sql-snapshot-isolation].</span></span> <span data-ttu-id="c4ff5-160">Некоторые службы хранилища Azure, например [Azure Cosmos DB][cosmosdb-faq] и [служба хранилища Azure][storage-concurrency], поддерживают оптимистическую блокировку с помощью тэгов eTag.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-160">Some Azure storage services support optimistic concurrency through the use of Etags, including [Azure Cosmos DB][cosmosdb-faq] and [Azure Storage][storage-concurrency].</span></span>

<span data-ttu-id="c4ff5-161">**Применяйте MapReduce или другой алгоритм распределенной параллельной обработки**.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-161">**Consider MapReduce or other parallel, distributed algorithms**.</span></span> <span data-ttu-id="c4ff5-162">В зависимости от характера данных и выполняемой работы, иногда ее можно разделить на несколько независимых задач, чтобы выполнять эти задачи параллельно на нескольких узлах.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-162">Depending on the data and type of work to be performed, you may be able to split the work into independent tasks that can be performed by multiple nodes working in parallel.</span></span> <span data-ttu-id="c4ff5-163">См. статью [Стиль архитектуры для больших вычислений][big-compute].</span><span class="sxs-lookup"><span data-stu-id="c4ff5-163">See [Big compute architecture style][big-compute].</span></span>

<span data-ttu-id="c4ff5-164">**Используйте шаблон выбора лидера для координации действий**.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-164">**Use leader election for coordination**.</span></span> <span data-ttu-id="c4ff5-165">В тех случаях, когда операции необходимо координировать, сделайте так, чтобы координатор не был единой точкой отказа в приложении.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-165">In cases where you need to coordinate operations, make sure the coordinator does not become a single point of failure in the application.</span></span> <span data-ttu-id="c4ff5-166">Если реализовать [шаблон выборов лидера][leader-election], в каждый момент времени один из экземпляров будет лидером, который выполняет функции координатора.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-166">Using the [Leader Election pattern][leader-election], one instance is the leader at any time, and acts as the coordinator.</span></span> <span data-ttu-id="c4ff5-167">Если в этом экземпляре происходит сбой, выбирается новый лидер.</span><span class="sxs-lookup"><span data-stu-id="c4ff5-167">If the leader fails, a new instance is elected to be the leader.</span></span>

<!-- links -->

[big-compute]: ../architecture-styles/big-compute.md
[compensating-transaction]: ../../patterns/compensating-transaction.md
[cqrs-style]: ../architecture-styles/cqrs.md
[cqrs-pattern]: ../../patterns/cqrs.md
[cosmosdb-faq]: /azure/cosmos-db/faq
[domain-event]: https://martinfowler.com/eaaDev/DomainEvent.html
[event-sourcing]: ../../patterns/event-sourcing.md
[leader-election]: ../../patterns/leader-election.md
[sas-pattern]: ../../patterns/scheduler-agent-supervisor.md
[sql-snapshot-isolation]: /sql/t-sql/statements/set-transaction-isolation-level-transact-sql
[storage-concurrency]: https://azure.microsoft.com/blog/managing-concurrency-in-microsoft-azure-storage-2/
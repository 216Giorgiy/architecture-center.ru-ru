---
title: Стиль архитектуры CQRS
titleSuffix: Azure Application Architecture Guide
description: В этой статье описаны преимущества и проблемы, связанные с использованием архитектур CQRS, а также рекомендации по работе с ними.
author: MikeWasson
ms.date: 08/30/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: seojan19
ms.openlocfilehash: 35f37afa60f943f410f1fbd46c789c0b2c66e36e
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/20/2019
ms.locfileid: "58246205"
---
# <a name="cqrs-architecture-style"></a><span data-ttu-id="eade2-103">Стиль архитектуры CQRS</span><span class="sxs-lookup"><span data-stu-id="eade2-103">CQRS architecture style</span></span>

<span data-ttu-id="eade2-104">Модель CQRS — это стиль архитектуры, в котором операции чтения отделены от операций записи.</span><span class="sxs-lookup"><span data-stu-id="eade2-104">Command and Query Responsibility Segregation (CQRS) is an architecture style that separates read operations from write operations.</span></span>

![Логическая схема архитектуры CQRS](./images/cqrs-logical.svg)

<span data-ttu-id="eade2-106">В традиционных архитектурах аналогичная модель используется в базах данных для выполнения запросов и обновлений.</span><span class="sxs-lookup"><span data-stu-id="eade2-106">In traditional architectures, the same data model is used to query and update a database.</span></span> <span data-ttu-id="eade2-107">Этот простой подход отлично подходит для базовых операций создания, чтения, обновления и удаления.</span><span class="sxs-lookup"><span data-stu-id="eade2-107">That's simple and works well for basic CRUD operations.</span></span> <span data-ttu-id="eade2-108">Но в более сложных приложениях такой подход не всегда будет удобным.</span><span class="sxs-lookup"><span data-stu-id="eade2-108">In more complex applications, however, this approach can become unwieldy.</span></span> <span data-ttu-id="eade2-109">Например, при чтении данных приложение может выполнять много разных запросов и возвращать несколько объектов передачи данных разных форм.</span><span class="sxs-lookup"><span data-stu-id="eade2-109">For example, on the read side, the application may perform many different queries, returning data transfer objects (DTOs) with different shapes.</span></span> <span data-ttu-id="eade2-110">Это усложняет сопоставление объектов.</span><span class="sxs-lookup"><span data-stu-id="eade2-110">Object mapping can become complicated.</span></span> <span data-ttu-id="eade2-111">Для записи данных модель может применять сложные процедуры проверки и процессы бизнес-логики.</span><span class="sxs-lookup"><span data-stu-id="eade2-111">On the write side, the model may implement complex validation and business logic.</span></span> <span data-ttu-id="eade2-112">В результате вы получите слишком сложную модель, которая выполняет слишком много функций.</span><span class="sxs-lookup"><span data-stu-id="eade2-112">As a result, you can end up with an overly complex model that does too much.</span></span>

<span data-ttu-id="eade2-113">Еще одна возможная проблема заключается в том, что рабочие нагрузки чтения и записи часто асимметричны и имеют совершенно разные требования к производительности и масштабируемости.</span><span class="sxs-lookup"><span data-stu-id="eade2-113">Another potential problem is that read and write workloads are often asymmetrical, with very different performance and scale requirements.</span></span>

<span data-ttu-id="eade2-114">Модель CQRS устраняет эти проблемы, разделяя потоки чтения и записи: для обновления данных используются **команды**, а для чтения — **запросы**.</span><span class="sxs-lookup"><span data-stu-id="eade2-114">CQRS addresses these problems by separating reads and writes into separate models, using **commands** to update data, and **queries** to read data.</span></span>

- <span data-ttu-id="eade2-115">В основе команд должны быть задачи, а не данные.</span><span class="sxs-lookup"><span data-stu-id="eade2-115">Commands should be task based, rather than data centric.</span></span> <span data-ttu-id="eade2-116">(Например, команда может выполнять функцию "Зарезервировать номер в отеле", но не "Установить значение Reserved для свойства ReservationStatus".) Команды лучше помещать в асинхронную очередь, а не требовать синхронной обработки.</span><span class="sxs-lookup"><span data-stu-id="eade2-116">("Book hotel room," not "set ReservationStatus to Reserved.") Commands may be placed on a queue for asynchronous processing, rather than being processed synchronously.</span></span>

- <span data-ttu-id="eade2-117">Запросы никогда не изменяют данные в базе данных.</span><span class="sxs-lookup"><span data-stu-id="eade2-117">Queries never modify the database.</span></span> <span data-ttu-id="eade2-118">Запрос возвращает объект передачи данных, который не содержит сведения о предметной области.</span><span class="sxs-lookup"><span data-stu-id="eade2-118">A query returns a DTO that does not encapsulate any domain knowledge.</span></span>

<span data-ttu-id="eade2-119">Для дополнительной изоляции можно физически разделить данные для чтения и данные для записи.</span><span class="sxs-lookup"><span data-stu-id="eade2-119">For greater isolation, you can physically separate the read data from the write data.</span></span> <span data-ttu-id="eade2-120">В этом случае в базе данных для чтения можно оптимизировать схему данных так, чтобы максимально эффективно выполнять запросы.</span><span class="sxs-lookup"><span data-stu-id="eade2-120">In that case, the read database can use its own data schema that is optimized for queries.</span></span> <span data-ttu-id="eade2-121">Например, в ней можно хранить [материализованные представления][materialized-view] данных, чтобы не использовать сложные операции соединения или сложные объектно-реляционные сопоставления.</span><span class="sxs-lookup"><span data-stu-id="eade2-121">For example, it can store a [materialized view][materialized-view] of the data, in order to avoid complex joins or complex O/RM mappings.</span></span> <span data-ttu-id="eade2-122">Вы можете даже применить другой тип хранилища данных.</span><span class="sxs-lookup"><span data-stu-id="eade2-122">It might even use a different type of data store.</span></span> <span data-ttu-id="eade2-123">Например, база данных для записи останется реляционной, а для чтения вы примените базу данных документов.</span><span class="sxs-lookup"><span data-stu-id="eade2-123">For example, the write database might be relational, while the read database is a document database.</span></span>

<span data-ttu-id="eade2-124">Если для чтения и записи используются разные базы данных, для них нужно поддерживать синхронизацию. Обычно для этого модель записи публикует событие при каждом обновлении базы данных.</span><span class="sxs-lookup"><span data-stu-id="eade2-124">If separate read and write databases are used, they must be kept in sync. Typically this is accomplished by having the write model publish an event whenever it updates the database.</span></span> <span data-ttu-id="eade2-125">Обновление базы данных и публикации события должны выполняться в рамках одной транзакции.</span><span class="sxs-lookup"><span data-stu-id="eade2-125">Updating the database and publishing the event must occur in a single transaction.</span></span>

<span data-ttu-id="eade2-126">Некоторые реализации CQRS используют [шаблон источников событий][event-sourcing].</span><span class="sxs-lookup"><span data-stu-id="eade2-126">Some implementations of CQRS use the [Event Sourcing pattern][event-sourcing].</span></span> <span data-ttu-id="eade2-127">В этом шаблоне состояние приложения сохраняется как последовательность событий.</span><span class="sxs-lookup"><span data-stu-id="eade2-127">With this pattern, application state is stored as a sequence of events.</span></span> <span data-ttu-id="eade2-128">Каждое событие обозначает некоторый набор изменений в данных.</span><span class="sxs-lookup"><span data-stu-id="eade2-128">Each event represents a set of changes to the data.</span></span> <span data-ttu-id="eade2-129">Текущее состояние воссоздается при последовательном воспроизведении событий.</span><span class="sxs-lookup"><span data-stu-id="eade2-129">The current state is constructed by replaying the events.</span></span> <span data-ttu-id="eade2-130">В контексте CQRS шаблон источников событий удобен тем, что эти же события могут оповещать другие компоненты, в частности модель чтения.</span><span class="sxs-lookup"><span data-stu-id="eade2-130">In a CQRS context, one benefit of Event Sourcing is that the same events can be used to notify other components &mdash; in particular, to notify the read model.</span></span> <span data-ttu-id="eade2-131">Модель чтения на основе событий поддерживает моментальный снимок текущего состояния, повышая эффективность запросов.</span><span class="sxs-lookup"><span data-stu-id="eade2-131">The read model uses the events to create a snapshot of the current state, which is more efficient for queries.</span></span> <span data-ttu-id="eade2-132">Но учтите, что шаблон источников событий усложняет архитектуру.</span><span class="sxs-lookup"><span data-stu-id="eade2-132">However, Event Sourcing adds complexity to the design.</span></span>

![События CQRS](./images/cqrs-events.svg)

## <a name="when-to-use-this-architecture"></a><span data-ttu-id="eade2-134">Когда следует использовать эту архитектуру</span><span class="sxs-lookup"><span data-stu-id="eade2-134">When to use this architecture</span></span>

<span data-ttu-id="eade2-135">Использовать CQRS можно в системах для совместной работы, где большое число пользователей обращается к одним и тем же данным, особенно если рабочие нагрузки чтения и записи явно асимметричны.</span><span class="sxs-lookup"><span data-stu-id="eade2-135">Consider CQRS for collaborative domains where many users access the same data, especially when the read and write workloads are asymmetrical.</span></span>

<span data-ttu-id="eade2-136">CQRS нельзя считать архитектурой верхнего уровня, применимой в масштабе всей системы.</span><span class="sxs-lookup"><span data-stu-id="eade2-136">CQRS is not a top-level architecture that applies to an entire system.</span></span> <span data-ttu-id="eade2-137">Применяйте CQRS только к тем подсистемам, где заметны явные преимущества от разделения процессов чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="eade2-137">Apply CQRS only to those subsystems where there is clear value in separating reads and writes.</span></span> <span data-ttu-id="eade2-138">В противном случае вы только повысите сложность системы, не получая никаких преимуществ.</span><span class="sxs-lookup"><span data-stu-id="eade2-138">Otherwise, you are creating additional complexity for no benefit.</span></span>

## <a name="benefits"></a><span data-ttu-id="eade2-139">Преимущества</span><span class="sxs-lookup"><span data-stu-id="eade2-139">Benefits</span></span>

- <span data-ttu-id="eade2-140">**Независимое масштабирование**.</span><span class="sxs-lookup"><span data-stu-id="eade2-140">**Independently scaling**.</span></span> <span data-ttu-id="eade2-141">CQRS позволяет раздельно масштабировать рабочие нагрузки чтения и записи, снижая риск конфликтов блокировки.</span><span class="sxs-lookup"><span data-stu-id="eade2-141">CQRS allows the read and write workloads to scale independently, and may result in fewer lock contentions.</span></span>
- <span data-ttu-id="eade2-142">**Оптимизация схем данных.**</span><span class="sxs-lookup"><span data-stu-id="eade2-142">**Optimized data schemas**.</span></span> <span data-ttu-id="eade2-143">Для процессов чтения можно применить схему, оптимизированную для запросов, а для процессов записи — другую схему, оптимизированную для обновлений.</span><span class="sxs-lookup"><span data-stu-id="eade2-143">The read side can use a schema that is optimized for queries, while the write side uses a schema that is optimized for updates.</span></span>
- <span data-ttu-id="eade2-144">**Безопасность**.</span><span class="sxs-lookup"><span data-stu-id="eade2-144">**Security**.</span></span> <span data-ttu-id="eade2-145">Так будет проще назначить для выполнения операций записи данных только допустимые сущности домена.</span><span class="sxs-lookup"><span data-stu-id="eade2-145">It's easier to ensure that only the right domain entities are performing writes on the data.</span></span>
- <span data-ttu-id="eade2-146">**Четкое разделение зон ответственности**.</span><span class="sxs-lookup"><span data-stu-id="eade2-146">**Separation of concerns**.</span></span> <span data-ttu-id="eade2-147">Разделение процессов чтения и записи позволяет получить более гибкие и простые в обслуживании.</span><span class="sxs-lookup"><span data-stu-id="eade2-147">Segregating the read and write sides can result in models that are more maintainable and flexible.</span></span> <span data-ttu-id="eade2-148">Большая часть сложной бизнес-логики переместится в модель записи.</span><span class="sxs-lookup"><span data-stu-id="eade2-148">Most of the complex business logic goes into the write model.</span></span> <span data-ttu-id="eade2-149">Это в некоторой степени упростит модель чтения.</span><span class="sxs-lookup"><span data-stu-id="eade2-149">The read model can be relatively simple.</span></span>
- <span data-ttu-id="eade2-150">**Более простые запросы**.</span><span class="sxs-lookup"><span data-stu-id="eade2-150">**Simpler queries**.</span></span> <span data-ttu-id="eade2-151">Сохраняя в базе данных для чтения материализованное представление данных, вы предотвратите использование приложением сложных соединений в запросах.</span><span class="sxs-lookup"><span data-stu-id="eade2-151">By storing a materialized view in the read database, the application can avoid complex joins when querying.</span></span>

## <a name="challenges"></a><span data-ttu-id="eade2-152">Сложности</span><span class="sxs-lookup"><span data-stu-id="eade2-152">Challenges</span></span>

- <span data-ttu-id="eade2-153">**Сложность.**</span><span class="sxs-lookup"><span data-stu-id="eade2-153">**Complexity**.</span></span> <span data-ttu-id="eade2-154">Основная идея CQRS очень проста.</span><span class="sxs-lookup"><span data-stu-id="eade2-154">The basic idea of CQRS is simple.</span></span> <span data-ttu-id="eade2-155">Но ее реализация может привести к усложнению проекта приложения, особенно если добавить шаблон источников событий.</span><span class="sxs-lookup"><span data-stu-id="eade2-155">But it can lead to a more complex application design, especially if they include the Event Sourcing pattern.</span></span>

- <span data-ttu-id="eade2-156">**Обмен сообщениями**.</span><span class="sxs-lookup"><span data-stu-id="eade2-156">**Messaging**.</span></span> <span data-ttu-id="eade2-157">Сама по себе модель CQRS не требует обмена сообщениями, но сообщения часто применяются для обработки команд и публикации событий обновления.</span><span class="sxs-lookup"><span data-stu-id="eade2-157">Although CQRS does not require messaging, it's common to use messaging to process commands and publish update events.</span></span> <span data-ttu-id="eade2-158">Это означает, что приложению придется обрабатывать сбои и дубликаты при передаче сообщений.</span><span class="sxs-lookup"><span data-stu-id="eade2-158">In that case, the application must handle message failures or duplicate messages.</span></span>

- <span data-ttu-id="eade2-159">**Итоговая согласованность**.</span><span class="sxs-lookup"><span data-stu-id="eade2-159">**Eventual consistency**.</span></span> <span data-ttu-id="eade2-160">Если вы разделите базы данных для чтения и записи, в базе данных для чтения могут оставаться устаревшие данные.</span><span class="sxs-lookup"><span data-stu-id="eade2-160">If you separate the read and write databases, the read data may be stale.</span></span>

## <a name="best-practices"></a><span data-ttu-id="eade2-161">Рекомендации</span><span class="sxs-lookup"><span data-stu-id="eade2-161">Best practices</span></span>

- <span data-ttu-id="eade2-162">См. дополнительные сведения о [реализации CQRS][cqrs-pattern].</span><span class="sxs-lookup"><span data-stu-id="eade2-162">For more information about implementing CQRS, see the [CQRS pattern][cqrs-pattern].</span></span>

- <span data-ttu-id="eade2-163">Изучите [шаблон источников событий][event-sourcing] и рассмотрите возможность его применения для устранения конфликтов обновления.</span><span class="sxs-lookup"><span data-stu-id="eade2-163">Consider using the [Event Sourcing][event-sourcing] pattern to avoid update conflicts.</span></span>

- <span data-ttu-id="eade2-164">Изучите [шаблон материализованного представления][materialized-view], который можно применять для модели чтения, чтобы оптимизировать схему данных для обработки запросов.</span><span class="sxs-lookup"><span data-stu-id="eade2-164">Consider using the [Materialized View pattern][materialized-view] for the read model, to optimize the schema for queries.</span></span>

## <a name="cqrs-in-microservices"></a><span data-ttu-id="eade2-165">CQRS в микрослужбах</span><span class="sxs-lookup"><span data-stu-id="eade2-165">CQRS in microservices</span></span>

<span data-ttu-id="eade2-166">Модель CQRS особенно удобно использовать с [архитектурой микрослужб][microservices].</span><span class="sxs-lookup"><span data-stu-id="eade2-166">CQRS can be especially useful in a [microservices architecture][microservices].</span></span> <span data-ttu-id="eade2-167">Один из принципов микрослужб — отсутствие прямых обращений между одной службой и хранилищем данных другой службы.</span><span class="sxs-lookup"><span data-stu-id="eade2-167">One of the principles of microservices is that a service cannot directly access another service's data store.</span></span>

![Схема неправильного подхода к использованию микрослужб](./images/cqrs-microservices-wrong.png)

<span data-ttu-id="eade2-169">На следующей схеме представлены служба A, которая записывает данные в хранилище данных, и служба B, которая хранит материализованное представление данных.</span><span class="sxs-lookup"><span data-stu-id="eade2-169">In the following diagram, Service A writes to a data store, and Service B keeps a materialized view of the data.</span></span> <span data-ttu-id="eade2-170">Служба A публикует событие при каждой операции записи в хранилище данных.</span><span class="sxs-lookup"><span data-stu-id="eade2-170">Service A publishes an event whenever it writes to the data store.</span></span> <span data-ttu-id="eade2-171">Служба B подписана на эти события.</span><span class="sxs-lookup"><span data-stu-id="eade2-171">Service B subscribes to the event.</span></span>

![Схема правильного подхода к использованию микрослужб](./images/cqrs-microservices-right.png)

<!-- links -->

[cqrs-pattern]: ../../patterns/cqrs.md
[event-sourcing]: ../../patterns/event-sourcing.md
[materialized-view]: ../../patterns/materialized-view.md
[microservices]: ./microservices.md

---
title: "Стили архитектуры"
description: "Общие стили архитектуры для облачных приложений"
layout: LandingPage
ms.openlocfilehash: 15a316f9ebf7cfe4e72a6992f264a68abb904819
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/14/2017
---
# <a name="architecture-styles"></a>Стили архитектуры

*Стиль архитектуры* — это семейство архитектур, обладающих общими характеристики. Например, [n-уровневый стиль][n-tier] — это распространенный стиль архитектуры. В последнее время [архитектуры микрослужб][microservices] находятся в приоритете. Для стилей архитектуры не требуется использовать определенные технологии, но некоторые технологии хорошо подходят для некоторых архитектур. Например, контейнеры естественным образом подходят для микрослужб.  

Мы определили набор стилей архитектур, которые часто встречаются в облачных приложениях. В статье для каждого стиля содержится:

- описание и логическая схема стиля;
- рекомендации по сценариям, для которых подходит стиль;
- преимущества, сложности и рекомендации;
- рекомендуемое развертывание с использованием соответствующих служб Azure.


## <a name="a-quick-tour-of-the-styles"></a>Краткий обзор стилей   

В этом разделе приводится краткий обзор определенных нами стилей архитектуры, а также некоторые рекомендации по их использованию. См. дополнительные сведения в связанных статьях.

### <a name="n-tier"></a>n-уровневый

<img src="./images/n-tier-sketch.svg" style="float:left; margin-top:6px;"/>

**[n-уровневый][n-tier]** — это стандартная архитектура для корпоративных приложений. Управление зависимостями осуществляется путем разделения приложения на *слои*, которые выполняют логические функции, такие как представление, бизнес-логику и доступ к данным. Слой может вызывать только те слои, которые расположены под ним. Но такая горизонтальная структура может быть недостатком. Из-за этого могут возникнуть трудности с внесением изменений в одной части приложения без затрагивания остальной его части. В результате частые обновления могут стать сложной задачей, замедляя добавление новых функций.

n-уровневый стиль очень удобен для переноса имеющихся приложений, в которых уже используется многоуровневая архитектура. По этой причине n-уровневый стиль чаще всего встречается в решениях на базе инфраструктуры как услуги (IaaS) или приложениях, использующих сочетание IaaS и управляемых служб. 

### <a name="web-queue-worker"></a>Рабочая роль веб-очереди

<img src="./images/web-queue-worker-sketch.svg" style="float:left; margin-top:6px;"/>

Исключительно для решения PaaS рассмотрим архитектуру **[рабочей роли веб-очереди](./web-queue-worker.md)**. В этом стиле в приложении есть веб-интерфейс, обрабатывающий HTTP-запросы, и серверная рабочая роль, выполняющая задачи с сильной нагрузкой на ЦП или долго выполняющиеся операции. Внешний интерфейс взаимодействует с рабочей ролью через очередь асинхронных сообщений. 

Рабочая роль веб-очереди подходит для относительно простых доменов с некоторыми ресурсоемкими задачами. Как и n-уровневый стиль, эта архитектура довольно проста. Использование управляемых служб упрощает развертывание и операции. Но при использовании сложных доменов могут возникнуть трудности с управлением зависимостями. Внешний интерфейс и рабочая роль могут увеличиться и превратиться в монолитные компоненты, которые трудно обслуживать и обновлять. Как и в случае с n-уровневым стилем, это может уменьшить частоту обновлений и замедлить внедрение инноваций.

### <a name="microservices"></a>Микрослужбы

<img src="./images/microservices-sketch.svg" style="float:left; margin-top:6px;"/>

Если в приложении используется более сложный домен, следует перейти на архитектуру **[микрослужб][microservices]**. Приложение для микрослужб состоит из множества небольших независимых служб. Каждая служба реализует возможность единого бизнеса. Службы слабо связаны, а обмен данными осуществляется через контракты API.

Каждую службу может разработать небольшая сосредоточенная группа разработчиков. Отдельные службы можно развернуть без усиленной координации между командами, что способствует частым обновлениям. Архитектура микрослужб сложнее в разработке и управлении, чем n-уровневый стиль или рабочая роль веб-очереди. Для нее требуются современные средства разработки и культура разработки и операций DevOps. Но при правильном выполнении этот стиль может ускорить выпуски, внедрение инноваций и сделать архитектуру более устойчивой. 

### <a name="cqrs"></a>CQRS

<img src="./images/cqrs-sketch.svg" style="float:left; margin-top:6px;"/>

Стиль **[CQRS](./cqrs.md)** (разделение ответственности команды и запроса) разделяет операции чтения и записи в отдельные модели. Это изолирует части системы, которые используются для обновления данных из частей, считывающих данные. Более того, операции чтения можно выполнить в материализованном представлении, физически отделенном от базы данных записи. Это позволяет масштабировать рабочие нагрузки чтения и записи независимо друг от друга и оптимизировать материализованное представление для запросов.

Наиболее целесообразно применять стиль CQRS в подсистеме более широкой архитектуры. Как правило, его не следует применять для всего приложения, так как это создаст ненужные сложности. Рассмотрите его использование в доменах для совместной работы, где множество пользователей получают доступ к одним и тем же данным.

### <a name="event-driven-architecture"></a>Управляемая событиями архитектура 

<img src="./images/event-driven-sketch.svg" style="float:left; margin-top:6px;"/>

В **[управляемых событиями архитектурах](./event-driven.md)** используется модель "публикация — подписка" (pub-sub), где производители публикуют события, а потребители подписываются на них. Производители не зависят от потребителей, а потребители не зависят друг от друга. 

Управляемая событиями архитектура рекомендуется для приложений, которые получают и обрабатывают большие объемы данных с очень низкой задержкой, например решения Интернета вещей. Этот стиль также подходит, когда разные подсистемы должны выполнять различные виды обработки одних и тех же данных событий.

<br />
### <a name="big-data-big-compute"></a>Большие данные и Большие вычисления

**[Большие данные](./big-data.md)** и **[Большие вычисления](./big-compute.md)** — специализированные стили архитектуры для рабочих нагрузок, которые соответствуют определенным специфическим профилям. Большие данные разделяют очень большой набор данных на блоки, выполняя параллельную обработку во всем наборе для анализа и отчетности. Большие вычисления, также называемые высокопроизводительными вычислительными системами, выполняют параллельные вычисления в большом числе ядер (тысячах). Домены включают имитацию, моделирование и трехмерную отрисовку.

## <a name="architecture-styles-as-constraints"></a>Стили архитектуры в качестве ограничений

Стиль архитектуры накладывает ограничения на проектирование, включая набор элементов, которые могут присутствовать, и разрешенные связи между этими элементами. Ограничения определяют "форму" архитектуры, отсеивая множество вариантов. Когда архитектура соответствует ограничениям определенного стиля, появляются некоторые необходимые свойства. 

Например, к ограничениям в микрослужбах относятся: 

- Служба представляет персональную ответственность. 
- Все службы не зависят от друг от друга. 
- Данные являются личными данными службы, которой они принадлежат. Службы не используют данные совместно.

При соблюдении этих ограничений создается система, в которой службы можно развертывать независимо друг от друга, ошибки изолированы, возможны частые обновления и легко внедрять новые технологии в приложение.

Прежде чем выбрать стиль архитектуры, убедитесь, что вы понимаете базовые принципы и ограничения этого стиля. В противном случае хоть и удастся разработать архитектуру, которая соответствует стилю на поверхностном уровне, воспользоваться всеми возможностями этого стиля будет невозможно. Кроме того, важно быть прагматичным. Иногда лучше немного отойти от ограничений, чем настаивать на полном соответствии им архитектуры.


В следующей таблице представлены сведения о том, как каждый стиль управляет зависимостями, и типы домена, которые наилучшим образом подходят для каждого из них.

| Стиль архитектуры |  Управление зависимостями | Тип домена |
|--------------------|------------------------|-------------|
| n-уровневый | Горизонтальные уровни, разделенные подсетью. | Традиционный домен для бизнеса. Частота обновления не высокая. |
| Рабочая роль веб-очереди | Интерфейсные и серверные задания, разделенные асинхронным обменом сообщениями. | Относительно простой домен с ресурсоемкими задачами. |
| Микрослужбы | Вертикально (функционально) разделенные службы, вызывающие друг друга через API-интерфейсы. | Сложный домен. Частые обновления. |
| CQRS | Разделение операций чтения и записи. Схема и масштаб оптимизированы отдельно. | Домен для совместной работы, где большое количество пользователей получают доступ к одним и тем же данным. |
| Управляемая событиями архитектура. | Производитель и потребитель. Независимое представление для каждой подсистемы. | Интернет вещей и системы, работающие в режиме реального времени |
| Данные большого размера | Разделение большого набора данных на мелкие блоки. Параллельная обработка для локальных наборов данных. | Пакетная обработка и анализ данных в режиме реального времени. Прогнозная аналитика с использованием машинного обучения. |
| Большие вычисления| Распределение данных в тысячах ядер. | Домены с ресурсоемкими вычислениями, например моделированием. |


## <a name="consider-challenges-and-benefits"></a>Сложности и преимущества

Ограничения также создают трудности, поэтому важно узнать о недостатках при внедрении любого из этих стилей. Преимущества стиля архитектуры перевешивают трудности *для этого дочернего домена и ограниченного контекста*. 

Ниже приведены некоторые типы трудностей, которые следует учитывать при выборе стиля архитектуры.

- **Сложность**. Обоснована ли сложность архитектуры для вашего домена? И наоборот, не слишком ли стиль прост для вашего домена? В этом случае вы рискуете получить [систему с нераспознаваемой структурой][ball-of-mud], так как архитектура не позволит правильно управлять зависимостями.

- **Асинхронный обмен сообщениями и итоговая согласованность**. Асинхронный обмен сообщениями может использоваться для разделения служб и повысить надежность (так как сообщения могут отсылаться повторно) и масштабируемость. Но это также создает трудности с семантикой и итоговой согласованностью.

- **Взаимодействие между службами**. Так как приложение можно разбить на отдельные службы, есть риск, что обмен данными между службами приведет к неприемлемому уровню задержек или перегрузке сети (например, в архитектуре микрослужб). 

- **Управляемость**. Насколько тяжело управлять приложением, выполнять мониторинг, развертывать обновления и т. д.?


[ball-of-mud]: https://en.wikipedia.org/wiki/Big_ball_of_mud
[microservices]: ./microservices.md
[n-tier]: ./n-tier.md
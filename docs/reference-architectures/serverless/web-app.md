---
title: Бессерверное веб-приложение
titleSuffix: Azure Reference Architectures
description: Рекомендуемая архитектура для бессерверного веб-приложения и веб-API.
author: MikeWasson
ms.date: 10/16/2018
ms.topic: reference-architecture
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: seodec18, serverless
ms.openlocfilehash: 60af3df5bbb75d97d6ba797874c8b37319b2fad5
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/23/2019
ms.locfileid: "54487395"
---
# <a name="serverless-web-application-on-azure"></a>Бессерверное веб-приложение в Azure

Эталонная архитектура, которая демонстрирует [бессерверное](https://azure.microsoft.com/solutions/serverless/) веб-приложение. Приложение передает статическое содержимое из хранилища BLOB-объектов Azure, а также реализует программный интерфейс с помощью Функций Azure. API считывает данные из Cosmos DB и возвращает результаты в веб-приложение. Эталонную реализацию для этой архитектуры можно найти на сайте [GitHub][github].

![Эталонная архитектура для бессерверного веб-приложения](./_images/serverless-web-app.png)

Термин "бессерверный" может иметь два различных значения, которые тем не менее связаны между собой:

- **Серверная часть как услуга** (BaaS). Серверные облачные службы, такие как базы данных и хранилища, предоставляют программные интерфейсы, которые позволяют клиентским приложениям напрямую подключаться к этим службам.
- **Функции как услуга** (FaaS). В этой модели "функция" представляет собой фрагмент кода, который развертывается в облаке и выполняется в среде узла, которая полностью абстрагирует серверы, на которых запускается код.

Оба определения подразумевают общую идею о том, что разработчикам и персоналу DevOps не нужно развертывать, настраивать или администрировать серверы. Эта эталонная архитектура фокусируется на FaaS с использованием Функций Azure, хотя обслуживание веб-содержимого из хранилища BLOB-объектов Azure является примером BaaS. Ниже приведены некоторые важные характеристики FaaS:

1. Вычислительные ресурсы динамически распределяются платформой по мере необходимости.
1. Тарификация на основе использования: вы платите только за вычислительные ресурсы, которые используются для выполнения кода.
1. Вычислительные ресурсы масштабируются по запросу на основе трафика, и разработчику при этом не нужно выполнять какую-либо конфигурацию.

Функции выполняются при возникновении внешнего триггера, например HTTP-запроса или сообщения, поступающего в очередь. Благодаря этому [тип управляемой событиями архитектуры][event-driven] является естественным для бессерверных архитектур. Чтобы координировать работу между компонентами в архитектуре, рассмотрите возможность использования брокеров сообщений или шаблонов публикаций и подписок. Дополнительные сведения о технологиях обмена сообщениями Azure см. в статье [Выбор между службами обмена сообщениями Azure][azure-messaging].

## <a name="architecture"></a>Архитектура

Она состоит из следующих компонентов:

**Хранилище больших двоичных объектов**. Статическое веб-содержимое, такое как файлы HTML, CSS и JavaScript, сохраняется в хранилище BLOB-объектов Azure и обслуживается клиентами с помощью [размещения статических веб-сайтов][static-hosting]. Все динамическое взаимодействие происходит с помощью кода JavaScript, который вызывает API серверной части. Для отображения веб-страницы не используется серверный код. Размещение статических веб-сайтов поддерживает индексированные документы и настраиваемые страницы ошибок 404.

> [!NOTE]
> Размещение статических веб-сайтов в данный момент предоставляется в [предварительной версии][static-hosting-preview].

**CDN.** Используйте [сеть доставки содержимого Azure][cdn] (CDN), чтобы выполнять кэширование содержимого с меньшей задержкой и более быстрой доставкой, а также предоставлением конечной точки HTTPS.

**Приложения-функции**. [Функции Azure][functions] — это независимая от сервера служба вычислений. Она использует управляемую событиями модель, где часть кода ("функция") вызывается триггером. В этой архитектуре функция вызывается, когда клиент делает HTTP-запрос. Запрос всегда маршрутизируется через шлюз API, описанный ниже.

**Служба управления API**. [Управление API][apim] предоставляет шлюз API, который находится перед функцией HTTP. Службу управления API можно использовать для публикации программных интерфейсов, используемых клиентскими приложениями, а также для управления ими. Использование шлюза помогает отделить внешнее приложение от серверных API. Например, служба управления API может переписывать URL-адреса, преобразовывать запросы до того, как они попадут на сервер, задавать заголовки запросов или ответов и так далее.

Управление API также может использоваться для реализации сквозных задач, таких как:

- Принудительное применение квот потребления и ограничений скорости.
- Проверка токенов OAuth для аутентификации.
- Включение запросов независимо от источника (CORS).
- Кэширование ответов.
- Мониторинг и ведение журнала запросов.

Если вам не нужны все функциональные возможности, предоставляемые службой управления API, можно использовать [прокси-серверы Функций][functions-proxy]. Эта возможность Функций Azure позволяет вам определять единую поверхность API для нескольких приложений-функций, создавая маршруты к серверным функциям. Прокси-серверы Функций также могут выполнять ограниченные преобразования запросов и ответов HTTP. Тем не менее они не обеспечивают те же расширенные функциональные возможности управления API на основе политик.

**Cosmos DB**. [Azure Cosmos DB][cosmosdb] — это служба многомодельной базы данных. Для этого сценария приложение-функция извлекает документы из Cosmos DB в ответ на запросы HTTP GET от клиента.

**Azure Active Directory** (Azure AD). Пользователи входят в веб-приложение, используя свои учетные данные Azure AD. Azure AD возвращает маркер доступа для API, используемый веб-приложением для проверки подлинности запросов API (см. раздел [Проверка подлинности](#authentication)).

**Azure Monitor**. [Monitor][monitor] собирает метрики производительности о службах Azure, развернутых в решении. Отобразив эти данные в визуализации на панели мониторинга, можно получить сведения о работоспособности решения. Monitor также собирает журналы приложений.

**Azure Pipelines**. [Pipelines][pipelines] — это служба непрерывной интеграции (CI) и непрерывной поставки (CD), которая выполняет сборку, тестирование и развертывание приложений.

## <a name="recommendations"></a>Рекомендации

### <a name="function-app-plans"></a>Планы приложения-функции

Функции Azure поддерживают две модели размещения. **План потребления** автоматически выделяет вычислительную мощность при выполнении кода.  В плане **службы приложений** для кода выделяется набор виртуальных машин. План службы приложений определяет число и размер виртуальных машин.

Обратите внимание, что план службы приложений не является *бессерверным* в соответствии с определением, указанным выше. Модель программирования одна и та же, однако тот же код функции может выполняться как в плане потребления, так и в плане службы приложений.

Ниже приведены некоторые факторы, которые следует учитывать при выборе подходящего плана для использования.

- **Холодный запуск**. В плане потребления функция, которая не вызывалась недавно, в следующий раз будет вызвана с дополнительной задержкой. Эта дополнительная задержка обусловлена ​​распределением и подготовкой среды выполнения. Обычно это занимает несколько секунд, но зависит от нескольких факторов, в том числе от количества зависимостей, которые необходимо загрузить. Дополнительные сведения см. в статье о [холодном запуске в бессерверной архитектуре][functions-cold-start]. Холодный запуск обычно больше относится к интерактивным (HTTP-триггеры), чем к асинхронным рабочим нагрузкам, связанным с сообщениями (триггеры очереди или концентраторов событий), потому что дополнительная задержка наблюдается непосредственно пользователями.
- **Период времени ожидания**.  В плане потребления функция должна выполняться в течение [настроенного][functions-timeout] времени ожидания (максимум до 10 минут).
- **Изоляция виртуальной сети**. Использование плана службы приложений позволяет выполнять функции внутри [среды службы приложений][ase], которая представляет собой выделенную и изолированную среду размещения.
- **Модель ценообразования**. В плане потребления счета выставляются по количеству выполнений и потреблению ресурсов (память &times; время выполнения). В плане службы приложений счета выставляются ежечасно на основе номера SKU экземпляра виртуальной машины. Часто план потребления может быть дешевле, чем план службы приложений, так как вы платите только за те ресурсы вычислений, которые используете. Это особенно верно в случаях, если в трафике наблюдаются пики и спады. Однако если в приложении наблюдается постоянная высокая пропускная способность, план службы приложений может стоить меньше, чем план потребления.
- **Масштабирование**. Большим преимуществом модели потребления является то, что она масштабируется динамически по мере необходимости в зависимости от входящего трафика. Хотя это масштабирование происходит быстро, есть еще период постепенного повышения производительности. Для некоторых рабочих нагрузок может потребоваться намеренная избыточная подготовка виртуальных машин, чтобы можно было обрабатывать всплески трафика без периода нарастания. В этом случае используйте план службы приложений.

### <a name="function-app-boundaries"></a>Границы приложения-функции

*Приложение-функция* выполняет одну или несколько *функций*. Приложение-функцию можно использовать для группирования нескольких функций в виде логической единицы. Эти функции совместно используют одни и те же параметры приложения, план размещения и жизненный цикл развертывания. Каждое приложение-функция имеет собственное имя узла.

Используйте приложения-функции для группирования функций с одинаковыми жизненным циклом и параметрами. Функции с разным жизненным циклом должны размещаться в различных приложениях-функциях.

Рассмотрите подход с микрослужбами, где каждое приложение-функция представляет одну микрослужбу, которая может состоять из нескольких связанных функций. В архитектуре микрослужб службы должны иметь слабую взаимозависимость и высокую функциональную слаженность. *Слабая взаимозависимость* означает, что вы можете изменить одну службу без необходимости одновременного обновления других служб. *Слаженность* означает, что служба имеет единую четко определенную цель. Более подробное описание этих идей см. в статье [Проектирование микрослужб: анализ предметной области][microservices-domain-analysis].

### <a name="function-bindings"></a>Привязки функций

Используйте [привязки][functions-bindings] функций, когда это возможно. Привязки предоставляют декларативный способ подключения кода к данным и интеграцию с другими службами Azure. Входная привязка заполняет входной параметр из внешнего источника данных. Выходная привязка отправляет возвращаемое значение функции в приемник данных, например в очередь или базу данных.

Предположим, что функция `GetStatus` в эталонной реализации использует [входную привязку][cosmosdb-input-binding] Cosmos DB. Эта привязка настроена для поиска документов в Cosmos DB с помощью параметров запроса, которые берутся из строки в HTTP-запросе. Если документ найден, он передается в функцию как параметр.

```csharp
[FunctionName("GetStatusFunction")]
public static Task<IActionResult> Run(
    [HttpTrigger(AuthorizationLevel.Function, "get", Route = null)] HttpRequest req,
    [CosmosDB(
        databaseName: "%COSMOSDB_DATABASE_NAME%",
        collectionName: "%COSMOSDB_DATABASE_COL%",
        ConnectionStringSetting = "COSMOSDB_CONNECTION_STRING",
        Id = "{Query.deviceId}",
        PartitionKey = "{Query.deviceId}")] dynamic deviceStatus,
    ILogger log)
{
    ...
}
```

При использовании привязок не требуется писать код, который напрямую обращается к службе. Таким образом, код функции упрощается, а сведения об источнике или приемнике данных абстрагируются. Однако в некоторых случаях может потребоваться более сложная логика, чем та, которую обеспечивает привязка. В этом случае используйте клиентские пакеты SDK Azure напрямую.

## <a name="scalability-considerations"></a>Вопросы масштабируемости

**Функции**. Для плана потребления HTTP-триггер масштабируется на основе трафика. Существует ограничение на количество параллельных экземпляров функций, но каждый экземпляр может обрабатывать несколько запросов одновременно. Для плана службы приложений HTTP-триггер масштабируется в соответствии с количеством экземпляров виртуальных машин, которое может быть фиксированным значением или автоматически изменяться на основе набора правил автомасштабирования. Дополнительные сведения см. в статье [Масштабирование и размещение Функций Azure][functions-scale].

**Cosmos DB**. Пропускная способность для Cosmos DB измеряется в [единицах запроса][ru] (ЕЗ). Одна единица запроса соответствует пропускной способности операций GET, выполняемых для документа объемом 1 КБ. Чтобы масштабировать контейнер Cosmos DB на более чем 10 000 единиц запросов, необходимо указать [ключ секции][partition-key] при создании контейнера и добавить этот ключ в каждый создаваемый документ. Дополнительные сведения о ключах секций см. в статье [Секционирование и масштабирование в Azure Cosmos DB][cosmosdb-scale].

**Служба управления API**. Управление API может масштабироваться и поддерживает автоматическое масштабирование на основе правил. Обратите внимание, что процесс масштабирования занимает не менее 20 минут. Если ваш трафик прерывистый, следует подготовиться к максимальному всплеску трафика, который вы ожидаете. Однако автоматическое масштабирование полезно для обработки почасовых или ежедневных колебаний трафика. Дополнительные сведения см. в статье [Автоматическое масштабирование экземпляра службы управления API Azure][apim-scale].

## <a name="disaster-recovery-considerations"></a>Рекомендации по аварийному восстановлению

Представленное здесь развертывание расположено в одном регионе Azure. Для более гибкого подхода к аварийному восстановлению воспользуйтесь функциями геораспределения в различных службах:

- Служба управления API поддерживает развертывание в нескольких регионах, что позволяет распространять единый экземпляр службы управления API в любом количестве регионов Azure. Дополнительные сведения см. в статье [Развертывание экземпляра службы управления Azure API в различных регионах Azure][api-geo].

- Используйте [диспетчер трафика][tm], чтобы направлять HTTP-запросы в основной регион. Если приложение-функция, работающее в этом регионе, становится недоступным, диспетчер трафика выполняет отработку отказа в дополнительный регион.

- Cosmos DB поддерживает [несколько основных регионов][cosmosdb-geo], что позволяет записывать данные в любой регион, добавляемый в учетную запись Cosmos DB. Если не включить несколько источников, можно по-прежнему выполнить отработку отказа в основной регион записи. Клиентские пакеты SDK для Cosmos DB и привязки Функций Azure автоматически выполняют отработку отказа, поэтому нет необходимости обновлять параметры конфигурации приложения.

## <a name="security-considerations"></a>Вопросы безопасности

### <a name="authentication"></a>Authentication

API `GetStatus` в эталонной реализации использует Azure AD для аутентификации запросов. Azure AD поддерживает Open ID Connect, который является протоколом аутентификации на основе протокола OAuth 2.

В этой архитектуре клиентское приложение представляет собой одностраничное приложение (SPA), которое запускается в браузере. Этот тип клиентского приложения не может хранить секрет клиента или код авторизации скрытым, поэтому следует использовать поток неявного предоставления разрешений. (См. сведения об [использовании потока OAuth 2.0][oauth-flow]). Вот общая последовательность действий:

1. Пользователь щелкает ссылку "Войти" в веб-приложении.
1. Браузер перенаправляется на страницу входа Azure AD.
1. Пользователь входит в систему.
1. Azure AD выполняет перенаправление обратно в клиентское приложение, добавляя маркер доступа во фрагменте URL-адреса.
1. Когда веб-приложение вызывает API, оно добавляет маркер доступа в заголовок аутентификации. Идентификатор приложения отправляется в качестве утверждения целевой аудитории (aud) в маркере доступа.
1. API серверной части проверяет маркер доступа.

Чтобы настроить аутентификацию:

- Зарегистрируйте приложение в клиенте Azure AD. При этом создается идентификатор приложения, который клиент добавляет в URL-адрес входа.

- Включите проверку подлинности Azure AD в приложении-функции. Дополнительные сведения см. в статье [Проверка подлинности и авторизация в Службе приложений Azure][app-service-auth].

- Добавьте [политику validate-jw][apim-validate-jwt] в службу управления API, чтобы предварительно авторизовать запрос, проверив маркер доступа.

Дополнительные сведения см. в [файле сведений на сайте GitHub][readme].

Рекомендуется создать отдельные регистрации приложений в Azure AD для клиентского приложения и API серверной части. Предоставьте клиентскому приложению разрешение вызывать веб-API. Этот подход позволяет определить несколько API и клиентов, а также управлять разрешениями для каждого из них.

В API используйте [области][scopes], чтобы приложение могло управлять разрешениями, которые оно запрашивает у пользователя. Например, API может использовать области `Read` и `Write`, а определенное клиентское приложение может запросить у пользователя авторизовать только разрешения `Read`.

### <a name="authorization"></a>Авторизация

Во многих приложениях API серверной части должен проверять, имеет ли пользователь разрешение на выполнение заданного действия. Рекомендуется использовать [авторизацию на основе утверждений][claims], где информация о пользователе передается поставщиком удостоверений (в данном случае Azure AD) и используется для принятия решений об авторизации.

Некоторые утверждения предоставляются внутри маркера идентификатора, который Azure AD возвращает клиенту. Эти утверждения можно получить из приложения-функции, изучив заголовок X-MS-CLIENT-PRINCIPAL в запросе. Для других утверждений используйте [Microsoft Graph][graph], чтобы отправить запрос в Azure AD (требуется согласие пользователя во время входа).

Например, при регистрации приложения в Azure AD можно определить набор ролей приложения в манифесте регистрации приложения. Когда пользователь входит в приложение, Azure AD добавляет утверждение roles для каждой роли, предоставленной пользователю (включая роли, унаследованные через членство в группах).

В эталонной реализации функция проверяет, является ли аутентифицированный пользователь членом роли приложения `GetStatus`. В противном случае функция возвращает неавторизованный ответ (401) HTTP.

```csharp
[FunctionName("GetStatusFunction")]
public static Task<IActionResult> Run(
    [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,
    [CosmosDB(
        databaseName: "%COSMOSDB_DATABASE_NAME%",
        collectionName: "%COSMOSDB_DATABASE_COL%",
        ConnectionStringSetting = "COSMOSDB_CONNECTION_STRING",
        Id = "{Query.deviceId}",
        PartitionKey = "{Query.deviceId}")] dynamic deviceStatus,
    ILogger log)
{
    log.LogInformation("Processing GetStatus request.");

    return req.HandleIfAuthorizedForRoles(new[] { GetDeviceStatusRoleName },
        async () =>
        {
            string deviceId = req.Query["deviceId"];
            if (deviceId == null)
            {
                return new BadRequestObjectResult("Missing DeviceId");
            }

            return await Task.FromResult<IActionResult>(deviceStatus != null
                    ? (ActionResult)new OkObjectResult(deviceStatus)
                    : new NotFoundResult());
        },
        log);
}
```

В этом примере кода `HandleIfAuthorizedForRoles` является методом расширения, который проверяет наличие утверждения роли и возвращает ответ HTTP 401, если утверждение не найдено. Исходный код можно найти [здесь][HttpRequestAuthorizationExtensions]. Обратите внимание, что `HandleIfAuthorizedForRoles` принимает параметр `ILogger`. Необходимо регистрировать неавторизованные запросы, чтобы иметь аудиторский след и при необходимости диагностировать проблемы. В то же время избегайте утечки подробной информации в ответе HTTP 401.

### <a name="cors"></a>CORS

В этой эталонной архитектуре веб-приложение и API не имеют общего источника. Это означает, что когда приложение вызывает API, это запрос CORS. Параметры безопасности веб-браузера предотвращают отправку запросов AJAX с веб-страницы к другому домену. Такое ограничение называется *политикой одного источника*. Эта политика предотвращает чтение вредоносным сайтом конфиденциальных данных с другого сайта. Чтобы включить запрос общего доступа к ресурсам независимо от источника, добавьте [политику][cors-policy] CORS в шлюз службы управления API:

```xml
<cors allow-credentials="true">
    <allowed-origins>
        <origin>[Website URL]</origin>
    </allowed-origins>
    <allowed-methods>
        <method>GET</method>
    </allowed-methods>
    <allowed-headers>
        <header>*</header>
    </allowed-headers>
</cors>
```

В этом примере атрибут **allow-credentials** имеет значение **true**. Это позволяет браузеру отправлять учетные данные (включая файлы cookie) с запросом. По умолчанию браузер не отправляет учетные данные с запросом CORS.

> [!NOTE]
> Будьте очень осторожны, устанавливая для **allow-credentials** значение **true**. Это означает, что веб-сайт может отправлять учетные данные пользователя в ваш API от имени пользователя без его ведома. Вы должны доверять разрешенному источнику.

### <a name="enforce-https"></a>Принудительное использование HTTPS

Для обеспечения максимальной безопасности требуйте использования HTTPS в конвейере запросов:

- **CDN.** По умолчанию Azure CDN поддерживает HTTPS в поддомене `*.azureedge.net`. Чтобы включить HTTPS в CDN для имен личных доменов, см. [руководство по настройке протокола HTTPS для личного домена в сети доставки содержимого Azure][cdn-https].

- **Размещение статического веб-сайта**. Включите параметр [Требуется безопасное перемещение][storage-https] в учетной записи хранения. Если этот параметр включен, учетная запись хранения разрешает запросы только с защищенных подключений HTTPS.

- **Служба управления API**. Настройте программные интерфейсы для использования только протокола HTTPS. Это можно настроить на портале Azure или с помощью шаблона Resource Manager.

    ```json
    {
        "apiVersion": "2018-01-01",
        "type": "apis",
        "name": "dronedeliveryapi",
        "dependsOn": [
            "[concat('Microsoft.ApiManagement/service/', variables('apiManagementServiceName'))]"
        ],
        "properties": {
            "displayName": "Drone Delivery API",
            "description": "Drone Delivery API",
            "path": "api",
            "protocols": [ "HTTPS" ]
        },
        ...
    }
    ```

- **Функции Azure**. Включите параметр [Только HTTPS][functions-https].

### <a name="lock-down-the-function-app"></a>Блокировка приложения-функции

Все вызовы функции должны проходить через шлюз API. Этого можно достичь следующим образом:

- Настройте в приложении-функции требование ключа функции. Шлюз службы управления API будет включать ключ функции при вызове приложения-функции. Это не позволяет клиентам вызывать функцию напрямую, минуя шлюз.

- Шлюз службы управления API имеет [статический IP-адрес][apim-ip]. Ограничьте функцию Azure, чтобы разрешить вызовы только с этого статического IP-адреса. Дополнительные сведения см. в статье [Ограничения статических IP-адресов в Службе приложений Azure][app-service-ip-restrictions]. (Эта функция доступна только для служб ценовой категории "Стандартный".)

### <a name="protect-application-secrets"></a>Защита секретов приложения

Не храните секреты приложений, такие как учетные данные базы данных, в файлах кода или конфигурации. Вместо этого используйте параметры приложения, которые хранятся в зашифрованном виде в Azure. Дополнительные сведения см. в статье [Безопасность в Службе приложений Azure и службе "Функции Azure"][app-service-security].

Кроме того, можно хранить секреты приложения в хранилище Key Vault. Это позволяет централизовать хранение секретов, контролировать их распределение и отслеживать, как и когда осуществляется доступ к ним. Дополнительные сведения см. в статье [Руководство по настройке веб-приложения Azure для считывания секрета из Key Vault][key-vault-web-app]. Однако обратите внимание, что триггеры и привязки функций загружают параметры конфигурации из параметров приложения. Не существует встроенного способа настройки триггеров и привязок для использования секретов Key Vault.

## <a name="devops-considerations"></a>Рекомендации для DevOps

### <a name="deployment"></a>Развертывание

Чтобы развернуть приложение-функцию, мы рекомендуем использовать [файлы пакетов][functions-run-from-package] (команда "Запуск из пакета"). В рамках этого подхода вы загружаете ZIP-файл в контейнер хранилища BLOB-объектов, а среда выполнения Функций подключает ZIP-файл как файловую систему только для чтения. Так как это атомарная операция, вероятность того, что в случае сбоя при развертывании приложение останется в несогласованном состоянии, является низкой. Это также позволяет ускорить холодный запуск, особенно для приложений Node.js, так как все файлы меняются одновременно.

### <a name="api-versioning"></a>Управление версиями API

API — это контракт между службой и клиентами. В этой архитектуре контракт API определяется на уровне службы управления API. Служба управления API поддерживает две разные, но взаимодополняющие [концепции присвоения версий][apim-versioning]:

- *Версии* позволяют объектам-получателям выбрать версию API в зависимости от потребностей, например версию 1 или 2.

- *Редакции* позволяют администраторам API вносить в API обратно совместимые изменения и развертывать их вместе с журналом изменений, который содержит сведения об изменениях для объектов-получателей.

Если вы вносите критические изменения в API, опубликуйте новую версию в службе управления API. Разверните новую версию параллельно с исходной версией в отдельном приложении-функции. Это позволяет перенести существующих клиентов в новый API без нарушения клиентских приложений. В конце концов, вы сможете прекратить поддержку предыдущей версии. Служба "Управление API" поддерживает несколько [схем управления версиями][apim-versioning-schemes]: URL-путь, заголовок HTTP и строка запроса. См. дополнительные сведения об [управлении версиями веб-API RESTful][api-versioning].

Для обновлений, не нарушающих изменения API, разверните новую версию в промежуточном слоте в том же приложении-функции. Убедитесь, что развертывание выполнено успешно, а затем замените промежуточную версию рабочей. Опубликуйте версию в службе управления API.

## <a name="deploy-the-solution"></a>Развертывание решения

Чтобы развернуть эту эталонную архитектуру, просмотрите [файл сведений на GitHub][readme].

<!-- links -->

[api-versioning]: ../../best-practices/api-design.md#versioning-a-restful-web-api
[apim]: /azure/api-management/api-management-key-concepts
[apim-ip]: /azure/api-management/api-management-faq#is-the-api-management-gateway-ip-address-constant-can-i-use-it-in-firewall-rules
[api-geo]: /azure/api-management/api-management-howto-deploy-multi-region
[apim-scale]: /azure/api-management/api-management-howto-autoscale
[apim-validate-jwt]: /azure/api-management/api-management-access-restriction-policies#ValidateJWT
[apim-versioning]: /azure/api-management/api-management-get-started-publish-versions
[apim-versioning-schemes]: /azure/api-management/api-management-get-started-publish-versions#choose-a-versioning-scheme
[app-service-auth]: /azure/app-service/app-service-authentication-overview
[app-service-ip-restrictions]: /azure/app-service/app-service-ip-restrictions
[app-service-security]: /azure/app-service/app-service-security
[ase]: /azure/app-service/environment/intro
[azure-messaging]: /azure/event-grid/compare-messaging-services
[claims]: https://en.wikipedia.org/wiki/Claims-based_identity
[cdn]: https://azure.microsoft.com/services/cdn/
[cdn-https]: /azure/cdn/cdn-custom-ssl
[cors-policy]: /azure/api-management/api-management-cross-domain-policies
[cosmosdb]: /azure/cosmos-db/introduction
[cosmosdb-geo]: /azure/cosmos-db/distribute-data-globally
[cosmosdb-input-binding]: /azure/azure-functions/functions-bindings-cosmosdb-v2#input
[cosmosdb-scale]: /azure/cosmos-db/partition-data
[event-driven]: ../../guide/architecture-styles/event-driven.md
[functions]: /azure/azure-functions/functions-overview
[functions-bindings]: /azure/azure-functions/functions-triggers-bindings
[functions-cold-start]: https://blogs.msdn.microsoft.com/appserviceteam/2018/02/07/understanding-serverless-cold-start/
[functions-https]: /azure/app-service/app-service-web-tutorial-custom-ssl#enforce-https
[functions-proxy]: /azure/azure-functions/functions-proxies
[functions-run-from-package]: /azure/azure-functions/run-functions-from-deployment-package
[functions-scale]: /azure/azure-functions/functions-scale
[functions-timeout]: /azure/azure-functions/functions-scale#consumption-plan
[functions-zip-deploy]: /azure/azure-functions/deployment-zip-push
[graph]: https://developer.microsoft.com/graph/docs/concepts/overview
[key-vault-web-app]: /azure/key-vault/tutorial-web-application-keyvault
[microservices-domain-analysis]: ../../microservices/domain-analysis.md
[monitor]: /azure/azure-monitor/overview
[oauth-flow]: https://auth0.com/docs/api-auth/which-oauth-flow-to-use
[partition-key]: /azure/cosmos-db/partition-data
[pipelines]: /azure/devops/pipelines/index
[ru]: /azure/cosmos-db/request-units
[scopes]: /azure/active-directory/develop/v2-permissions-and-consent
[static-hosting]: /azure/storage/blobs/storage-blob-static-website
[static-hosting-preview]: https://azure.microsoft.com/blog/azure-storage-static-web-hosting-public-preview/
[storage-https]: /azure/storage/common/storage-require-secure-transfer
[tm]: /azure/traffic-manager/traffic-manager-overview

[github]: https://github.com/mspnp/serverless-reference-implementation
[HttpRequestAuthorizationExtensions]: https://github.com/mspnp/serverless-reference-implementation/blob/master/src/DroneStatus/dotnet/DroneStatusFunctionApp/HttpRequestAuthorizationExtensions.cs
[readme]: https://github.com/mspnp/serverless-reference-implementation/blob/master/README.md

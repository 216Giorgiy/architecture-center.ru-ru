---
title: Обмен данными между микрослужбами
description: Обмен данными между микрослужбами
author: MikeWasson
ms.date: 10/23/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: 7b1a5d7d6d386f707ff0842c08ff342dc5a1bbbd
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/23/2019
ms.locfileid: "54480646"
---
# <a name="designing-microservices-interservice-communication"></a><span data-ttu-id="a3675-103">Проектирование микрослужб. Обмен данными между службами</span><span class="sxs-lookup"><span data-stu-id="a3675-103">Designing microservices: Interservice communication</span></span>

<span data-ttu-id="a3675-104">Обмен данными между микрослужбами должен быть эффективным и надежным.</span><span class="sxs-lookup"><span data-stu-id="a3675-104">Communication between microservices must be efficient and robust.</span></span> <span data-ttu-id="a3675-105">При взаимодействии большого количества небольших служб для выполнения одной транзакции это может оказаться сложной задачей.</span><span class="sxs-lookup"><span data-stu-id="a3675-105">With lots of small services interacting to complete a single transaction, this can be a challenge.</span></span> <span data-ttu-id="a3675-106">В этой главе мы рассмотрим компромиссы между асинхронным обменом сообщениями и синхронными API-интерфейсами.</span><span class="sxs-lookup"><span data-stu-id="a3675-106">In this chapter, we look at the tradeoffs between asynchronous messaging versus synchronous APIs.</span></span> <span data-ttu-id="a3675-107">Затем мы рассмотрим некоторые из проблем, возникающих при разработке устойчивого обмена данными между службами, и роль, которую может играть слой взаимодействия между службами.</span><span class="sxs-lookup"><span data-stu-id="a3675-107">Then we look at some of the challenges in designing resilient interservice communication, and the role that a service mesh can play.</span></span>

![Схема обмена данными между службами](./images/interservice-communication.png)

## <a name="challenges"></a><span data-ttu-id="a3675-109">Сложности</span><span class="sxs-lookup"><span data-stu-id="a3675-109">Challenges</span></span>

<span data-ttu-id="a3675-110">Вот некоторые из основных проблем, возникающих при обмене данными между службами.</span><span class="sxs-lookup"><span data-stu-id="a3675-110">Here are some of the main challenges arising from service-to-service communication.</span></span> <span data-ttu-id="a3675-111">Слои взаимодействия между службами, описанные далее в этой главе, предназначены для решения многих из этих задач.</span><span class="sxs-lookup"><span data-stu-id="a3675-111">Service meshes, described later in this chapter, are designed to handle many of these challenges.</span></span>

<span data-ttu-id="a3675-112">**Устойчивость.**</span><span class="sxs-lookup"><span data-stu-id="a3675-112">**Resiliency**.</span></span> <span data-ttu-id="a3675-113">Могут существовать десятки и даже сотни экземпляров любой определенной микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="a3675-113">There may be dozens or even hundreds of instances of any given microservice.</span></span> <span data-ttu-id="a3675-114">Экземпляр может завершиться ошибкой по ряду причин.</span><span class="sxs-lookup"><span data-stu-id="a3675-114">An instance can fail for any number of reasons.</span></span> <span data-ttu-id="a3675-115">Может произойти сбой на уровне узла, например сбой оборудования или перезагрузка виртуальной машины.</span><span class="sxs-lookup"><span data-stu-id="a3675-115">There can be a node-level failure, such as a hardware failure or a VM reboot.</span></span> <span data-ttu-id="a3675-116">Экземпляр может аварийно завершить работу либо быть перегружен запросами, не имея возможности обрабатывать новые запросы.</span><span class="sxs-lookup"><span data-stu-id="a3675-116">An instance might crash, or be overwhelmed with requests and unable to process any new requests.</span></span> <span data-ttu-id="a3675-117">Любое из этих событий может вызвать сбой сетевого вызова.</span><span class="sxs-lookup"><span data-stu-id="a3675-117">Any of these events can cause a network call to fail.</span></span> <span data-ttu-id="a3675-118">Существует два конструктивных шаблона, которые могут повысить устойчивость сетевых вызовов между службами.</span><span class="sxs-lookup"><span data-stu-id="a3675-118">There are two design patterns that can help make service-to-service network calls more resilient:</span></span>

- <span data-ttu-id="a3675-119">**[Повторные попытки](../patterns/retry.md)**.</span><span class="sxs-lookup"><span data-stu-id="a3675-119">**[Retry](../patterns/retry.md)**.</span></span> <span data-ttu-id="a3675-120">Сетевой вызов может завершиться сбоем из-за временной ошибки, которая исчезает сама по себе.</span><span class="sxs-lookup"><span data-stu-id="a3675-120">A network call may fail because of a transient fault that goes away by itself.</span></span> <span data-ttu-id="a3675-121">Вместо завершения вызова вызывающий объект обычно повторяет операцию несколько раз или до тех пор, пока не истечет настроенный период времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="a3675-121">Rather than fail outright, the caller should typically retry the operation a certain number of times, or until a configured time-out period elapses.</span></span> <span data-ttu-id="a3675-122">Тем не менее, если операция не является идемпотентной, повторные попытки могут вызвать непредвиденные побочные эффекты.</span><span class="sxs-lookup"><span data-stu-id="a3675-122">However, if an operation is not idempotent, retries can cause unintended side effects.</span></span> <span data-ttu-id="a3675-123">Начальный вызов может быть выполнен успешно, но вызывающий объект никогда не получит ответ.</span><span class="sxs-lookup"><span data-stu-id="a3675-123">The original call might succeed, but the caller never gets a response.</span></span> <span data-ttu-id="a3675-124">Если вызывающий объект повторяет попытку, операция может вызываться дважды.</span><span class="sxs-lookup"><span data-stu-id="a3675-124">If the caller retries, the operation may be invoked twice.</span></span> <span data-ttu-id="a3675-125">Как правило, небезопасно повторять методы POST или PATCH, потому что они не обязательно будут идемпотентными.</span><span class="sxs-lookup"><span data-stu-id="a3675-125">Generally, it's not safe to retry POST or PATCH methods, because these are not guaranteed to be idempotent.</span></span>

- <span data-ttu-id="a3675-126">**[Автоматический выключатель](../patterns/circuit-breaker.md)**.</span><span class="sxs-lookup"><span data-stu-id="a3675-126">**[Circuit Breaker](../patterns/circuit-breaker.md)**.</span></span> <span data-ttu-id="a3675-127">Слишком много неудавшихся запросов могут вызвать узкое место, так как ожидающие запросы накапливаются в очереди.</span><span class="sxs-lookup"><span data-stu-id="a3675-127">Too many failed requests can cause a bottleneck, as pending requests accumulate in the queue.</span></span> <span data-ttu-id="a3675-128">Эти заблокированные запросы могут содержать критические системные ресурсы, такие как память, потоки, подключения к базе данных и т. д., что может привести к каскадным сбоям.</span><span class="sxs-lookup"><span data-stu-id="a3675-128">These blocked requests might hold critical system resources such as memory, threads, database connections, and so on, which can cause cascading failures.</span></span> <span data-ttu-id="a3675-129">С помощью шаблона автоматического выключения (прерывателя) в службе можно предотвратить повторное выполнение операции, которая, вероятнее всего, завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="a3675-129">The Circuit Breaker pattern can prevent a service from repeatedly trying an operation that is likely to fail.</span></span>

<span data-ttu-id="a3675-130">**Балансировка нагрузки**.</span><span class="sxs-lookup"><span data-stu-id="a3675-130">**Load balancing**.</span></span> <span data-ttu-id="a3675-131">Когда служба "A" вызывает службу "B", запрос должен достичь работающего экземпляра службы "B".</span><span class="sxs-lookup"><span data-stu-id="a3675-131">When service "A" calls service "B", the request must reach a running instance of service "B".</span></span> <span data-ttu-id="a3675-132">В Kubernetes тип ресурса `Service` обеспечивает стабильный IP-адрес для всех групп модулей pod.</span><span class="sxs-lookup"><span data-stu-id="a3675-132">In Kubernetes, the `Service` resource type provides a stable IP address for a group of pods.</span></span> <span data-ttu-id="a3675-133">Сетевой трафик на IP-адрес службы отправляется в pod с помощью правил iptable.</span><span class="sxs-lookup"><span data-stu-id="a3675-133">Network traffic to the service's IP address gets forwarded to a pod by means of iptable rules.</span></span> <span data-ttu-id="a3675-134">По умолчанию выбирается случайный модуль pod.</span><span class="sxs-lookup"><span data-stu-id="a3675-134">By default, a random pod is chosen.</span></span> <span data-ttu-id="a3675-135">Слой взаимодействия между службами (см. ниже) может обеспечить более интеллектуальные алгоритмы балансировки нагрузки на основе наблюдаемой задержки или других метрик.</span><span class="sxs-lookup"><span data-stu-id="a3675-135">A service mesh (see below) can provide more intelligent load balancing algorithms based on observed latency or other metrics.</span></span>

<span data-ttu-id="a3675-136">**Распределенная трассировка**.</span><span class="sxs-lookup"><span data-stu-id="a3675-136">**Distributed tracing**.</span></span> <span data-ttu-id="a3675-137">Одна транзакция может охватывать несколько служб.</span><span class="sxs-lookup"><span data-stu-id="a3675-137">A single transaction may span multiple services.</span></span> <span data-ttu-id="a3675-138">Это может затруднить наблюдение за общей производительностью и работоспособностью системы.</span><span class="sxs-lookup"><span data-stu-id="a3675-138">That can make it hard to monitor the overall performance and health of the system.</span></span> <span data-ttu-id="a3675-139">Даже если каждая служба создает журналы и метрики, при отсутствии определенного метода связать их вместе они имеют ограниченное использование.</span><span class="sxs-lookup"><span data-stu-id="a3675-139">Even if every service generates logs and metrics, without some way to tie them together, they are of limited use.</span></span> <span data-ttu-id="a3675-140">В главе о [ведении журнала и мониторинге](./logging-monitoring.md) более подробно рассматривается вопрос распределенной трассировки, но здесь он упоминается как проблема.</span><span class="sxs-lookup"><span data-stu-id="a3675-140">The chapter [Logging and monitoring](./logging-monitoring.md) talks more about distributed tracing, but we mention it here as a challenge.</span></span>

<span data-ttu-id="a3675-141">**Управление версиями службы**.</span><span class="sxs-lookup"><span data-stu-id="a3675-141">**Service versioning**.</span></span> <span data-ttu-id="a3675-142">Развертывая новую версию службы, команда должна предотвратить нарушение работы каких-либо других служб или внешних клиентов, которые зависят от нее.</span><span class="sxs-lookup"><span data-stu-id="a3675-142">When a team deploys a new version of a service, they must avoid breaking any other services or external clients that depend on it.</span></span> <span data-ttu-id="a3675-143">Кроме того, можно выполнять несколько версий службы параллельно и перенаправлять запросы к определенной версии.</span><span class="sxs-lookup"><span data-stu-id="a3675-143">In addition, you might want to run multiple versions of a service side-by-side, and route requests to a particular version.</span></span> <span data-ttu-id="a3675-144">Дополнительные сведения см. в разделе [Управление версиями API](./api-design.md#api-versioning).</span><span class="sxs-lookup"><span data-stu-id="a3675-144">See [API Versioning](./api-design.md#api-versioning) for more discussion of this issue.</span></span>

<span data-ttu-id="a3675-145">**Шифрование TLS и взаимная проверка подлинности TLS**.</span><span class="sxs-lookup"><span data-stu-id="a3675-145">**TLS encryption and mutual TLS authentication**.</span></span> <span data-ttu-id="a3675-146">По соображениям безопасности можно зашифровать трафик между службами с помощью TLS и использовать взаимную проверку подлинности TLS для аутентификации вызывающих объектов.</span><span class="sxs-lookup"><span data-stu-id="a3675-146">For security reasons, you may want to encrypt traffic between services with TLS, and use mutual TLS authentication to authenticate callers.</span></span>

## <a name="synchronous-versus-asynchronous-messaging"></a><span data-ttu-id="a3675-147">Синхронный и асинхронный обмен сообщениями</span><span class="sxs-lookup"><span data-stu-id="a3675-147">Synchronous versus asynchronous messaging</span></span>

<span data-ttu-id="a3675-148">Существует два основных шаблона обмена сообщениями, с помощью которых микрослужбы могут взаимодействовать.</span><span class="sxs-lookup"><span data-stu-id="a3675-148">There are two basic messaging patterns that microservices can use to communicate with other microservices.</span></span>

1. <span data-ttu-id="a3675-149">Синхронный обмен данными.</span><span class="sxs-lookup"><span data-stu-id="a3675-149">Synchronous communication.</span></span> <span data-ttu-id="a3675-150">В этом шаблоне служба вызывает API, который предоставляет другая служба, используя протокол, такой как HTTP или gRPC.</span><span class="sxs-lookup"><span data-stu-id="a3675-150">In this pattern, a service calls an API that another service exposes, using a protocol such as HTTP or gRPC.</span></span> <span data-ttu-id="a3675-151">Это шаблон синхронного обмена сообщениями, потому что вызывающий объект ожидает ответа от получателя.</span><span class="sxs-lookup"><span data-stu-id="a3675-151">This option is a synchronous messaging pattern because the caller waits for a response from the receiver.</span></span>

2. <span data-ttu-id="a3675-152">Асинхронная передача сообщений.</span><span class="sxs-lookup"><span data-stu-id="a3675-152">Asynchronous message passing.</span></span> <span data-ttu-id="a3675-153">В этом шаблоне служба отправляет сообщение, не дожидаясь ответа, поэтому одна или несколько служб обрабатывают сообщения асинхронно.</span><span class="sxs-lookup"><span data-stu-id="a3675-153">In this pattern, a service sends message without waiting for a response, and one or more services process the message asynchronously.</span></span>

<span data-ttu-id="a3675-154">Важно различать асинхронный ввод-вывод и асинхронный протокол.</span><span class="sxs-lookup"><span data-stu-id="a3675-154">It's important to distinguish between asynchronous I/O and an asynchronous protocol.</span></span> <span data-ttu-id="a3675-155">Асинхронный ввод-вывод означает, что вызывающий поток не блокируется, пока не завершится операция ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="a3675-155">Asynchronous I/O means the calling thread is not blocked while the I/O completes.</span></span> <span data-ttu-id="a3675-156">Он важен для производительности и является элементом реализации с точки зрения архитектуры.</span><span class="sxs-lookup"><span data-stu-id="a3675-156">That's important for performance, but is an implementation detail in terms of the architecture.</span></span> <span data-ttu-id="a3675-157">Асинхронный протокол подразумевает, что отправитель не ждет ответа.</span><span class="sxs-lookup"><span data-stu-id="a3675-157">An asynchronous protocol means the sender doesn't wait for a response.</span></span> <span data-ttu-id="a3675-158">Протокол HTTP — это синхронный протокол, хотя клиент HTTP может использовать асинхронный ввод-вывод при отправке запроса.</span><span class="sxs-lookup"><span data-stu-id="a3675-158">HTTP is a synchronous protocol, even though an HTTP client may use asynchronous I/O when it sends a request.</span></span>

<span data-ttu-id="a3675-159">Каждый шаблон имеет свои недостатки.</span><span class="sxs-lookup"><span data-stu-id="a3675-159">There are tradeoffs to each pattern.</span></span> <span data-ttu-id="a3675-160">"Запрос — ответ" является вполне понятной парадигмой, поэтому разработка API может показаться более естественной, чем проектирование системы обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="a3675-160">Request/response is a well-understood paradigm, so designing an API may feel more natural than designing a messaging system.</span></span> <span data-ttu-id="a3675-161">Тем не менее асинхронный обмен сообщениями имеет некоторые преимущества, которые могут быть очень полезными в архитектуре микрослужб.</span><span class="sxs-lookup"><span data-stu-id="a3675-161">However, asynchronous messaging has some advantages that can be very useful in a microservices architecture:</span></span>

- <span data-ttu-id="a3675-162">**Слабая взаимозависимость**.</span><span class="sxs-lookup"><span data-stu-id="a3675-162">**Reduced coupling**.</span></span> <span data-ttu-id="a3675-163">Отправителю сообщения не нужно знать об объекте-получателе.</span><span class="sxs-lookup"><span data-stu-id="a3675-163">The message sender does not need to know about the consumer.</span></span>

- <span data-ttu-id="a3675-164">**Несколько подписчиков**.</span><span class="sxs-lookup"><span data-stu-id="a3675-164">**Multiple subscribers**.</span></span> <span data-ttu-id="a3675-165">С помощью модели публикации и подписки несколько клиентов могут подписаться на получение событий.</span><span class="sxs-lookup"><span data-stu-id="a3675-165">Using a pub/sub model, multiple consumers can subscribe to receive events.</span></span> <span data-ttu-id="a3675-166">Дополнительные сведения см. в статье [Стиль архитектуры, управляемой событиями](/azure/architecture/guide/architecture-styles/event-driven).</span><span class="sxs-lookup"><span data-stu-id="a3675-166">See [Event-driven architecture style](/azure/architecture/guide/architecture-styles/event-driven).</span></span>

- <span data-ttu-id="a3675-167">**Изоляция сбоев**.</span><span class="sxs-lookup"><span data-stu-id="a3675-167">**Failure isolation**.</span></span> <span data-ttu-id="a3675-168">Если объект-получатель вышел из строя, отправитель все равно может отправлять сообщения.</span><span class="sxs-lookup"><span data-stu-id="a3675-168">If the consumer fails, the sender can still send messages.</span></span> <span data-ttu-id="a3675-169">Сообщения будут доставлены, когда объект-получатель восстановится.</span><span class="sxs-lookup"><span data-stu-id="a3675-169">The messages will be picked up when the consumer recovers.</span></span> <span data-ttu-id="a3675-170">Эта возможность особенно полезна в архитектуре микрослужб, так как каждая служба имеет свой собственный жизненный цикл.</span><span class="sxs-lookup"><span data-stu-id="a3675-170">This ability is especially useful in a microservices architecture, because each service has its own lifecycle.</span></span> <span data-ttu-id="a3675-171">В любой момент времени служба может стать недоступной или быть заменена более новой версией.</span><span class="sxs-lookup"><span data-stu-id="a3675-171">A service could become unavailable or be replaced with a newer version at any given time.</span></span> <span data-ttu-id="a3675-172">Асинхронный обмен сообщениями может обрабатывать прерывистый простой.</span><span class="sxs-lookup"><span data-stu-id="a3675-172">Asynchronous messaging can handle intermittent downtime.</span></span> <span data-ttu-id="a3675-173">С другой стороны, в синхронных API нижестоящая служба должна быть доступна, иначе операция завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="a3675-173">Synchronous APIs, on the other hand, require the downstream service to be available or the operation fails.</span></span>

- <span data-ttu-id="a3675-174">**Скорость реагирования**.</span><span class="sxs-lookup"><span data-stu-id="a3675-174">**Responsiveness**.</span></span> <span data-ttu-id="a3675-175">Вышестоящая служба может отвечать быстрее, если она не ждет ответа от нижестоящих служб.</span><span class="sxs-lookup"><span data-stu-id="a3675-175">An upstream service can reply faster if it does not wait on downstream services.</span></span> <span data-ttu-id="a3675-176">Это особенно удобно использовать в архитектуре микрослужб.</span><span class="sxs-lookup"><span data-stu-id="a3675-176">This is especially useful in a microservices architecture.</span></span> <span data-ttu-id="a3675-177">Если имеется цепочка зависимостей служб (служба "A" вызывает "B", которая вызывает "C" и т. д.), то ожидание синхронных вызовов может привести к неприемлемым задержкам.</span><span class="sxs-lookup"><span data-stu-id="a3675-177">If there is a chain of service dependencies (service A calls B, which calls C, and so on), waiting on synchronous calls can add unacceptable amounts of latency.</span></span>

- <span data-ttu-id="a3675-178">**Выравнивание нагрузки**.</span><span class="sxs-lookup"><span data-stu-id="a3675-178">**Load leveling**.</span></span> <span data-ttu-id="a3675-179">Очередь может выступать в качестве буфера для выравнивания рабочей нагрузки, поэтому получатели могут обрабатывать сообщения с нужной им скоростью.</span><span class="sxs-lookup"><span data-stu-id="a3675-179">A queue can act as a buffer to level the workload, so that receivers can process messages at their own rate.</span></span>

- <span data-ttu-id="a3675-180">**Рабочие процессы**.</span><span class="sxs-lookup"><span data-stu-id="a3675-180">**Workflows**.</span></span> <span data-ttu-id="a3675-181">Очереди можно использовать для управления рабочим процессом, устанавливая конечную точку для сообщения после каждого шага рабочего процесса.</span><span class="sxs-lookup"><span data-stu-id="a3675-181">Queues can be used to manage a workflow, by check-pointing the message after each step in the workflow.</span></span>

<span data-ttu-id="a3675-182">Однако существуют некоторые проблемы с эффективностью использования асинхронного обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="a3675-182">However, there are also some challenges to using asynchronous messaging effectively.</span></span>

- <span data-ttu-id="a3675-183">**Взаимозависимость с инфраструктурой обмена сообщениями**.</span><span class="sxs-lookup"><span data-stu-id="a3675-183">**Coupling with the messaging infrastructure**.</span></span> <span data-ttu-id="a3675-184">Использование определенной инфраструктуры обмена сообщениями может вызвать тесную связь с этой инфраструктурой.</span><span class="sxs-lookup"><span data-stu-id="a3675-184">Using a particular messaging infrastructure may cause tight coupling with that infrastructure.</span></span> <span data-ttu-id="a3675-185">Потом будет сложно переключиться на другую инфраструктуру обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="a3675-185">It will be difficult to switch to another messaging infrastructure later.</span></span>

- <span data-ttu-id="a3675-186">**Задержка**.</span><span class="sxs-lookup"><span data-stu-id="a3675-186">**Latency**.</span></span> <span data-ttu-id="a3675-187">Если очереди сообщений заполняются, то совокупная задержка обработки операций может стать очень высокой.</span><span class="sxs-lookup"><span data-stu-id="a3675-187">End-to-end latency for an operation may become high if the message queues fill up.</span></span>

- <span data-ttu-id="a3675-188">**Стоимость**.</span><span class="sxs-lookup"><span data-stu-id="a3675-188">**Cost**.</span></span> <span data-ttu-id="a3675-189">При высокой пропускной способности инфраструктура обмена сообщениями может быть дорогостоящей.</span><span class="sxs-lookup"><span data-stu-id="a3675-189">At high throughputs, the monetary cost of the messaging infrastructure could be significant.</span></span>

- <span data-ttu-id="a3675-190">**Сложность.**</span><span class="sxs-lookup"><span data-stu-id="a3675-190">**Complexity**.</span></span> <span data-ttu-id="a3675-191">Обработка асинхронного обмена сообщениями является непростой задачей.</span><span class="sxs-lookup"><span data-stu-id="a3675-191">Handling asynchronous messaging is not a trivial task.</span></span> <span data-ttu-id="a3675-192">Например, нужно обрабатывать дублирующиеся сообщения, удаляя дубликаты либо делая операции идемпотентными.</span><span class="sxs-lookup"><span data-stu-id="a3675-192">For example, you must handle duplicated messages, either by de-duplicating or by making operations idempotent.</span></span> <span data-ttu-id="a3675-193">При использовании асинхронного обмена сообщениями также трудно реализовать семантику "запрос — ответ".</span><span class="sxs-lookup"><span data-stu-id="a3675-193">It's also hard to implement request-response semantics using asynchronous messaging.</span></span> <span data-ttu-id="a3675-194">Для отправки ответа потребуется другая очередь, а также способ коррелировать запросы и ответные сообщения.</span><span class="sxs-lookup"><span data-stu-id="a3675-194">To send a response, you need another queue, plus a way to correlate request and response messages.</span></span>

- <span data-ttu-id="a3675-195">**Пропускная способность**.</span><span class="sxs-lookup"><span data-stu-id="a3675-195">**Throughput**.</span></span> <span data-ttu-id="a3675-196">Если сообщения требуют *семантику очереди*, то очереди могут стать узким местом в системе.</span><span class="sxs-lookup"><span data-stu-id="a3675-196">If messages require *queue semantics*, the queue can become a bottleneck in the system.</span></span> <span data-ttu-id="a3675-197">Каждое сообщение требует наличия хотя бы одной операции постановки в очередь и одной операции вывода из очереди.</span><span class="sxs-lookup"><span data-stu-id="a3675-197">Each message requires at least one queue operation and one dequeue operation.</span></span> <span data-ttu-id="a3675-198">Более того, семантика очереди обычно требует некоторой блокировки внутри инфраструктуры обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="a3675-198">Moreover, queue semantics generally require some kind of locking inside the messaging infrastructure.</span></span> <span data-ttu-id="a3675-199">Если очередь выступает управляемой службой, может появиться дополнительная задержка, так как очередь является внешней по отношению к виртуальной сети кластера.</span><span class="sxs-lookup"><span data-stu-id="a3675-199">If the queue is a managed service, there may be additional latency, because the queue is external to the cluster's virtual network.</span></span> <span data-ttu-id="a3675-200">Можно устранить эти проблемы, используя пакетные сообщения, но это усложнит код.</span><span class="sxs-lookup"><span data-stu-id="a3675-200">You can mitigate these issues by batching messages, but that complicates the code.</span></span> <span data-ttu-id="a3675-201">Если сообщения не требуют семантики очереди, можно использовать *поток* событий вместо очереди.</span><span class="sxs-lookup"><span data-stu-id="a3675-201">If the messages don't require queue semantics, you might be able to use an event *stream* instead of a queue.</span></span> <span data-ttu-id="a3675-202">Дополнительные сведения см. в статье [Стиль архитектуры, управляемой событиями](../guide/architecture-styles/event-driven.md).</span><span class="sxs-lookup"><span data-stu-id="a3675-202">For more information, see [Event-driven architectural style](../guide/architecture-styles/event-driven.md).</span></span>

## <a name="drone-delivery-choosing-the-messaging-patterns"></a><span data-ttu-id="a3675-203">Доставка с помощью дронов. Выбор шаблонов обмена сообщениями</span><span class="sxs-lookup"><span data-stu-id="a3675-203">Drone Delivery: Choosing the messaging patterns</span></span>

<span data-ttu-id="a3675-204">Учитывая приведенные выше соображения, команда разработчиков сделала следующие выборы в отношении проектирования приложения доставки с помощью дронов.</span><span class="sxs-lookup"><span data-stu-id="a3675-204">With these considerations in mind, the development team made the following design choices for the Drone Delivery application</span></span>

- <span data-ttu-id="a3675-205">Служба приема предоставляет открытый интерфейс REST API, который клиентские приложения используют для планирования, обновления или отмены поставок.</span><span class="sxs-lookup"><span data-stu-id="a3675-205">The Ingestion service exposes a public REST API that client applications use to schedule, update, or cancel deliveries.</span></span>

- <span data-ttu-id="a3675-206">Служба приема использует Центры событий для отправки асинхронных сообщений в службу планировщика.</span><span class="sxs-lookup"><span data-stu-id="a3675-206">The Ingestion service uses Event Hubs to send asynchronous messages to the Scheduler service.</span></span> <span data-ttu-id="a3675-207">Асинхронные сообщения необходимы для реализации выравнивания нагрузки, которая необходима для приема данных.</span><span class="sxs-lookup"><span data-stu-id="a3675-207">Asynchronous messages are necessary to implement the load-leveling that is required for ingestion.</span></span> <span data-ttu-id="a3675-208">Дополнительные сведения о взаимодействии служб приема данных и планировщика см. в главе о [приеме данных и рабочем процессе][ingestion-workflow].</span><span class="sxs-lookup"><span data-stu-id="a3675-208">For details on how the Ingestion and Scheduler services interact, see [Ingestion and workflow][ingestion-workflow].</span></span>

- <span data-ttu-id="a3675-209">Службы учетной записи, доставки, посылок, дронов и транспортных услуг третьих лиц предоставляют внутренние интерфейсы REST API.</span><span class="sxs-lookup"><span data-stu-id="a3675-209">The Account, Delivery, Package, Drone, and Third-party Transport services all expose internal REST APIs.</span></span> <span data-ttu-id="a3675-210">Служба планировщика вызывает эти API для выполнения запроса пользователя.</span><span class="sxs-lookup"><span data-stu-id="a3675-210">The Scheduler service calls these APIs to carry out a user request.</span></span> <span data-ttu-id="a3675-211">Одной из причин использования синхронных API является то, что планировщику необходимо получить ответ от каждой из нижестоящих служб.</span><span class="sxs-lookup"><span data-stu-id="a3675-211">One reason to use synchronous APIs is that the Scheduler needs to get a response from each of the downstream services.</span></span> <span data-ttu-id="a3675-212">Сбой в любой из нижестоящих служб означает, что вся операция завершилась неудачно.</span><span class="sxs-lookup"><span data-stu-id="a3675-212">A failure in any of the downstream services means the entire operation failed.</span></span> <span data-ttu-id="a3675-213">Тем не менее потенциальная проблема — это объем задержки, которая возникает при вызове серверных служб.</span><span class="sxs-lookup"><span data-stu-id="a3675-213">However, a potential issue is the amount of latency that is introduced by calling the backend services.</span></span>

- <span data-ttu-id="a3675-214">Если в какой-либо нижестоящей службе произошла повторяющаяся ошибка, вся транзакция должна быть отмечена как завершившаяся сбоем.</span><span class="sxs-lookup"><span data-stu-id="a3675-214">If any downstream service has a non-transient failure, the entire transaction should be marked as failed.</span></span> <span data-ttu-id="a3675-215">Для обработки этого случая служба планировщика отправляет асинхронное сообщение контролеру, который может запланировать компенсирующие транзакции, как описано в главе о [приеме данных и рабочем процессе][ingestion-workflow].</span><span class="sxs-lookup"><span data-stu-id="a3675-215">To handle this case, the Scheduler service sends an asynchronous message to the Supervisor, so that the Supervisor can schedule compensating transactions, as described in the chapter [Ingestion and workflow][ingestion-workflow].</span></span>

- <span data-ttu-id="a3675-216">Служба доставки предоставляет открытый API, который клиенты могут использовать для получения состояния доставки.</span><span class="sxs-lookup"><span data-stu-id="a3675-216">The Delivery service exposes a public API that clients can use to get the status of a delivery.</span></span> <span data-ttu-id="a3675-217">В главе о [шлюзах API](./gateway.md) рассматривается, как шлюз API может скрывать базовые службы от клиента, поэтому клиенту не нужно знать, какие API предоставляют те или иные службы.</span><span class="sxs-lookup"><span data-stu-id="a3675-217">In the chapter [API gateway](./gateway.md), we discuss how an API gateway can hide the underlying services from the client, so the client doesn't need to know which services expose which APIs.</span></span>

- <span data-ttu-id="a3675-218">Пока дрон находится в полете, служба дронов отправляет события, которые содержат сведения о текущем местоположении и состоянии дрона.</span><span class="sxs-lookup"><span data-stu-id="a3675-218">While a drone is in flight, the Drone service sends events that contain the drone's current location and status.</span></span> <span data-ttu-id="a3675-219">Служба доставки принимает эти события для отслеживания состояния доставки.</span><span class="sxs-lookup"><span data-stu-id="a3675-219">The Delivery service listens to these events in order to track the status of a delivery.</span></span>

- <span data-ttu-id="a3675-220">При изменении состояния доставки служба доставки отправляет событие состояния доставки, например `DeliveryCreated` или `DeliveryCompleted`.</span><span class="sxs-lookup"><span data-stu-id="a3675-220">When the status of a delivery changes, the Delivery service sends a delivery status event, such as `DeliveryCreated` or `DeliveryCompleted`.</span></span> <span data-ttu-id="a3675-221">Любая служба может подписаться на получение этих событий.</span><span class="sxs-lookup"><span data-stu-id="a3675-221">Any service can subscribe to these events.</span></span> <span data-ttu-id="a3675-222">В текущей версии архитектуры служба доставки является единственным подписчиком, но позже могут появиться другие подписчики.</span><span class="sxs-lookup"><span data-stu-id="a3675-222">In the current design, the Delivery service is the only subscriber, but there might be other subscribers later.</span></span> <span data-ttu-id="a3675-223">Например, события могут попадать в службу аналитики в режиме реального времени.</span><span class="sxs-lookup"><span data-stu-id="a3675-223">For example, the events might go to a real-time analytics service.</span></span> <span data-ttu-id="a3675-224">Так как планировщик не должен ожидать ответа, добавление большего количества подписчиков не влияет на путь основного рабочего процесса.</span><span class="sxs-lookup"><span data-stu-id="a3675-224">And because the Scheduler doesn't have to wait for a response, adding more subscribers doesn't affect the main workflow path.</span></span>

![Схема обмена данными между дронами](./images/drone-communication.png)

<span data-ttu-id="a3675-226">Обратите внимание, что события состояния доставки являются производными от событий расположения дронов.</span><span class="sxs-lookup"><span data-stu-id="a3675-226">Notice that delivery status events are derived from drone location events.</span></span> <span data-ttu-id="a3675-227">Например, когда дрон достигает места доставки и выгружает груз, служба доставки преобразует это в событие DeliveryCompleted (доставка завершена).</span><span class="sxs-lookup"><span data-stu-id="a3675-227">For example, when a drone reaches a delivery location and drops off a package, the Delivery service translates this into a DeliveryCompleted event.</span></span> <span data-ttu-id="a3675-228">Это пример подхода с учетом модели предметной области.</span><span class="sxs-lookup"><span data-stu-id="a3675-228">This is an example of thinking in terms of domain models.</span></span> <span data-ttu-id="a3675-229">Как описано выше, управление дронами принадлежит к отдельному ограниченному контексту.</span><span class="sxs-lookup"><span data-stu-id="a3675-229">As described earlier, Drone Management belongs in a separate bounded context.</span></span> <span data-ttu-id="a3675-230">События дронов передают их физическое расположение.</span><span class="sxs-lookup"><span data-stu-id="a3675-230">The drone events convey the physical location of a drone.</span></span> <span data-ttu-id="a3675-231">С другой стороны, события доставки представляют собой изменения состояния доставки, что является другой бизнес-сущностью.</span><span class="sxs-lookup"><span data-stu-id="a3675-231">The delivery events, on the other hand, represent changes in the status of a delivery, which is a different business entity.</span></span>

## <a name="using-a-service-mesh"></a><span data-ttu-id="a3675-232">Использование слоя взаимодействия между службами</span><span class="sxs-lookup"><span data-stu-id="a3675-232">Using a service mesh</span></span>

<span data-ttu-id="a3675-233">*Слой взаимодействия между службами* — это программный уровень, который обрабатывает обмен данными между службами.</span><span class="sxs-lookup"><span data-stu-id="a3675-233">A *service mesh* is a software layer that handles service-to-service communication.</span></span> <span data-ttu-id="a3675-234">Слои взаимодействия между службами предназначены для решения многих проблем, перечисленных в предыдущем разделе. Они позволяют перенести ответственность за эти проблемы от самих микрослужб на общий уровень.</span><span class="sxs-lookup"><span data-stu-id="a3675-234">Service meshes are designed to address many of the concerns listed in the previous section, and to move responsibility for these concerns away from the microservices themselves and into a shared layer.</span></span> <span data-ttu-id="a3675-235">Слой взаимодействия между службами выступает в качестве прокси-сервера, который перехватывает сетевой обмен данными между микрослужбами в кластере.</span><span class="sxs-lookup"><span data-stu-id="a3675-235">The service mesh acts as a proxy that intercepts network communication between microservices in the cluster.</span></span>

> [!NOTE]
> <span data-ttu-id="a3675-236">Слой взаимодействия между службами является примером [шаблона посредника](../patterns/ambassador.md) &mdash; вспомогательной службы, которая отправляет сетевые запросы от имени приложения.</span><span class="sxs-lookup"><span data-stu-id="a3675-236">Service mesh is an example of the [Ambassador pattern](../patterns/ambassador.md) &mdash; a helper service that sends network requests on behalf of the application.</span></span>

<span data-ttu-id="a3675-237">Сейчас основными вариантами слоя взаимодействия между службами в Kubernetes являются [linkerd](https://linkerd.io/) и [Istio](https://istio.io/).</span><span class="sxs-lookup"><span data-stu-id="a3675-237">Right now, the main options for a service mesh in Kubernetes are [linkerd](https://linkerd.io/) and [Istio](https://istio.io/).</span></span> <span data-ttu-id="a3675-238">Обе эти технологии быстро развиваются.</span><span class="sxs-lookup"><span data-stu-id="a3675-238">Both of these technologies are evolving rapidly.</span></span> <span data-ttu-id="a3675-239">Тем не менее и linkerd, и Istio предоставляют следующие функции:</span><span class="sxs-lookup"><span data-stu-id="a3675-239">However, some features that both linkerd and Istio have in common include:</span></span>

- <span data-ttu-id="a3675-240">Балансировка нагрузки на уровне сеанса, основанная на наблюдаемых задержках или количестве ожидающих запросов.</span><span class="sxs-lookup"><span data-stu-id="a3675-240">Load balancing at the session level, based on observed latencies or number of outstanding requests.</span></span> <span data-ttu-id="a3675-241">Это может повысить производительность по сравнению с балансировкой нагрузки уровня 4, предоставляемой Kubernetes.</span><span class="sxs-lookup"><span data-stu-id="a3675-241">This can improve performance over the layer-4 load balancing that is provided by Kubernetes.</span></span>

- <span data-ttu-id="a3675-242">Маршрутизация уровня 7 на основе URL-адреса, заголовка узла, версии API или других правил уровня приложения.</span><span class="sxs-lookup"><span data-stu-id="a3675-242">Layer-7 routing based on URL path, Host header, API version, or other application-level rules.</span></span>

- <span data-ttu-id="a3675-243">Повторение невыполненных запросов.</span><span class="sxs-lookup"><span data-stu-id="a3675-243">Retry of failed requests.</span></span> <span data-ttu-id="a3675-244">Слой взаимодействия между службами распознает коды ошибок HTTP и может автоматически повторять невыполненные запросы.</span><span class="sxs-lookup"><span data-stu-id="a3675-244">A service mesh understands HTTP error codes, and can automatically retry failed requests.</span></span> <span data-ttu-id="a3675-245">Можно настроить максимальное количество попыток, а также время ожидания, чтобы ограничить максимальную задержку.</span><span class="sxs-lookup"><span data-stu-id="a3675-245">You can configure that maximum number of retries, along with a timeout period in order to bound the maximum latency.</span></span>

- <span data-ttu-id="a3675-246">Автоматическое выключение.</span><span class="sxs-lookup"><span data-stu-id="a3675-246">Circuit breaking.</span></span> <span data-ttu-id="a3675-247">Если экземпляр последовательно не выполняет запросы, слой взаимодействия между службами временно пометит его как отключенный.</span><span class="sxs-lookup"><span data-stu-id="a3675-247">If an instance consistently fails requests, the service mesh will temporarily mark it as unavailable.</span></span> <span data-ttu-id="a3675-248">Через некоторое время он снова попробует связаться с экземпляром.</span><span class="sxs-lookup"><span data-stu-id="a3675-248">After a backoff period, it will try the instance again.</span></span> <span data-ttu-id="a3675-249">Можно настроить автоматический выключатель на основе различных критериев, таких как количество последовательных сбоев.</span><span class="sxs-lookup"><span data-stu-id="a3675-249">You can configure the circuit breaker based on various criteria, such as the number of consecutive failures,</span></span>  

- <span data-ttu-id="a3675-250">Слой взаимодействия между службами фиксирует показатели вызовов между службами, такие как объем запроса, задержка, уровень ошибок и успешности, а также размеры ответов.</span><span class="sxs-lookup"><span data-stu-id="a3675-250">Service mesh captures metrics about interservice calls, such as the request volume, latency, error and success rates, and response sizes.</span></span> <span data-ttu-id="a3675-251">Слой взаимодействия между службами также позволяет распределенную трассировку путем добавления информации о корреляции для каждого прыжка в запросе.</span><span class="sxs-lookup"><span data-stu-id="a3675-251">The service mesh also enables distributed tracing by adding correlation information for each hop in a request.</span></span>

- <span data-ttu-id="a3675-252">Взаимная проверка подлинности TLS для вызовов между службами.</span><span class="sxs-lookup"><span data-stu-id="a3675-252">Mutual TLS Authentication for service-to-service calls.</span></span>

<span data-ttu-id="a3675-253">Вам нужен слой взаимодействия между службами?</span><span class="sxs-lookup"><span data-stu-id="a3675-253">Do you need a service mesh?</span></span> <span data-ttu-id="a3675-254">Предоставляемые им преимущества в распределенной системе, безусловно, убедительны.</span><span class="sxs-lookup"><span data-stu-id="a3675-254">The value they add to a distributed system is certainly compelling.</span></span> <span data-ttu-id="a3675-255">Если у вас нет слоя взаимодействия между службами, вам необходимо будет рассмотреть каждую из проблем, упомянутых в начале главы.</span><span class="sxs-lookup"><span data-stu-id="a3675-255">If you don't have a service mesh, you will need to consider each of the challenges mentioned at the beginning of the chapter.</span></span> <span data-ttu-id="a3675-256">Вы можете решать такие проблемы, как повторение запросов, автоматический выключатель и распределенная трассировка без слоя взаимодействия между службами, но она перемещает эти проблемы из отдельных служб на выделенный уровень.</span><span class="sxs-lookup"><span data-stu-id="a3675-256">You can solve problems like retry, circuit breaker, and distributed tracing without a service mesh, but a service mesh moves these concerns out of the individual services and into a dedicated layer.</span></span> <span data-ttu-id="a3675-257">С другой стороны, слои взаимодействия между службами являются относительно новой технологией, которая все еще дорабатывается.</span><span class="sxs-lookup"><span data-stu-id="a3675-257">On the other hand, service meshes are a relatively new technology that is still maturing.</span></span> <span data-ttu-id="a3675-258">Развертывание слоя взаимодействия между службами усложняет установку и настройку кластера.</span><span class="sxs-lookup"><span data-stu-id="a3675-258">Deploying a service mesh adds complexity to the setup and configuration of the cluster.</span></span> <span data-ttu-id="a3675-259">Так как запросы теперь маршрутизируются через прокси-сервер слоя взаимодействия между службами, а также потому, что на каждом узле кластера теперь выполняются дополнительные службы, возможны последствия для производительности.</span><span class="sxs-lookup"><span data-stu-id="a3675-259">There may be performance implications, because requests now get routed through the service mesh proxy, and because extra services are now running on every node in the cluster.</span></span> <span data-ttu-id="a3675-260">Следует выполнять тщательную проверку производительности и нагрузочное тестирование перед развертыванием слоя взаимодействия между службами в рабочей среде.</span><span class="sxs-lookup"><span data-stu-id="a3675-260">You should do thorough performance and load testing before deploying a service mesh in production.</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="a3675-261">Проектирование API</span><span class="sxs-lookup"><span data-stu-id="a3675-261">API design</span></span>](./api-design.md)

<!-- links -->

[ingestion-workflow]: ./ingestion-workflow.md

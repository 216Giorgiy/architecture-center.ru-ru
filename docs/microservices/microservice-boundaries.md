---
title: Определение границ микрослужбы
description: Определение границ микрослужбы
author: MikeWasson
ms.date: 12/08/2017
ms.openlocfilehash: d35b92ffd97c4fda5d6599340925ce3dfea7f15b
ms.sourcegitcommit: a5e549c15a948f6fb5cec786dbddc8578af3be66
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/06/2018
---
# <a name="designing-microservices-identifying-microservice-boundaries"></a>Проектирование микрослужб: определение границ микрослужбы

Какой размер является подходящим для микрослужбы? Вам часто приходилось слышать ответ наподобие "не слишком большой и не слишком маленький". Это, конечно, верно, но как реализовать это на практике? Если вы начнете с тщательно разработанной модели предметной области, то так гораздо легче рассуждать о микрослужбах.

![](./images/bounded-contexts.png)

## <a name="from-domain-model-to-microservices"></a>От модели предметной области к микрослужбам

В [предыдущей части](./domain-analysis.md) мы определили набор ограниченных контекстов для приложения доставки с помощью дронов. Затем мы подробнее рассмотрели один из ограниченных контекстов, а именно ограниченный контекст доставки, и определили для него набор сущностей, статистических выражений и служб предметных областей.

Теперь вы готовы перейти от модели предметной области к разработке приложения. Ниже представлен подход, который можно использовать для определения микрослужб на основе модели предметной области.

1. Начните с ограниченного контекста. В целом функциональность в микрослужбе не должна охватывать более одного ограниченного контекста. Согласно определению ограниченный контекст помечает границу конкретной модели предметной области. Если микрослужба охватывает разные модели предметной области, вам нужно вернуться назад и уточнить анализ предметной области.

2. Затем проанализируйте статистические выражения в модели предметной области. Статистические выражения часто являются хорошими кандидатами для микрослужбы. Хорошо спроектированные статистические выражения демонстрируют характеристики хорошо спроектированной микрослужбы, например:

    - Статистические выражения скорее происходят из бизнес-требований, нежели из технических соображений, таких как доступ к данным или обмен сообщениями.  
    - Статистические выражения должны иметь высокую функциональную слаженность.
    - Статистическое выражение является границей сохраняемости.
    - Статистические выражения должны быть слабо связаны. 
    
3. Службы предметных областей также являются хорошими кандидатами для микрослужб. Это операции без учета состояния в нескольких статистических выражениях. Типичным примером является рабочий процесс, который охватывает несколько микрослужб. Такой пример реализован в приложении доставки с помощью дронов.

4. И наконец, рассмотрим требования, не касающиеся функциональности. Рассмотрите такие факторы, как размер команды, тип данных, технологии, требования к масштабируемости, доступности и безопасности. Возможно, из-за них вам придется разделить микрослужбу на две или более меньшие службы или сделать противоположное (объединить несколько микрослужб в одну). 

Когда вы определите микрослужбы в приложении, поверьте структуру на соответствие следующим условиям:

- Каждая из служб отвечает за одну функциональность.
- Между службами отсутствуют частые вызовы. Если после разделения функциональности на две службы они станут отправлять слишком много вызовов, это может быть признаком того, что функции принадлежат к одной службе.
- Каждая из служб достаточно небольшая, так что ее может независимо создать команда из нескольких человек.
- Нет никаких взаимных зависимостей, из-за которых необходимо развертывать две или больше микрослужб в связке. Всегда должна быть возможность развернуть службу без повторного развертывания других служб.
- Службы не имеют тесной связи и могут развиваться независимо.
- Границы вашей службы не будут создавать проблем с согласованностью или целостностью данных. Иногда важно поддерживать согласованность данных, разместив функциональность в одной микрослужбе. Тем не менее, подумайте, действительно ли вам нужна высокая согласованность. Существуют стратегии для обеспечения итоговой согласованности в распределенной системе, а преимущества декомпозиции служб часто перевешивают проблемы поддержки такой согласованности.

Прежде всего, важно быть прагматичным и помнить, что предметно-ориентированное проектирование является итеративным процессом. В случае сомнений начинайте с недетализированных микрослужб. Разделить микрослужбу на две меньшие службы проще, чем выполнить рефакторинг функциональности между несколькими существующими микрослужбами.
  
## <a name="drone-delivery-defining-the-microservices"></a>Доставка с помощью дронов: определение микрослужб

Напомним, что команда разработчиков определила четыре статистических выражения &mdash; "Доставка", "Посылка", "Дрон" и "Учетная запись" &mdash; и две службы предметных областей "Планировщик" и "Контролер". 

"Доставка" и "Посылка" являются очевидными кандидатами для микрослужб. "Планировщик" и "Контролер" координируют действия, выполняемые другими микрослужбами, поэтому имеет смысл внедрить эти службы предметных областей в качестве микрослужб.  

"Дрон" и "Учетная запись" интересны тем, что они принадлежат к другим ограниченным контекстам. Один из вариантов заключается в том, чтобы "Планировщик" напрямую вызывал ограниченные контексты "Дрон" и "Учетная запись". Также можно создать микрослужбы"Дрон" и "Учетная запись" внутри ограниченного контекста доставки. Эти микрослужбы будут посредниками между ограниченными контекстами, предоставляя API или схемы данных, которые более подходят для контекста доставки.

Подробности об ограниченных контекстах "Дрон" и "Учетная запись" выходят за рамки этого руководства, поэтому мы создали для них макеты служб в нашей эталонной реализации. Но в этой ситуации необходимо учитывать некоторые факторы:

- Какова нагрузка на сеть для прямого вызова другого ограниченного контекста? 

- Подходит ли схема данных другого ограниченного контекста для этого контекста или лучше иметь схему, предназначенную для этого ограниченного контекста? 

- Является ли другой ограниченный контекст устаревшей системой? Если так, то можно создать службу, которая действует как [уровень защиты от повреждений](../patterns/anti-corruption-layer.md) для преобразования между старой системой и современным приложением. 

- Какова структура команды? Легко ли взаимодействовать с командой, ответственной за другой ограниченный контекст? Если нет, тогда создайте службу, которая будет посредником между двумя контекстами, что может помочь снизить стоимость взаимодействия между командами.

До сих пор мы не рассматривали каких-либо нефункциональных требований. Думая о требованиях к пропускной способности приложений, команда разработчиков решила создать отдельную микрослужбу приема, которая отвечает за прием клиентских запросов. Эта микрослужба будет выполнять [выравнивание нагрузки](../patterns/queue-based-load-leveling.md), помещая входящие запросы в буфер для обработки. Планировщик будет считывать запросы из буфера и выполнять рабочий процесс. 

Чтобы удовлетворить нефункциональные требования, команде пришлось создать еще одну дополнительную службу. До сих пор все службы касались процесса планирования и доставки посылок в режиме реального времени. Но для анализа данных системе также необходимо сохранять историю каждой доставки в объект для долговременного хранения. Команда возложила ответственность за это на службу доставки. Тем не менее, требования к хранилищу данных совершенно различны для исторического анализа и текущих операций (см. [рекомендации в отношении данных](./data-considerations.md)). Поэтому команда решила создать отдельную службу истории доставки, которая будет прослушивать события для отслеживания доставки из службы доставки и записывать их в долговременное хранилище.

На следующей схеме показана структура на этом конкретном этапе:
 
![](./images/microservices.png)

## <a name="choosing-a-compute-option"></a>Выбор варианта вычисления

Термин *вычислительная служба* означает модель размещения вычислительных ресурсов, которые используются для выполнения приложения. Для архитектуры микрослужб особенно популярными являются два подхода:

- Служба оркестратора, которая управляет службами, выполняющимися на выделенных узлах (виртуальных машинах).
- Бессерверная архитектура, которая использует функции как услугу (FaaS). 

Хотя это не единственные варианты, они оба являются проверенными подходами к созданию микрослужб. В приложение могут быть включены оба эти подхода.

### <a name="service-orchestrators"></a>Оркестраторы служб

Оркестратор выполняет задачи, связанные с развертыванием набора служб и управлением ним. К этим задачам относятся размещение служб на узлах, мониторинг состояния работоспособности служб, перезапуск неработоспособных служб, балансировка нагрузки сетевого трафика между экземплярами службы, обнаружение служб, масштабирование количества экземпляров службы и применение обновления конфигурации. Популярными оркестрами являются Kubernetes, DC/OS, Docker Swarm и Service Fabric. 

- [Служба контейнеров Azure](/azure/container-service/) (ACS) — это служба Azure, которая позволяет развертывать готовые для рабочей среды кластеры Kubernetes, DC/OS или Docker Swarm.

- [Служба контейнеров Azure](/azure/aks/) (AKS) является управляемой службой Kubernetes. AKS реализует среду Kubernetes и предоставляет конечные точки API Kubernetes, а также содержит и администрирует плоскость управления Kubernetes, выполняя автоматические обновления, автоматическое исправление, автомасштабирование и другие задачи управления. Вы можете думать об AKS как о "программных интерфейсах API Kubernetes как услуге". В момент написания этой статьи доступна предварительная версия AKS. Тем не менее, ожидается, что AKS станет предпочтительным вариантом для выполнения Kubernetes в Azure. 

- [Service Fabric](/azure/service-fabric/) — это платформа распределенных систем для упаковки и развертывания микрослужб, а также управления ими. Микрослужбы могут быть развернуты в Service Fabric в виде контейнеров, исполняемых двоичных файлов или [Reliable Services](/azure/service-fabric/service-fabric-reliable-services-introduction). Используя модель программирования Reliable Services, службы могут напрямую использовать API программирования Service Fabric, чтобы отправлять запросы к системе, формировать отчеты о состоянии, получать уведомления об изменениях конфигурации и кода, а также обнаруживать другие службы. Ключевое отличие Service Fabric — активная ориентация на создание служб с отслеживанием состояния с использованием [Reliable Collections](/azure/service-fabric/service-fabric-reliable-services-reliable-collections).

### <a name="containers"></a>Контейнеры

Иногда о контейнерах и микрослужбах говорят так, как будто это одно и то же. Это в корне неверно. Для создания микрослужб не нужны контейнеры. Тем не менее, контейнеры имеют некоторые преимущества, которые особенно актуальны для микрослужб, в частности:

- **Мобильность.** Образ контейнера представляет собой изолированный пакет, для запуска которого не нужно устанавливать библиотеки или другие зависимости. Благодаря этому их легче развертывать. Контейнеры можно быстро запустить и остановить, что позволяет развернуть новые экземпляры, чтобы обрабатывать большую нагрузку или восстанавливаться после сбоев узлов. 

- **Плотность**. По сравнению с виртуальными машинами, контейнеры имеют меньшую плотность, так как они совместно используют ресурсы ОС. Благодаря этому можно упаковать несколько контейнеров в единый узел, что особенно полезно, когда приложение состоит из множества небольших служб.

- **Изоляция ресурсов**. Вы можете ограничить объем ресурсов памяти и ЦП, которые доступны для контейнера, чтобы неконтролируемый процесс не исчерпал ресурсы узла. Дополнительные сведения см. в статье [Шаблон отсеков](../patterns/bulkhead.md).

### <a name="serverless-functions-as-a-service"></a>Бессерверная архитектура (функции как услуга)

При использовании бессерверной архитектуры не нужно управлять виртуальными машинами или инфраструктурой виртуальных сетей. Вместо этого, вы развертываете код, который будет передан службой размещения в виртуальную машину для выполнения. Этот подход поддерживает небольшие детализированные функции, которые координируются с использованием триггеров, основанных на событиях. Например, сообщение, помещенное в очередь, может запустить функцию, которая считывает из очереди и обрабатывает сообщение.

[Функции Azure][functions] — это независимая от сервера служба вычислений, которая поддерживает различные триггеры функций, в том числе HTTP-запросы, очереди служебной шины и события концентраторов событий. Полный список см. в статье [Основные понятия триггеров и привязок в Функциях Azure][functions-triggers]. Также рассмотрите возможность использования [Сетки событий Azure][event-grid]. Это управляемая служба маршрутизации событий в Azure.

### <a name="orchestrator-or-serverless"></a>Архитектура с оркестрацией или независимая от сервера

Ниже приведено несколько факторов, которые нужно учитывать при выборе между архитектурой с оркестратором и бессерверной архитектурой.

**Управляемость**. Бессерверными приложениями легче управлять, так как всеми вычислительными ресурсами управляет платформа. При использовании оркестратора некоторые аспекты администрирования и настройки кластера представлены на абстрактном уровне, он не полностью скрывает базовые виртуальные машины. При использовании оркестратора вам будет необходимо думать о таких проблемах, как балансировка нагрузки, использование ЦП и памяти, а также работа сети.

**Гибкость и контроль**. С помощью оркестратора у вас появится больше контроля над настройкой служб и кластера, а также управлением ими. Компромисс является дополнительной сложностью. При использовании бессерверной архитектуры вы теряете некоторую часть контроля, так как эти детали абстрагированы.

**Мобильность.** Все перечисленные здесь оркестраторы (Kubernetes, DC/OS, Docker Swarm и Service Fabric) могут работать в локальной среде или в нескольких общедоступных облаках. 

**Интеграция приложений**. Создание сложного приложения с бессерверной архитектурой может оказаться трудной задачей. Единственным вариантом в Azure является использование [Azure Logic Apps](/azure/logic-apps/) для координации набора функций Azure. Пример этого подхода представлен в статье [Создание функции, интегрируемой с Azure Logic Apps](/azure/azure-functions/functions-twitter-email).

**Стоимость**. С оркестратором вы платите за виртуальные машины, которые работают в кластере. С независимым от сервера приложением вы платите только за фактически использованные вычислительные ресурсы. В обоих случаях вам необходимо учитывать стоимость любых дополнительных служб, таких как хранилища, базы данных и службы обмена сообщениями.

**Масштабируемость**. Функции Azure масштабируются автоматически в соответствии с требованиями в зависимости от числа входящих событий. При использовании оркестратора вы можете выполнить масштабирование, увеличив количество экземпляров службы, запущенных в кластере. Вы также можете изменить масштаб, добавив дополнительные виртуальные машины в кластер.

В эталонной реализации в основном используется Kubernetes, но мы также использовали службу "Функции Azure" для службы "История доставки". Функции Azure подходят этой конкретной службе, так как это управляемая событиями рабочая нагрузка. Так как для вызова функции используется триггер концентраторов событий, службе требуется минимальное количество кода. Кроме того, служба "История доставки" не является частью основного рабочего процесса, поэтому ее запуск за пределами кластера Kubernetes не повлияет на совокупную задержку инициированных пользователем операций. 

> [!div class="nextstepaction"]
> [Рекомендации в отношении данных](./data-considerations.md)

<!-- links -->

[acs-engine]: https://github.com/Azure/acs-engine
[acs-faq]: /azure/container-service/dcos-swarm/container-service-faq
[event-grid]: /azure/event-grid/
[functions]: /azure/azure-functions/functions-overview
[functions-triggers]: /azure/azure-functions/functions-triggers-bindings

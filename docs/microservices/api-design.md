---
title: Проектирование API
description: Проектирование API для микрослужб
author: MikeWasson
ms.date: 10/23/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: 01f774773b2d2a653e52c9ee961f12c5b9fc833a
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/23/2019
ms.locfileid: "54485984"
---
# <a name="designing-microservices-api-design"></a><span data-ttu-id="f6d9d-103">Проектирование микрослужб. Проектирование API</span><span class="sxs-lookup"><span data-stu-id="f6d9d-103">Designing microservices: API design</span></span>

<span data-ttu-id="f6d9d-104">Правильное проектирование API важно в архитектуре микрослужб, так как весь обмен данными между службами происходит либо через сообщения, либо через вызовы API.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-104">Good API design is important in a microservices architecture, because all data exchange between services happens either through messages or API calls.</span></span> <span data-ttu-id="f6d9d-105">API должны быть эффективными и не допускать создания [множественных операций ввода-вывода](../antipatterns/chatty-io/index.md).</span><span class="sxs-lookup"><span data-stu-id="f6d9d-105">APIs must be efficient to avoid creating [chatty I/O](../antipatterns/chatty-io/index.md).</span></span> <span data-ttu-id="f6d9d-106">Так как службы разрабатывают отдельные команды, API должны иметь четко определенную семантику и схемы управления версиями, чтобы обновления не прерывали работу других служб.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-106">Because services are designed by teams working independently, APIs must have well-defined semantics and versioning schemes, so that updates don't break other services.</span></span>

![Проектирование API для микрослужб](./images/api-design.png)

<span data-ttu-id="f6d9d-108">Важно различать два типа API:</span><span class="sxs-lookup"><span data-stu-id="f6d9d-108">It's important to distinguish between two types of API:</span></span>

- <span data-ttu-id="f6d9d-109">общедоступные API, которые вызываются клиентскими приложениями;</span><span class="sxs-lookup"><span data-stu-id="f6d9d-109">Public APIs that client applications call.</span></span>
- <span data-ttu-id="f6d9d-110">серверные API, которые используются для обмена данными между службами.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-110">Backend APIs that are used for interservice communication.</span></span>

<span data-ttu-id="f6d9d-111">Эти два варианта использования имеют различные требования.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-111">These two use cases have somewhat different requirements.</span></span> <span data-ttu-id="f6d9d-112">Общедоступный API должен быть совместим с клиентскими приложениями (браузерными приложениями или собственными мобильными приложениями).</span><span class="sxs-lookup"><span data-stu-id="f6d9d-112">A public API must be compatible with client applications, typically browser applications or native mobile applications.</span></span> <span data-ttu-id="f6d9d-113">В большинстве случаев это означает, что общедоступный API будет использовать REST по протоколу HTTP.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-113">Most of the time, that means the public API will use REST over HTTP.</span></span> <span data-ttu-id="f6d9d-114">Однако для серверных API нужно учитывать производительность сети.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-114">For the backend APIs, however, you need to take network performance into account.</span></span> <span data-ttu-id="f6d9d-115">Обмен данными между службами может привести к большому трафику. Это зависит от степени детализации ваших служб.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-115">Depending on the granularity of your services, interservice communication can result in a lot of network traffic.</span></span> <span data-ttu-id="f6d9d-116">У них могут быстро появиться ограничения ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-116">Services can quickly become I/O bound.</span></span> <span data-ttu-id="f6d9d-117">Поэтому важна скорость сериализации и объем полезных данных.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-117">For that reason, considerations such as serialization speed and payload size become more important.</span></span> <span data-ttu-id="f6d9d-118">К известным альтернативным вариантам использования REST по протоколу HTTP относятся gRPC, Apache Avro и Apache Thrift.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-118">Some popular alternatives to using REST over HTTP include gRPC, Apache Avro, and Apache Thrift.</span></span> <span data-ttu-id="f6d9d-119">Эти протоколы поддерживают двоичную сериализацию и, как правило, эффективнее протокола HTTP.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-119">These protocols support binary serialization and are generally more efficient than HTTP.</span></span>

## <a name="considerations"></a><span data-ttu-id="f6d9d-120">Рекомендации</span><span class="sxs-lookup"><span data-stu-id="f6d9d-120">Considerations</span></span>

<span data-ttu-id="f6d9d-121">Когда вы выбираете способ реализации API, нужно обратить внимание на следующие аспекты.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-121">Here are some things to think about when choosing how to implement an API.</span></span>

<span data-ttu-id="f6d9d-122">**Сравнение REST и RPC**.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-122">**REST vs RPC**.</span></span> <span data-ttu-id="f6d9d-123">Рассмотрим компромиссы между использованием интерфейса на основе REST и интерфейса на основе RPC.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-123">Consider the tradeoffs between using a REST-style interface versus an RPC-style interface.</span></span>

- <span data-ttu-id="f6d9d-124">REST моделирует ресурсы, что может быть стандартным способом выражения модели предметной области.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-124">REST models resources, which can be a natural way express your domain model.</span></span> <span data-ttu-id="f6d9d-125">В этом случае мы имеем единый интерфейс, основанный на HTTP-командах, что способствует развитию.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-125">It defines a uniform interface based on HTTP verbs, which encourages evolvability.</span></span> <span data-ttu-id="f6d9d-126">Такой интерфейс имеет четко определенную семантику с точки зрения идемпотентности, побочных эффектов и кодов отклика.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-126">It has well-defined semantics in terms of idempotency, side effects, and response codes.</span></span> <span data-ttu-id="f6d9d-127">Кроме того, он обеспечивает связь без учета состояния, что повышает масштабируемость.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-127">And it enforces stateless communication, which improves scalability.</span></span>

- <span data-ttu-id="f6d9d-128">Интерфейс RPC более ориентирован на операции или команды.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-128">RPC is more oriented around operations or commands.</span></span> <span data-ttu-id="f6d9d-129">Интерфейсы RPC похожи на вызовы локальных методов. Это может привести к проектированию API, выполняющих слишком частый обмен данными.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-129">Because RPC interfaces look like local method calls, it may lead you to design overly chatty APIs.</span></span> <span data-ttu-id="f6d9d-130">Однако это не должно быть так.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-130">However, that doesn't mean RPC must be chatty.</span></span> <span data-ttu-id="f6d9d-131">Просто, проектируя интерфейс, нужно быть крайне осторожным.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-131">It just means you need to use care when designing the interface.</span></span>

<span data-ttu-id="f6d9d-132">Для интерфейса RESTful наиболее распространенным вариантом является REST по протоколу HTTP с использованием JSON.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-132">For a RESTful interface, the most common choice is REST over HTTP using JSON.</span></span> <span data-ttu-id="f6d9d-133">Для интерфейса на основе RPC существует несколько популярных платформ, в том числе gRPC, Apache Avro и Apache Thrift.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-133">For an RPC-style interface, there are several popular frameworks, including gRPC, Apache Avro, and Apache Thrift.</span></span>

<span data-ttu-id="f6d9d-134">**Эффективность**.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-134">**Efficiency**.</span></span> <span data-ttu-id="f6d9d-135">Рассмотрите возможность повышения эффективности с точки зрения скорости, объема памяти и полезных данных.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-135">Consider efficiency in terms of speed, memory, and payload size.</span></span> <span data-ttu-id="f6d9d-136">Обычно интерфейс на основе gRPC быстрее, чем REST по протоколу HTTP.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-136">Typically a gRPC-based interface is faster than REST over HTTP.</span></span>

<span data-ttu-id="f6d9d-137">**Язык описания интерфейса (IDL)**.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-137">**Interface definition language (IDL)**.</span></span> <span data-ttu-id="f6d9d-138">IDL используется для определения методов, параметров и возвращаемых значений API.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-138">An IDL is used to define the methods, parameters, and return values of an API.</span></span> <span data-ttu-id="f6d9d-139">IDL может использоваться для создания клиентского кода, кода сериализации и документации API.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-139">An IDL can be used to generate client code, serialization code, and API documentation.</span></span> <span data-ttu-id="f6d9d-140">IDL также могут использовать инструменты тестирования API, такие как Postman.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-140">IDLs can also be consumed by API testing tools such as Postman.</span></span> <span data-ttu-id="f6d9d-141">Такие платформы, как gRPC, Avro и Thrift, определяют свои собственные спецификации IDL.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-141">Frameworks such as gRPC, Avro, and Thrift define their own IDL specifications.</span></span> <span data-ttu-id="f6d9d-142">REST по протоколу HTTP не имеет стандартного формата IDL. Типичным вариантом является OpenAPI (ранее известный как Swagger).</span><span class="sxs-lookup"><span data-stu-id="f6d9d-142">REST over HTTP does not have a standard IDL format, but a common choice is OpenAPI (formerly Swagger).</span></span> <span data-ttu-id="f6d9d-143">Вы также можете создать HTTP REST API, не используя формальный язык описания, но тогда у вас не будет преимуществ создания и тестирования кода.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-143">You can also create an HTTP REST API without using a formal definition language, but then you lose the benefits of code generation and testing.</span></span>

<span data-ttu-id="f6d9d-144">**Сериализация**.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-144">**Serialization**.</span></span> <span data-ttu-id="f6d9d-145">Как объекты сериализуются по сети?</span><span class="sxs-lookup"><span data-stu-id="f6d9d-145">How are objects serialized over the wire?</span></span> <span data-ttu-id="f6d9d-146">Применяются текстовые форматы (в первую очередь JSON) и двоичные форматы, такие как буфер протокола.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-146">Options include text-based formats (primarily JSON) and binary formats such as protocol buffer.</span></span> <span data-ttu-id="f6d9d-147">Двоичные форматы обычно быстрее, чем текстовые.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-147">Binary formats are generally faster than text-based formats.</span></span> <span data-ttu-id="f6d9d-148">Однако JSON имеет преимущества в плане взаимодействия, так как большинство языков и платформ поддерживают сериализацию JSON.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-148">However, JSON has advantages in terms of interoperability, because most languages and frameworks support JSON serialization.</span></span> <span data-ttu-id="f6d9d-149">Одним форматам сериализации нужна фиксированная схема, а другим — компиляция файла описания схемы.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-149">Some serialization formats require a fixed schema, and some require compiling a schema definition file.</span></span> <span data-ttu-id="f6d9d-150">В таком случае вам необходимо включить этот шаг в процесс сборки.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-150">In that case, you'll need to incorporate this step into your build process.</span></span>

<span data-ttu-id="f6d9d-151">**Поддержка платформ и языков**.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-151">**Framework and language support**.</span></span> <span data-ttu-id="f6d9d-152">Протокол HTTP поддерживается практически каждой платформой и языком.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-152">HTTP is supported in nearly every framework and language.</span></span> <span data-ttu-id="f6d9d-153">Платформы gRPC, Avro и Thrift также имеют библиотеки для языков C++, C#, Java и Python.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-153">gRPC, Avro, and Thrift all have libraries for C++, C#, Java, and Python.</span></span> <span data-ttu-id="f6d9d-154">Thrift и gRPC также поддерживают язык Go.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-154">Thrift and gRPC also support Go.</span></span>

<span data-ttu-id="f6d9d-155">**Совместимость и взаимодействие**.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-155">**Compatibility and interoperability**.</span></span> <span data-ttu-id="f6d9d-156">Если вы выберете протокол gRPC, вам нужен будет слой преобразования протокола между общедоступным API и серверной частью.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-156">If you choose a protocol like gRPC, you may need a protocol translation layer between the public API and the back end.</span></span> <span data-ttu-id="f6d9d-157">Эту функцию может выполнять [шлюз](./gateway.md).</span><span class="sxs-lookup"><span data-stu-id="f6d9d-157">A [gateway](./gateway.md) can perform that function.</span></span> <span data-ttu-id="f6d9d-158">Если вы используете ПО слоя взаимодействия между службами, узнайте, какие протоколы с ней совместимы.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-158">If you are using a service mesh, consider which protocols are compatible with the service mesh.</span></span> <span data-ttu-id="f6d9d-159">Например, linkerd имеет встроенную поддержку HTTP, Thrift и gRPC.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-159">For example, linkerd has built-in support for HTTP, Thrift, and gRPC.</span></span>

<span data-ttu-id="f6d9d-160">Если вам не нужны преимущества производительности двоичного протокола, мы рекомендуем выбрать REST по протоколу HTTP.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-160">Our baseline recommendation is to choose REST over HTTP unless you need the performance benefits of a binary protocol.</span></span> <span data-ttu-id="f6d9d-161">Для этого варианта не нужны специальные библиотеки.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-161">REST over HTTP requires no special libraries.</span></span> <span data-ttu-id="f6d9d-162">Он обеспечивает минимальную взаимозависимость, потому что вызывающим объектам не нужна клиентская заглушка для связи со службой.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-162">It creates minimal coupling, because callers don't need a client stub to communicate with the service.</span></span> <span data-ttu-id="f6d9d-163">Существуют широкие экосистемы инструментов для поддержки определений схем, тестирования и мониторинга конечных точек HTTP RESTful.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-163">There is rich ecosystems of tools to support schema definitions, testing, and monitoring of RESTful HTTP endpoints.</span></span> <span data-ttu-id="f6d9d-164">И наконец, протокол HTTP совместим с браузерными клиентами, поэтому вам не нужен слой преобразования протокола между клиентом и серверной частью.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-164">Finally, HTTP is compatible with browser clients, so you don't need a protocol translation layer between the client and the backend.</span></span>

<span data-ttu-id="f6d9d-165">Однако, если вы выбираете REST по протоколу HTTP, на ранней стадии процесса разработки необходимо выполнить тестирование производительности и нагрузки, чтобы проверить, достаточно ли хорошо он работает для вашего сценария.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-165">However, if you choose REST over HTTP, you should do performance and load testing early in the development process, to validate whether it performs well enough for your scenario.</span></span>

## <a name="restful-api-design"></a><span data-ttu-id="f6d9d-166">Проектирование API-интерфейсов RESTful</span><span class="sxs-lookup"><span data-stu-id="f6d9d-166">RESTful API design</span></span>

<span data-ttu-id="f6d9d-167">Существует много ресурсов по проектированию API-интерфейсов RESTful.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-167">There are many resources for designing RESTful APIs.</span></span> <span data-ttu-id="f6d9d-168">Вот некоторые из них:</span><span class="sxs-lookup"><span data-stu-id="f6d9d-168">Here are some that you might find helpful:</span></span>

- [<span data-ttu-id="f6d9d-169">Проектирование API</span><span class="sxs-lookup"><span data-stu-id="f6d9d-169">API design</span></span>](../best-practices/api-design.md)

- [<span data-ttu-id="f6d9d-170">Руководство по реализации API</span><span class="sxs-lookup"><span data-stu-id="f6d9d-170">API implementation</span></span>](../best-practices/api-implementation.md)

- [<span data-ttu-id="f6d9d-171">Рекомендации по REST API от Microsoft</span><span class="sxs-lookup"><span data-stu-id="f6d9d-171">Microsoft REST API Guidelines</span></span>](https://github.com/Microsoft/api-guidelines)

<span data-ttu-id="f6d9d-172">Ниже приведены моменты, на которые следует обратить внимание.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-172">Here are some specific considerations to keep in mind.</span></span>

- <span data-ttu-id="f6d9d-173">Будьте осторожнее с API, в которых недостаточно подробностей о внутренней реализации или которые просто отражают внутреннюю схему базы данных.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-173">Watch out for APIs that leak internal implementation details or simply mirror an internal database schema.</span></span> <span data-ttu-id="f6d9d-174">API должен моделировать предметную область.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-174">The API should model the domain.</span></span> <span data-ttu-id="f6d9d-175">Это контракт между службами, и в идеале это должно измениться только при добавлении новых функций, а не просто потому, что вы выполнили рефакторинг кода или нормализовали таблицу базы данных.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-175">It's a contract between services, and ideally should only change when new functionality is added, not just because you refactored some code or normalized a database table.</span></span>

- <span data-ttu-id="f6d9d-176">Для разных типов клиентов (например, мобильного приложения и классического браузера) могут потребоваться разные объемы полезных данных или шаблоны взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-176">Different types of client, such as mobile application and desktop web browser, may require different payload sizes or interaction patterns.</span></span> <span data-ttu-id="f6d9d-177">Рассмотрите возможность использования [схемы отдельных серверных частей для каждого интерфейса](../patterns/backends-for-frontends.md), чтобы для каждого клиента создать отдельные серверные части, которые предоставляют оптимальный интерфейс.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-177">Consider using the [Backends for Frontends pattern](../patterns/backends-for-frontends.md) to create separate backends for each client, that expose an optimal interface for that client.</span></span>

- <span data-ttu-id="f6d9d-178">Подумайте о том, как сделать операции с побочными эффектами идемпотентными и реализовать их в качестве методов PUT.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-178">For operations with side effects, consider making them idempotent and implementing them as PUT methods.</span></span> <span data-ttu-id="f6d9d-179">Это позволит выполнять безопасные повторные попытки и сможет повысить отказоустойчивость.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-179">That will enable safe retries and can improve resiliency.</span></span> <span data-ttu-id="f6d9d-180">Этот вопрос подробней описан в главе о [приеме данных и рабочем процессе](./ingestion-workflow.md#idempotent-vs-non-idempotent-operations), а также в главе об [обмене данными между службами](./interservice-communication.md).</span><span class="sxs-lookup"><span data-stu-id="f6d9d-180">The chapters [Ingestion and workflow](./ingestion-workflow.md#idempotent-vs-non-idempotent-operations) and [Interservice communication](./interservice-communication.md) discuss this issue in more detail.</span></span>

- <span data-ttu-id="f6d9d-181">Методы HTTP могут иметь асинхронную семантику, при которой метод немедленно возвращает ответ, а служба выполняет операцию асинхронно.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-181">HTTP methods can have asynchronous semantics, where the method returns a response immediately, but the service carries out the operation asynchronously.</span></span> <span data-ttu-id="f6d9d-182">В таком случае метод должен вернуть код отклика [HTTP 202](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html), который обозначает, что запрос был принят для обработки, однако она еще не завершена.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-182">In that case, the method should return an [HTTP 202](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) response code, which indicates the request was accepted for processing, but the processing is not yet completed.</span></span>

## <a name="mapping-rest-to-ddd-patterns"></a><span data-ttu-id="f6d9d-183">Сопоставление шаблонов REST и DDD</span><span class="sxs-lookup"><span data-stu-id="f6d9d-183">Mapping REST to DDD patterns</span></span>

<span data-ttu-id="f6d9d-184">Такие шаблоны как сущность, статистическое выражение и объект-значение, предназначены для установки определенных ограничений на объекты в вашей модели предметной области.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-184">Patterns such as entity, aggregate, and value object are designed to place certain constraints on the objects in your domain model.</span></span> <span data-ttu-id="f6d9d-185">Во многих обсуждениях DDD шаблоны моделируются с помощью понятий объектно-ориентированного (OO) языка, таких как конструкторы или методы получения и задания свойств.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-185">In many discussions of DDD, the patterns are modeled using object-oriented (OO) language concepts like constructors or property getters and setters.</span></span> <span data-ttu-id="f6d9d-186">Например, *объекты-значения* должны быть неизменными.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-186">For example, *value objects* are supposed to be immutable.</span></span> <span data-ttu-id="f6d9d-187">В OO-языке программирования для этого необходимо назначить значения в конструкторе и сделать свойства доступными только для чтения:</span><span class="sxs-lookup"><span data-stu-id="f6d9d-187">In an OO programming language, you would enforce this by assigning the values in the constructor and making the properties read-only:</span></span>

```ts
export class Location {
    readonly latitude: number;
    readonly longitude: number;

    constructor(latitude: number, longitude: number) {
        if (latitude < -90 || latitude > 90) {
            throw new RangeError('latitude must be between -90 and 90');
        }
        if (longitude < -180 || longitude > 180) {
            throw new RangeError('longitude must be between -180 and 180');
        }
        this.latitude = latitude;
        this.longitude = longitude;
    }
}
```

<span data-ttu-id="f6d9d-188">Такие методы кодирования особенно важны при сборке стандартного монолитного приложения.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-188">These sorts of coding practices are particularly important when building a traditional monolithic application.</span></span> <span data-ttu-id="f6d9d-189">При наличии большой базы кода многие подсистемы могут использовать объект `Location`, поэтому для него важно обеспечить правильное поведение.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-189">With a large code base, many subsystems might use the `Location` object, so it's important for the object to enforce correct behavior.</span></span>

<span data-ttu-id="f6d9d-190">Другим примером является шаблон репозитория, который гарантирует, что другие части приложения не будут выполнять прямые операции чтения или записи в отношении хранилища данных:</span><span class="sxs-lookup"><span data-stu-id="f6d9d-190">Another example is the Repository pattern, which ensures that other parts of the application do not make direct reads or writes to the data store:</span></span>

![Схема репозитория службы доставки дронами](./images/repository.png)

<span data-ttu-id="f6d9d-192">Однако в архитектуре микрослужб службы не используют одинаковые базы кода и хранилища данных.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-192">In a microservices architecture, however, services don't share the same code base and don't share data stores.</span></span> <span data-ttu-id="f6d9d-193">Вместо этого они обмениваются данными через API.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-193">Instead, they communicate through APIs.</span></span> <span data-ttu-id="f6d9d-194">Рассмотрим случай, когда служба "Планировщик" запрашивает информацию о дроне из службы дронов.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-194">Consider the case where the Scheduler service requests information about a drone from the Drone service.</span></span> <span data-ttu-id="f6d9d-195">У службы дронов есть внутренняя модель дрона, выраженная через код.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-195">The Drone service has its internal model of a drone, expressed through code.</span></span> <span data-ttu-id="f6d9d-196">Однако планировщик этого не видит.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-196">But the Scheduler doesn't see that.</span></span> <span data-ttu-id="f6d9d-197">Он возвращает *представление* сущности дрона, возможно объекта JSON, в ответе HTTP.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-197">Instead, it gets back a *representation* of the drone entity &mdash; perhaps a JSON object in an HTTP response.</span></span>

![Схема службы доставки дронами](./images/ddd-rest.png)

<span data-ttu-id="f6d9d-199">Служба "Планировщик" не может изменять внутренние модели службы дронов или записывать в ее хранилище данных.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-199">The Scheduler service can't modify the Drone service's internal models, or write to the Drone service's data store.</span></span> <span data-ttu-id="f6d9d-200">Это означает, что контактная зона кода, реализующего службу дронов, меньше по сравнению с зоной кода в стандартном монолитном приложении.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-200">That means the code that implements the Drone service has a smaller exposed surface area, compared with code in a traditional monolith.</span></span> <span data-ttu-id="f6d9d-201">Если служба дронов определяет класс расположения, область действия этого класса ограничена &mdash;, никакая другая служба не будет непосредственно использовать этот класс.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-201">If the Drone service defines a Location class, the scope of that class is limited &mdash; no other service will directly consume the class.</span></span>

<span data-ttu-id="f6d9d-202">Поэтому данное руководство не фокусируется на методах кодирования, так как они относятся к тактическим шаблонам DDD.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-202">For these reasons, this guidance doesn't focus much on coding practices as they relate to the tactical DDD patterns.</span></span> <span data-ttu-id="f6d9d-203">Однако вы также можете моделировать многие шаблоны DDD через API-интерфейсы REST.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-203">But it turns out that you can also model many of the DDD patterns through REST APIs.</span></span>

<span data-ttu-id="f6d9d-204">Например: </span><span class="sxs-lookup"><span data-stu-id="f6d9d-204">For example:</span></span>

- <span data-ttu-id="f6d9d-205">Статистические выражения естественным образом сопоставляются с *ресурсами* в REST.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-205">Aggregates map naturally to *resources* in REST.</span></span> <span data-ttu-id="f6d9d-206">Например, статистическое выражение поставки будет отображаться в качестве ресурса в API доставки.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-206">For example, the Delivery aggregate would be exposed as a resource by the Delivery API.</span></span>

- <span data-ttu-id="f6d9d-207">Статистические выражения — это границы согласованности.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-207">Aggregates are consistency boundaries.</span></span> <span data-ttu-id="f6d9d-208">Операции статистического вычисления никогда не должны оставлять статистическое выражение в несогласованном состоянии.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-208">Operations on aggregates should never leave an aggregate in an inconsistent state.</span></span> <span data-ttu-id="f6d9d-209">Поэтому следует избегать создания API, которые позволяют клиенту манипулировать внутренним состоянием статистического выражения.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-209">Therefore, you should avoid creating APIs that allow a client to manipulate the internal state of an aggregate.</span></span> <span data-ttu-id="f6d9d-210">Вместо этого создайте API, которые предоставляют статистические выражения в качестве ресурсов.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-210">Instead, favor coarse-grained APIs that expose aggregates as resources.</span></span>

- <span data-ttu-id="f6d9d-211">Сущности имеют уникальные идентификаторы.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-211">Entities have unique identities.</span></span> <span data-ttu-id="f6d9d-212">В REST ресурсы имеют уникальные идентификаторы в виде URL-адресов.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-212">In REST, resources have unique identifiers in the form of URLs.</span></span> <span data-ttu-id="f6d9d-213">Создайте URL-адреса ресурсов, которые соответствуют идентификатору предметной области сущности.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-213">Create resource URLs that correspond to an entity's domain identity.</span></span> <span data-ttu-id="f6d9d-214">Сопоставление URL-адреса с идентификатором предметной области может быть непрозрачным для клиента.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-214">The mapping from URL to domain identity may be opaque to client.</span></span>

- <span data-ttu-id="f6d9d-215">Получить доступ к дочерним сущностям статистического выражения можно путем перехода от корневого объекта.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-215">Child entities of an aggregate can be reached by navigating from the root entity.</span></span> <span data-ttu-id="f6d9d-216">Если вы следуете принципам [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS), для вас дочерние сущности могут быть доступны через ссылки в представлении родительской сущности.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-216">If you follow [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS) principles, child entities can be reached via links in the representation of the parent entity.</span></span>

- <span data-ttu-id="f6d9d-217">Так как объекты-значения неизменяемы, обновления выполняются путем замены всего объекта-значения.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-217">Because value objects are immutable, updates are performed by replacing the entire value object.</span></span> <span data-ttu-id="f6d9d-218">Для REST реализуйте обновления через запросы PUT или PATCH.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-218">In REST, implement updates through PUT or PATCH requests.</span></span>

- <span data-ttu-id="f6d9d-219">Репозиторий позволяет клиентам запрашивать, добавлять и удалять объекты в коллекции, абстрагируя детали базового хранилища данных.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-219">A repository lets clients query, add, or remove objects in a collection, abstracting the details of the underlying data store.</span></span> <span data-ttu-id="f6d9d-220">В REST коллекция может представлять собой отдельный ресурс с методами запроса коллекции или добавления новых сущностей в коллекцию.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-220">In REST, a collection can be a distinct resource, with methods for querying the collection or adding new entities to the collection.</span></span>

<span data-ttu-id="f6d9d-221">Во время проектирования API-интерфейсов обратите внимание на то, как они выражают модель предметной области, не только данные внутри модели, а бизнес-операции и ограничения на данные.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-221">When you design your APIs, think about how they express the domain model, not just the data inside the model, but also the business operations and the constraints on the data.</span></span>

| <span data-ttu-id="f6d9d-222">Концепция DDD</span><span class="sxs-lookup"><span data-stu-id="f6d9d-222">DDD concept</span></span> | <span data-ttu-id="f6d9d-223">Эквивалент в REST</span><span class="sxs-lookup"><span data-stu-id="f6d9d-223">REST equivalent</span></span> | <span data-ttu-id="f6d9d-224">Пример</span><span class="sxs-lookup"><span data-stu-id="f6d9d-224">Example</span></span> |
|-------------|-----------------|---------|
| <span data-ttu-id="f6d9d-225">Статистическое выражение</span><span class="sxs-lookup"><span data-stu-id="f6d9d-225">Aggregate</span></span> | <span data-ttu-id="f6d9d-226">Ресурс</span><span class="sxs-lookup"><span data-stu-id="f6d9d-226">Resource</span></span> | `{ "1":1234, "status":"pending"... }` |
| <span data-ttu-id="f6d9d-227">Удостоверение</span><span class="sxs-lookup"><span data-stu-id="f6d9d-227">Identity</span></span> | <span data-ttu-id="f6d9d-228">URL-адрес</span><span class="sxs-lookup"><span data-stu-id="f6d9d-228">URL</span></span> | `https://delivery-service/deliveries/1` |
| <span data-ttu-id="f6d9d-229">Дочерние сущности</span><span class="sxs-lookup"><span data-stu-id="f6d9d-229">Child entities</span></span> | <span data-ttu-id="f6d9d-230">Ссылки</span><span class="sxs-lookup"><span data-stu-id="f6d9d-230">Links</span></span> | `{ "href": "/deliveries/1/confirmation" }` |
| <span data-ttu-id="f6d9d-231">Обновление объектов-значений</span><span class="sxs-lookup"><span data-stu-id="f6d9d-231">Update value objects</span></span> | <span data-ttu-id="f6d9d-232">PUT или PATCH</span><span class="sxs-lookup"><span data-stu-id="f6d9d-232">PUT or PATCH</span></span> | `PUT https://delivery-service/deliveries/1/dropoff` |
| <span data-ttu-id="f6d9d-233">Репозиторий</span><span class="sxs-lookup"><span data-stu-id="f6d9d-233">Repository</span></span> | <span data-ttu-id="f6d9d-234">Коллекция</span><span class="sxs-lookup"><span data-stu-id="f6d9d-234">Collection</span></span> | `https://delivery-service/deliveries?status=pending` |

## <a name="api-versioning"></a><span data-ttu-id="f6d9d-235">Управление версиями API</span><span class="sxs-lookup"><span data-stu-id="f6d9d-235">API versioning</span></span>

<span data-ttu-id="f6d9d-236">API — это контракт между службой и клиентами или объектами-получателями.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-236">An API is a contract between a service and clients or consumers of that service.</span></span> <span data-ttu-id="f6d9d-237">При изменениях API возникает риск нарушения работы клиентов, которые зависят от API, будь то внешние клиенты или другие микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-237">If an API changes, there is a risk of breaking clients that depend on the API, whether those are external clients or other microservices.</span></span> <span data-ttu-id="f6d9d-238">Поэтому мы рекомендуем минимизировать количество изменений API.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-238">Therefore, it's a good idea to minimize the number of API changes that you make.</span></span> <span data-ttu-id="f6d9d-239">Часто для изменений в базовой реализации не нужны изменения в API.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-239">Often, changes in the underlying implementation don't require any changes to the API.</span></span> <span data-ttu-id="f6d9d-240">Однако в какой-то момент вам понадобится добавить новые функции или новые возможности, требующие изменения имеющегося API.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-240">Realistically, however, at some point you will want to add new features or new capabilities that require changing an existing API.</span></span>

<span data-ttu-id="f6d9d-241">По возможности обеспечьте обратную совместимость изменений API.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-241">Whenever possible, make API changes backward compatible.</span></span> <span data-ttu-id="f6d9d-242">Например, не удаляйте поле из модели, потому что это может нарушить работу клиентов, которым оно необходимо.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-242">For example, avoid removing a field from a model, because that can break clients that expect the field to be there.</span></span> <span data-ttu-id="f6d9d-243">Добавление поля не нарушает совместимость, так как клиенты должны игнорировать в ответе любые поля, которые они не понимают.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-243">Adding a field does not break compatibility, because clients should ignore any fields they don't understand in a response.</span></span> <span data-ttu-id="f6d9d-244">Однако служба должна обрабатывать случаи, когда устаревший клиент игнорирует новые поля в запросе.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-244">However, the service must handle the case where an older client omits the new field in a request.</span></span>

<span data-ttu-id="f6d9d-245">Обеспечьте поддержку управления версиями в контракте API.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-245">Support versioning in your API contract.</span></span> <span data-ttu-id="f6d9d-246">Если вы разработали критически важное изменение API, выпустите новую версию.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-246">If you introduce a breaking API change, introduce a new API version.</span></span> <span data-ttu-id="f6d9d-247">По-прежнему поддерживайте предыдущую версию и позвольте клиентам выбирать версию для вызова.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-247">Continue to support the previous version, and let clients select which version to call.</span></span> <span data-ttu-id="f6d9d-248">Для этого существует два способа.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-248">There are a couple of ways to do this.</span></span> <span data-ttu-id="f6d9d-249">Один из них — просто предоставить обе версии в одной службе.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-249">One is simply to expose both versions in the same service.</span></span> <span data-ttu-id="f6d9d-250">Другим вариантом является параллельный запуск двух версий службы и маршрутизация запросов к той или иной версии на основе правил маршрутизации HTTP.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-250">Another option is to run two versions of the service side-by-side, and route requests to one or the other version, based on HTTP routing rules.</span></span>

![Управление версиями](./images/versioning1.svg)

<span data-ttu-id="f6d9d-252">Поддержка нескольких версий сопровождается затратами: время разработки, тестирование и операционные издержки.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-252">There's a cost to supporting multiple versions, in terms of developer time, testing, and operational overhead.</span></span> <span data-ttu-id="f6d9d-253">Поэтому лучше как можно быстрее отказаться от старых версий.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-253">Therefore, it's good to deprecate old versions as quickly as possible.</span></span> <span data-ttu-id="f6d9d-254">Что касается внутренних API, команда, владеющая API, может работать с другими командами, чтобы помочь им перейти на новую версию.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-254">For internal APIs, the team that owns the API can work with other teams to help them migrate to the new version.</span></span> <span data-ttu-id="f6d9d-255">Это нужно, если необходим процесс управления в нескольких командах.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-255">This is when having a cross-team governance process is useful.</span></span> <span data-ttu-id="f6d9d-256">Для внешних (общедоступных) API может быть сложнее отказаться от версии API, особенно если API используется третьими лицами или собственными клиентскими приложениями.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-256">For external (public) APIs, it can be harder to deprecate an API version, especially if the API is consumed by third parties or by native client applications.</span></span>

<span data-ttu-id="f6d9d-257">Если реализация службы изменилась, нужно обозначить изменение версией.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-257">When a service implementation changes, it's useful to tag the change with a version.</span></span> <span data-ttu-id="f6d9d-258">Версия предоставляет важную информацию при устранении ошибок.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-258">The version provides important information when troubleshooting errors.</span></span> <span data-ttu-id="f6d9d-259">Во время выполнения анализа первопричин полезно знать, какая версия службы была вызвана.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-259">It can be very helpful for root cause analysis to know exactly which version of the service was called.</span></span> <span data-ttu-id="f6d9d-260">Рассмотрите возможность использования [семантической организации номера версии](https://semver.org/) для версий службы.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-260">Consider using [semantic versioning](https://semver.org/) for service versions.</span></span> <span data-ttu-id="f6d9d-261">При такой организации используется формат *основная.дополнительная.исправление*.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-261">Semantic versioning uses a *MAJOR.MINOR.PATCH* format.</span></span> <span data-ttu-id="f6d9d-262">Тем не менее клиенты должны выбрать API только по основному номеру версии или, возможно, по дополнительной версии при наличии значительных (но не критических) изменений между дополнительными версиями.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-262">However, clients should only select an API by the major version number, or possibly the minor version if there are significant (but non-breaking) changes between minor versions.</span></span> <span data-ttu-id="f6d9d-263">Другими словами, для клиентов лучше выбирать между версиями API 1 и 2 и не выбирать версию 2.1.3.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-263">In other words, it's reasonable for clients to select between version 1 and version 2 of an API, but not to select version 2.1.3.</span></span> <span data-ttu-id="f6d9d-264">При таком уровне детализации существует вероятность, что вам придется поддерживать увеличение количества версий.</span><span class="sxs-lookup"><span data-stu-id="f6d9d-264">If you allow that level of granularity, you risk having to support a proliferation of versions.</span></span>

<span data-ttu-id="f6d9d-265">Дальнейшее обсуждение управления версиями API см. в разделе [Управление версиями веб-API RESTful](../best-practices/api-design.md#versioning-a-restful-web-api).</span><span class="sxs-lookup"><span data-stu-id="f6d9d-265">For further discussion of API versioning, see [Versioning a RESTful web API](../best-practices/api-design.md#versioning-a-restful-web-api).</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="f6d9d-266">Прием данных и рабочий процесс</span><span class="sxs-lookup"><span data-stu-id="f6d9d-266">Ingestion and workflow</span></span>](./ingestion-workflow.md)

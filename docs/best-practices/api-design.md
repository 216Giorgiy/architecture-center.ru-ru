---
title: "Руководство по проектированию API"
description: "Рекомендации по созданию качественно спроектированного API."
author: dragon119
ms.date: 07/13/2016
pnp.series.title: Best Practices
ms.openlocfilehash: 3ffadce1b0c4a4da808e52d61cff0b7f0b27de11
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/14/2017
---
# <a name="api-design"></a><span data-ttu-id="8ae1b-103">Проектирование API</span><span class="sxs-lookup"><span data-stu-id="8ae1b-103">API design</span></span>
[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="8ae1b-104">Многие современные веб-решения используют веб-службы, размещенные на веб-серверах, для обеспечения работы удаленных клиентских приложений.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-104">Many modern web-based solutions make the use of web services, hosted by web servers, to provide functionality for remote client applications.</span></span> <span data-ttu-id="8ae1b-105">Предоставляемые веб-службой операции составляют веб-API.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-105">The operations that a web service exposes constitute a web API.</span></span> <span data-ttu-id="8ae1b-106">Качественно спроектированный API должен поддерживать следующее:</span><span class="sxs-lookup"><span data-stu-id="8ae1b-106">A well-designed web API should aim to support:</span></span>

* <span data-ttu-id="8ae1b-107">**Независимость от платформы**.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-107">**Platform independence**.</span></span> <span data-ttu-id="8ae1b-108">Клиентские приложения должны иметь возможность использовать API, предоставляемый веб-службой, независимо от физической реализации предоставления данных или операций через API.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-108">Client applications should be able to utilize the API that the web service provides without requiring how the data or operations that API exposes are physically implemented.</span></span> <span data-ttu-id="8ae1b-109">Для этого API должен соответствовать общепринятым стандартам, позволяющим клиентскому приложению и веб-службе согласовывать между собой используемые форматы данных и структуру данных, которыми обмениваются клиентские приложения и веб-служба.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-109">This requires that the API abides by common standards that enable a client application and web service to agree on which data formats to use, and the structure of the data that is exchanged between client applications and the web service.</span></span>
* <span data-ttu-id="8ae1b-110">**Развитие службы**.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-110">**Service evolution**.</span></span> <span data-ttu-id="8ae1b-111">Веб-служба должна иметь возможность развиваться и расширять (или сокращать) набор функций независимо от клиентских приложений.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-111">The web service should be able to evolve and add (or remove) functionality independently from client applications.</span></span> <span data-ttu-id="8ae1b-112">У существующих клиентских приложений должна быть возможность продолжать работу без изменений независимо от изменения функций, предоставляемых веб-службой.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-112">Existing client applications should be able to continue to operate unmodified as the features provided by the web service change.</span></span> <span data-ttu-id="8ae1b-113">Все функции также должны быть доступными, чтобы клиентские приложения могли полноценно их использовать.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-113">All functionality should also be discoverable, so that client applications can fully utilize it.</span></span>

<span data-ttu-id="8ae1b-114">Цель этого руководства — описать вопросы, на которые следует обратить внимание при разработке веб-API.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-114">The purpose of this guidance is to describe the issues that you should consider when designing a web API.</span></span>

## <a name="introduction-to-representational-state-transfer-rest"></a><span data-ttu-id="8ae1b-115">Общие сведения о передаче репрезентативного состояния (REST)</span><span class="sxs-lookup"><span data-stu-id="8ae1b-115">Introduction to Representational State Transfer (REST)</span></span>
<span data-ttu-id="8ae1b-116">В 2000 году Рой Филдинг в своей диссертации предложил альтернативный архитектурный подход к структурированию операций, предоставляемых веб-службами, — REST.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-116">In his dissertation in 2000, Roy Fielding proposed an alternative architectural approach to structuring the operations exposed by web services; REST.</span></span> <span data-ttu-id="8ae1b-117">REST — это архитектурная концепция создания распределенных систем на основе гиперсред.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-117">REST is an architectural style for building distributed systems based on hypermedia.</span></span> <span data-ttu-id="8ae1b-118">Основное достоинство модели REST в том, что она основана на открытых стандартах и не требует какой-либо конкретной реализации модели или использующих ее клиентских приложений.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-118">A primary advantage of the REST model is that it is based on open standards and does not bind the implementation of the model or the client applications that access it to any specific implementation.</span></span> <span data-ttu-id="8ae1b-119">Например, веб-службу REST можно реализовать при помощи веб-API Microsoft ASP.NET, а клиентские приложения можно разработать с помощью любого языка и набора инструментов, позволяющего создавать HTTP-запросы и анализировать HTTP-ответы.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-119">For example, a REST web service could be implemented by using the Microsoft ASP.NET Web API, and client applications could be developed by using any language and toolset that can generate HTTP requests and parse HTTP responses.</span></span>

> [!NOTE]
> <span data-ttu-id="8ae1b-120">Модель REST не зависит от каких-либо базовых протоколов и не требует привязки к HTTP.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-120">REST is actually independent of any underlying protocol and is not necessarily tied to HTTP.</span></span> <span data-ttu-id="8ae1b-121">Однако в большинстве наиболее распространенных реализаций систем на основе REST в качестве протокола приложений для отправки и получения запросов используется HTTP.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-121">However, most common implementations of systems that are based on REST utilize HTTP as the application protocol for sending and receiving requests.</span></span> <span data-ttu-id="8ae1b-122">В этом документе основное внимание уделяется сопоставлению принципов REST с системами, использующими в работе протокол HTTP.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-122">This document focuses on mapping REST principles to systems designed to operate using HTTP.</span></span>
>
>

<span data-ttu-id="8ae1b-123">Модель REST использует схему переходов для представления объектов и служб (называющихся *ресурсами*) по сети.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-123">The REST model uses a navigational scheme to represent objects and services over a network (referred to as *resources*).</span></span> <span data-ttu-id="8ae1b-124">Во многих системах, реализующих REST, для передачи запросов с целью получения доступа к этим ресурсам обычно используется протокол HTTP.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-124">Many systems that implement REST typically use the HTTP protocol to transmit requests to access these resources.</span></span> <span data-ttu-id="8ae1b-125">В таких системах клиентское приложение отправляет запрос в виде универсального кода ресурса (URI), определяющего ресурс, и метод HTTP (чаще всего используются GET, POST, PUT или DELETE), определяющего операцию, выполняемую на указанном ресурсе.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-125">In these systems, a client application submits a request in the form of a URI that identifies a resource, and an HTTP method (the most common being GET, POST, PUT, or DELETE) that indicates the operation to be performed on that resource.</span></span>  <span data-ttu-id="8ae1b-126">Текст HTTP-запроса содержит данные, необходимые для выполнения операции.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-126">The body of the HTTP request contains the data required to perform the operation.</span></span> <span data-ttu-id="8ae1b-127">Важно понять, что концепция REST определяет модель запроса без отслеживания состояния.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-127">The important point to understand is that REST defines a stateless request model.</span></span> <span data-ttu-id="8ae1b-128">HTTP-запросы должны быть независимыми и могут создаваться в любом порядке, поэтому сохранение сведений о переходном состоянии между запросами не представляется возможным.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-128">HTTP requests should be independent and may occur in any order, so attempting to retain transient state information between requests is not feasible.</span></span>  <span data-ttu-id="8ae1b-129">Сведения хранятся только в самих ресурсах, и каждый запрос должен быть атомарной операцией.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-129">The only place where information is stored is in the resources themselves, and each request should be an atomic operation.</span></span> <span data-ttu-id="8ae1b-130">В сущности, модель REST реализует конечный автомат, в котором запрос проход через ресурс от одного четко определенного непереходного состояния к другому.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-130">Effectively, a REST model implements a finite state machine where a request transitions a resource from one well-defined non-transient state to another.</span></span>

> [!NOTE]
> <span data-ttu-id="8ae1b-131">Характер отдельных запросов в модели REST, не предусматривающий отслеживание состояния, позволяет создать высокомасштабируемую систему на основе этих принципов.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-131">The stateless nature of individual requests in the REST model enables a system constructed by following these principles to be highly scalable.</span></span> <span data-ttu-id="8ae1b-132">Нет необходимости сохранять сходство между клиентским приложением, создающим серию запросов, и обрабатывающими их веб-серверами.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-132">There is no need to retain any affinity between a client application making a series of requests and the specific web servers handling those requests.</span></span>
>
>

<span data-ttu-id="8ae1b-133">При реализации эффективной модели REST также крайне важно понять структуру связей между различными ресурсами, к которым модель предоставляет доступ.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-133">Another crucial point in implementing an effective REST model is to understand the relationships between the various resources to which the model provides access.</span></span> <span data-ttu-id="8ae1b-134">Как правило, эти ресурсы организованы в виде коллекций и связей.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-134">These resources are typically organized as collections and relationships.</span></span> <span data-ttu-id="8ae1b-135">Например, предположим, что быстрый анализ системы электронной коммерции выявляет наличие двух коллекций, которыми скорее всего будут пользоваться клиентские приложения: заказы и клиенты.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-135">For example, suppose that a quick analysis of an ecommerce system shows that there are two collections in which client applications are likely to be interested: orders and customers.</span></span> <span data-ttu-id="8ae1b-136">У каждого заказа и клиента должен быть собственный уникальный ключ для идентификации.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-136">Each order and customer should have its own unique key for identification purposes.</span></span> <span data-ttu-id="8ae1b-137">Универсальный код ресурса (URI) для доступа к коллекции заказов может быть довольно простым, например */orders*, как и URI для получения всех клиентов, например */customers*.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-137">The URI to access the collection of orders could be something as simple as */orders*, and similarly the URI for retrieving all customers could be */customers*.</span></span> <span data-ttu-id="8ae1b-138">При отправке HTTP-запроса GET на универсальный код ресурса (URI) */orders* возвращается список всех заказов в коллекции, закодированный в виде HTTP-ответа.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-138">Issuing an HTTP GET request to the */orders* URI should return a list representing all orders in the collection encoded as an HTTP response:</span></span>

```HTTP
GET http://adventure-works.com/orders HTTP/1.1
...
```

<span data-ttu-id="8ae1b-139">В ответе, приведенном ниже, заказы закодированы в виде структуры JSON-списка.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-139">The response shown below encodes the orders as a JSON list structure:</span></span>

```HTTP
HTTP/1.1 200 OK
...
Date: Fri, 22 Aug 2014 08:49:02 GMT
Content-Length: ...
[{"orderId":1,"orderValue":99.90,"productId":1,"quantity":1},{"orderId":2,"orderValue":10.00,"productId":4,"quantity":2},{"orderId":3,"orderValue":16.60,"productId":2,"quantity":4},{"orderId":4,"orderValue":25.90,"productId":3,"quantity":1},{"orderId":5,"orderValue":99.90,"productId":1,"quantity":1}]
```
<span data-ttu-id="8ae1b-140">Для получения отдельного заказа требуется указать его идентификатор из ресурса *orders*, например */orders/2*.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-140">To fetch an individual order requires specifying the identifier for the order from the *orders* resource, such as */orders/2*:</span></span>

```HTTP
GET http://adventure-works.com/orders/2 HTTP/1.1
...
```

```HTTP
HTTP/1.1 200 OK
...
Date: Fri, 22 Aug 2014 08:49:02 GMT
Content-Length: ...
{"orderId":2,"orderValue":10.00,"productId":4,"quantity":2}
```

> [!NOTE]
> <span data-ttu-id="8ae1b-141">Для простоты сведения в этих примерах возвращаются в виде текстовых JSON-данных.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-141">For simplicity, these examples show the information in responses being returned as JSON text data.</span></span> <span data-ttu-id="8ae1b-142">Однако ресурсы вполне могут содержать другие типы данных, поддерживаемые HTTP, например двоичные или зашифрованные данные. Тип данных указывается в строке "content-type" в HTTP-ответе.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-142">However, there is no reason why resources should not contain any other type of data supported by HTTP, such as binary or encrypted information; the content-type in the HTTP response should specify the type.</span></span> <span data-ttu-id="8ae1b-143">Кроме того, модель REST может возвращать одни и те же данные в разных форматах, таких как XML или JSON.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-143">Also, a REST model may be able to return the same data in different formats, such as XML or JSON.</span></span> <span data-ttu-id="8ae1b-144">В этом случае веб-служба должна иметь возможность согласовать содержимое с клиентским приложением, отправившим запрос.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-144">In this case, the web service should be able to perform content negotiation with the client making the request.</span></span> <span data-ttu-id="8ae1b-145">Запрос может включать заголовок *Accept*, указывающий на предпочтительный для клиентского приложения формат получения, а веб-служба должна попытаться по возможности выполнить это требование.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-145">The request can include an *Accept* header which specifies the preferred format that the client would like to receive and the web service should attempt to honor this format if at all possible.</span></span>
>
>

<span data-ttu-id="8ae1b-146">Обратите внимание, что в ответе на запрос REST используются стандартные коды состояния HTTP.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-146">Notice that the response from a REST request makes use of the standard HTTP status codes.</span></span> <span data-ttu-id="8ae1b-147">Например, запрос, возвращающий допустимые данные, должен включать код HTTP-ответа 200 (ОК), в то время как запрос, по которому не удалось найти или удалить указанный ресурс, должен вернуть ответ, включающий код состояния HTTP 404 (не найдено).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-147">For example, a request that returns valid data should include the HTTP response code 200 (OK), while a request that fails to find or delete a specified resource should return a response that includes the HTTP status code 404 (Not Found).</span></span>

## <a name="design-and-structure-of-a-restful-web-api"></a><span data-ttu-id="8ae1b-148">Схема и структура веб-API RESTful</span><span class="sxs-lookup"><span data-stu-id="8ae1b-148">Design and structure of a RESTful web API</span></span>
<span data-ttu-id="8ae1b-149">Залог разработки эффективного веб-API — простота и согласованность.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-149">The keys to designing a successful web API are simplicity and consistency.</span></span> <span data-ttu-id="8ae1b-150">Веб-API, обладающий этими двумя свойствами, упрощает создание клиентских приложений, которым требуется использовать API.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-150">A Web API that exhibits these two factors makes it easier to build client applications that need to consume the API.</span></span>

<span data-ttu-id="8ae1b-151">Основная задача веб-API RESTful — предоставление набора взаимосвязанных ресурсов и базовых операций, позволяющих приложению использовать эти ресурсы и беспрепятственно перемещаться между ними.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-151">A RESTful web API is focused on exposing a set of connected resources, and providing the core operations that enable an application to manipulate these resources and easily navigate between them.</span></span> <span data-ttu-id="8ae1b-152">По этой причине универсальные коды ресурсов (URI), составляющие стандартный веб-API RESTful, должны быть ориентированы на предоставляемые данные и использовать средства HTTP для работы с ними.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-152">For this reason, the URIs that constitute a typical RESTful web API should be oriented towards the data that it exposes, and use the facilities provided by HTTP to operate on this data.</span></span> <span data-ttu-id="8ae1b-153">Этот метод требует иного подхода, нежели тот, что обычно используется при разработки набора классов в объектно-ориентированном API, в основе которого, как правило, лежит поведение объектов и классов.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-153">This approach requires a different mindset from that typically employed when designing a set of classes in an object-oriented API which tends to be more motivated by the behavior of objects and classes.</span></span> <span data-ttu-id="8ae1b-154">Кроме того, веб-API RESTful должен характеризоваться отсутствием отслеживания состояния и быть независимым от операций, вызываемых в конкретной последовательности.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-154">Additionally, a RESTful web API should be stateless and not depend on operations being invoked in a particular sequence.</span></span> <span data-ttu-id="8ae1b-155">В следующих разделах описаны моменты, которые следует учесть при разработке веб-API RESTful.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-155">The following sections summarize the points you should consider when designing a RESTful web API.</span></span>

### <a name="organizing-the-web-api-around-resources"></a><span data-ttu-id="8ae1b-156">Организация структуры веб-API на основе ресурсов</span><span class="sxs-lookup"><span data-stu-id="8ae1b-156">Organizing the web API around resources</span></span>
> [!TIP]
> <span data-ttu-id="8ae1b-157">В основе универсальных кодов ресурсов (URI), предоставляемых веб-службой REST, должны лежать существительные (данные, к которым предоставляет доступ веб-API), а не глаголы (действия, которые приложение может выполнить с данными).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-157">The URIs exposed by a REST web service should be based on nouns (the data to which the web API provides access) and not verbs (what an application can do with the data).</span></span>
>
>

<span data-ttu-id="8ae1b-158">Сосредоточьтесь на бизнес-сущностях, предоставляемых веб-API.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-158">Focus on the business entities that the web API exposes.</span></span> <span data-ttu-id="8ae1b-159">Например, в веб-API, созданном для поддержки ранее описанной системы электронной коммерции, основные сущности — клиенты и заказы.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-159">For example, in a web API designed to support the ecommerce system described earlier, the primary entities are customers and orders.</span></span> <span data-ttu-id="8ae1b-160">Выполнение таких процессов, как размещение заказа, можно обеспечить путем предоставления операции HTTP POST, добавляющей сведения о заказе в список заказов для клиента.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-160">Processes such as the act of placing an order can be achieved by providing an HTTP POST operation that takes the order information and adds it to the list of orders for the customer.</span></span> <span data-ttu-id="8ae1b-161">Внутри системы операция POST может выполнять такие задачи, как проверка количества продукции на складе и выставление счетов клиенту.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-161">Internally, this POST operation can perform tasks such as checking stock levels, and billing the customer.</span></span> <span data-ttu-id="8ae1b-162">HTTP-ответ может указывать на успешность размещения заказа.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-162">The HTTP response can indicate whether the order was placed successfully or not.</span></span> <span data-ttu-id="8ae1b-163">Кроме того, обратите внимание, что ресурс не обязательно должен быть основан на одном физическом элементе данных.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-163">Also note that a resource does not have to be based on a single physical data item.</span></span> <span data-ttu-id="8ae1b-164">К примеру, ресурс заказа можно реализовать внутри системы с использованием сводных данных из множества строк, содержащихся в нескольких таблицах в реляционной базе данных, но представленных клиентскому приложению в виде единой сущности.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-164">As an example, an order resource might be implemented internally by using information aggregated from many rows spread across several tables in a relational database but presented to the client as a single entity.</span></span>

> [!TIP]
> <span data-ttu-id="8ae1b-165">Не следует создавать интерфейс REST, зеркально отображающий внутреннюю структуру предоставляемых данных или зависящий от нее.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-165">Avoid designing a REST interface that mirrors or depends on the internal structure of the data that it exposes.</span></span> <span data-ttu-id="8ae1b-166">Модель REST позволяет не только реализовывать простые операции CRUD (создание, чтение, обновление, удаление) в отдельных таблицах в реляционной базе данных.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-166">REST is about more than implementing simple CRUD (Create, Retrieve, Update, Delete) operations over separate tables in a relational database.</span></span> <span data-ttu-id="8ae1b-167">Задача модели REST — сопоставление бизнес-сущностей и операций, которые приложение может выполнить с ними, с физической реализацией этих сущностей. При этом физические сведения должны быть скрыты от клиентского приложения.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-167">The purpose of REST is to map business entities and the operations that an application can perform on these entities to the physical implementation of these entities, but a client should not be exposed to these physical details.</span></span>
>
>

<span data-ttu-id="8ae1b-168">Отдельные бизнес-сущности редко существуют изолированно (хотя это возможно для некоторых одноэлементых объектов) и чаще сгруппированы в коллекциях.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-168">Individual business entities rarely exist in isolation (although some singleton objects may exist), but instead tend to be grouped together into collections.</span></span> <span data-ttu-id="8ae1b-169">В рамках модели REST каждая сущность и коллекция являются ресурсами.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-169">In REST terms, each entity and each collection are resources.</span></span> <span data-ttu-id="8ae1b-170">В веб-API RESTful у каждой коллекции есть собственный универсальный код ресурса (URI) в веб-службе. При выполнении HTTP-запроса GET посредством универсального кода ресурса (URI) для коллекции возвращается список элементов в этой коллекции.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-170">In a RESTful web API, each collection has its own URI within the web service, and performing an HTTP GET request over a URI for a collection retrieves a list of items in that collection.</span></span> <span data-ttu-id="8ae1b-171">У каждого отдельного элемента также есть собственный универсальный код ресурса (URI). Приложение может отправлять дополнительный HTTP-запрос GET с использованием этого универсального кода ресурса (URI) для получения сведений о соответствующем элементе.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-171">Each individual item also has its own URI, and an application can submit another HTTP GET request using that URI to retrieve the details of that item.</span></span> <span data-ttu-id="8ae1b-172">Вам следует упорядочить универсальные коды ресурсов (URI) для коллекций и элементов в виде иерархии.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-172">You should organize the URIs for collections and items in a hierarchical manner.</span></span> <span data-ttu-id="8ae1b-173">В системе электронной коммерции универсальный код ресурса (URI) */customers* обозначает коллекцию клиента, а */customers/5* получает сведения для одного клиента из этой коллекции с идентификатором 5.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-173">In the ecommerce system, the URI */customers* denotes the customer’s collection, and */customers/5* retrieves the details for the single customer with the ID 5 from this collection.</span></span> <span data-ttu-id="8ae1b-174">Этот подход позволяет обеспечивать простоту веб-API.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-174">This approach helps to keep the web API intuitive.</span></span>

> [!TIP]
> <span data-ttu-id="8ae1b-175">Используйте единое соглашение об именовании в универсальных кодах ресурсов (URI). В целом это помогает использовать существительные во множественном числе для универсальных кодов ресурсов (URI), ссылающихся на коллекции.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-175">Adopt a consistent naming convention in URIs; in general it helps to use plural nouns for URIs that reference collections.</span></span>
>
>

<span data-ttu-id="8ae1b-176">Вам также следует продумать связи между разными типами ресурсов и способы предоставления этих связей.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-176">You also need to consider the relationships between different types of resources and how you might expose these associations.</span></span> <span data-ttu-id="8ae1b-177">Например, клиенты могут размещать ноль и более заказов.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-177">For example, customers may place zero or more orders.</span></span> <span data-ttu-id="8ae1b-178">Естественный способ представления этой связи — использование универсального кода ресурса (URI), такого как */customers/5/orders*, чтобы найти все заказы для клиента 5.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-178">A natural way to represent this relationship would be through a URI such as */customers/5/orders* to find all the orders for customer 5.</span></span> <span data-ttu-id="8ae1b-179">Вы также можете представить связь между заказом и конкретным клиентом посредством универсального кода ресурса (URI), такого как */orders/99/customer*, чтобы найти клиента для заказа 99, но чрезмерное расширение этой модели может вызвать трудности.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-179">You might also consider representing the association from an order back to a specific customer through a URI such as */orders/99/customer* to find the customer for order 99, but extending this model too far can become cumbersome to implement.</span></span> <span data-ttu-id="8ae1b-180">Более рациональное решение — предоставить ссылки с возможностью перехода на связанные ресурсы, такие как клиент, в тексте HTTP-ответа, возвращаемого при отправке запроса на заказ.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-180">A better solution is to provide navigable links to associated resources, such as the customer, in the body of the HTTP response message returned when the order is queried.</span></span> <span data-ttu-id="8ae1b-181">Это механизм более подробно описан далее в этом руководстве в разделе "Использование подхода HATEOAS для обеспечения возможности перехода к связанным ресурсам".</span><span class="sxs-lookup"><span data-stu-id="8ae1b-181">This mechanism is described in more detail in the section Using the HATEOAS Approach to Enable Navigation To Related Resources later in this guidance.</span></span>

<span data-ttu-id="8ae1b-182">В более сложных системах может быть гораздо больше типов сущностей, и очевидным решением может показаться предоставление универсальных кодов ресурсов (URI), позволяющих клиентскому приложению переходить между несколькими уровнями связей, например */customers/1/orders/99/products* для получения списка продуктов в заказе 99, размещенном клиентом 1.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-182">In more complex systems there may be many more types of entity, and it can be tempting to provide URIs that enable a client application to navigate through several levels of relationships, such as */customers/1/orders/99/products* to obtain the list of products in order 99 placed by customer 1.</span></span> <span data-ttu-id="8ae1b-183">Однако такой уровень сложности трудно обслуживать и адаптировать в случае дальнейшего изменения связей между ресурсами.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-183">However, this level of complexity can be difficult to maintain and is inflexible if the relationships between resources change in the future.</span></span> <span data-ttu-id="8ae1b-184">Вместо этого постарайтесь сделать универсальные коды ресурсов (URI) максимально простыми.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-184">Rather, you should seek to keep URIs relatively simple.</span></span> <span data-ttu-id="8ae1b-185">Следует помнить, что как только у приложения появляется ссылка на ресурс, оно может использовать эту ссылку для поиска элементов, связанных с указанным ресурсом.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-185">Bear in mind that once an application has a reference to a resource, it should be possible to use this reference to find items related to that resource.</span></span> <span data-ttu-id="8ae1b-186">Предыдущий запрос можно заменить на универсальный код ресурса (URI) */customers/1/orders* для поиска всех заказов для клиента 1, а затем запросить универсальный код ресурса (URI) */orders/99/products* для поиска продуктов в указанном порядке (предполагая, что заказ 99 размещен клиентом 1).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-186">The preceding query can be replaced with the URI */customers/1/orders* to find all the orders for customer 1, and then query the URI */orders/99/products* to find the products in this order (assuming order 99 was placed by customer 1).</span></span>

> [!TIP]
> <span data-ttu-id="8ae1b-187">Старайтесь использовать универсальные коды ресурсов не сложнее *collection/item/collection*.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-187">Avoid requiring resource URIs more complex than *collection/item/collection*.</span></span>
>
>

<span data-ttu-id="8ae1b-188">Кроме того, следует учесть, что все веб-запросы увеличивают нагрузку на веб-сервер, которая растет вместе с числом запросов.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-188">Another point to consider is that all web requests impose a load on the web server, and the greater the number of requests the bigger the load.</span></span> <span data-ttu-id="8ae1b-189">Старайтесь определять ресурсы таким образом, чтобы избежать создания "избыточных" веб-API, предоставляющих множество небольших ресурсов.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-189">You should attempt to define your resources to avoid “chatty” web APIs that expose a large number of small resources.</span></span> <span data-ttu-id="8ae1b-190">Такой API может потребовать от клиентского приложения отправки нескольких запросов для поиска всех необходимых данных.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-190">Such an API may require a client application to submit multiple requests to find all the data that it requires.</span></span> <span data-ttu-id="8ae1b-191">Возможно, следует денормализовать данные и объединить связанную информацию в более крупные ресурсы, которые можно получить с помощью одного запроса.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-191">It may be beneficial to denormalize data and combine related information together into bigger resources that can be retrieved by issuing a single request.</span></span> <span data-ttu-id="8ae1b-192">Однако следует сохранять равновесие в этом подходе, чтобы избежать получения чрезмерного объема данных, потребность в которых у клиентского приложения возникает нечасто.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-192">However, you need to balance this approach against the overhead of fetching data that might not be frequently required by the client.</span></span> <span data-ttu-id="8ae1b-193">Получение крупных объектов может увеличить задержку запроса и повлечь за собой дополнительные затраты пропускной способности с малой выгодой в случае редкого использования дополнительных данных.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-193">Retrieving large objects can increase the latency of a request and incur additional bandwidth costs for little advantage if the additional data is not often used.</span></span>

<span data-ttu-id="8ae1b-194">Избегайте зависимостей между веб-API и структурой, типом или расположением базовых ресурсов данных.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-194">Avoid introducing dependencies between the web API to the structure, type, or location of the underlying data sources.</span></span> <span data-ttu-id="8ae1b-195">Например, если данные находятся в реляционной базе данных, веб-API не требуется предоставлять каждую таблицу в виде коллекции ресурсов.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-195">For example, if your data is located in a relational database, the web API does not need to expose each table as a collection of resources.</span></span> <span data-ttu-id="8ae1b-196">Представьте веб-API в виде абстракции базы данных и при необходимости создайте уровень сопоставления между базой данных и веб-API.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-196">Think of the web API as an abstraction of the database, and if necessary introduce a mapping layer between the database and the web API.</span></span> <span data-ttu-id="8ae1b-197">Таким образом, при изменении структуры или реализации базы данных (например, при перемещении от реляционной базы данных, содержащей коллекцию нормализованных таблиц, к денормализованной системе хранения NoSQL, такой как база данных документов) клиентские приложения изолированы от вносимых изменений.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-197">In this way, if the design or implementation of the database changes (for example, you move from a relational database containing a collection of normalized tables to a denormalized NoSQL storage system such as a document database) client applications are insulated from these changes.</span></span>

> [!TIP]
> <span data-ttu-id="8ae1b-198">Источником данных, лежащим в основе веб-API, не обязательно должно быть хранилище данных. Вместо него можно использовать другую службу или бизнес-приложение, либо приложение прежних версий, выполняемое локально внутри организации.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-198">The source of the data that underpins a web API does not have to be a data store; it could be another service or line-of-business application or even a legacy application running on-premises within an organization.</span></span>
>
>

<span data-ttu-id="8ae1b-199">Наконец, сопоставление каждой операции, реализованной веб-API, с конкретным источником не всегда возможно.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-199">Finally, it might not be possible to map every operation implemented by a web API to a specific resource.</span></span> <span data-ttu-id="8ae1b-200">Такие *безресурсные* сценарии можно обрабатывать с помощью HTTP-запросов GET, вызывающих определенную функцию и возвращающих результаты в виде ответного HTTP-сообщения.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-200">You can handle such *non-resource* scenarios through HTTP GET requests that invoke a piece of functionality and return the results as an HTTP response message.</span></span> <span data-ttu-id="8ae1b-201">Веб-API, реализующий простые расчетные операции, такие как добавление и вычитание, может предоставить универсальные коды ресурсов (URI), представляющие эти операции в виде псевдоресурсов, и использовать строку запроса для указания требуемых параметров.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-201">A web API that implements simple calculator-style operations such as add and subtract could provide URIs that expose these operations as pseudo resources and utilize the query string to specify the parameters required.</span></span> <span data-ttu-id="8ae1b-202">Например, запрос GET для универсального кода ресурса (URI) */add?operand1=99&operand2=1* может вернуть ответное сообщение, содержащее значение 100, а запрос GET для универсального кода ресурса (URI) */subtract?operand1=50&operand2=20* может вернуть ответное сообщение, содержащее значение 30.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-202">For example a GET request to the URI */add?operand1=99&operand2=1* could return a response message with the body containing the value 100, and GET request to the URI */subtract?operand1=50&operand2=20* could return a response message with the body containing the value 30.</span></span> <span data-ttu-id="8ae1b-203">Однако следует использовать эти формы универсальных кодов ресурсов (URI) с осторожностью.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-203">However, only use these forms of URIs sparingly.</span></span>

### <a name="defining-operations-in-terms-of-http-methods"></a><span data-ttu-id="8ae1b-204">Определение операций с точки зрения методов HTTP</span><span class="sxs-lookup"><span data-stu-id="8ae1b-204">Defining operations in terms of HTTP methods</span></span>
<span data-ttu-id="8ae1b-205">Протокол HTTP определяет несколько методов, назначающих запросу семантическое значение.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-205">The HTTP protocol defines a number of methods that assign semantic meaning to a request.</span></span> <span data-ttu-id="8ae1b-206">Ниже приведены наиболее распространенные методы HTTP, используемые большинством веб-API RESTful:</span><span class="sxs-lookup"><span data-stu-id="8ae1b-206">The common HTTP methods used by most RESTful web APIs are:</span></span>

* <span data-ttu-id="8ae1b-207">**GET.** Возвращает копию ресурса по указанному универсальному коду ресурса (URI).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-207">**GET**, to retrieve a copy of the resource at the specified URI.</span></span> <span data-ttu-id="8ae1b-208">Текст ответного сообщения содержит сведения о запрашиваемом ресурсе.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-208">The body of the response message contains the details of the requested resource.</span></span>
* <span data-ttu-id="8ae1b-209">**POST.** Создает новый ресурс по указанному универсальному коду ресурса (URI).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-209">**POST**, to create a new resource at the specified URI.</span></span> <span data-ttu-id="8ae1b-210">Текст запроса содержит сведения о новом ресурсе.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-210">The body of the request message provides the details of the new resource.</span></span> <span data-ttu-id="8ae1b-211">Обратите внимание, что метод POST также можно использовать для запуска операций, не относящихся непосредственно к созданию ресурсов.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-211">Note that POST can also be used to trigger operations that don't actually create resources.</span></span>
* <span data-ttu-id="8ae1b-212">**PUT.** Заменяет или обновляет ресурс по указанному универсальному коду ресурса (URI).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-212">**PUT**, to replace or update the resource at the specified URI.</span></span> <span data-ttu-id="8ae1b-213">В тексте запроса указывается изменяемый ресурс и устанавливаемые значения.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-213">The body of the request message specifies the resource to be modified and the values to be applied.</span></span>
* <span data-ttu-id="8ae1b-214">**DELETE.** Удаляет ресурс по указанному универсальному коду ресурса (URI).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-214">**DELETE**, to remove the resource at the specified URI.</span></span>

> [!NOTE]
> <span data-ttu-id="8ae1b-215">Протокол HTTP также определяет другие менее распространенные методы, такие как PATCH, используемый для запроса выборочных обновлений ресурса, HEAD, используемый для запроса описания ресурса, OPTIONS, позволяющий клиентскому приложению получать сведения о параметрах обмена данными, поддерживаемых сервером, и TRACE, позволяющий клиентскому приложению запрашивать сведения, которые можно использовать в целях тестирования и диагностики.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-215">The HTTP protocol also defines other less commonly-used methods, such as PATCH which is used to request selective updates to a resource, HEAD which is used to request a description of a resource, OPTIONS which enables a client information to obtain information about the communication options supported by the server, and TRACE which allows a client to request information that it can use for testing and diagnostics purposes.</span></span>
>
>

<span data-ttu-id="8ae1b-216">Результат конкретного запроса должен зависеть от того, является ли целевой ресурс коллекцией или отдельным элементов.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-216">The effect of a specific request should depend on whether the resource to which it is applied is a collection or an individual item.</span></span> <span data-ttu-id="8ae1b-217">В следующей таблице перечислены общие соглашения, принятые в большинстве реализаций RESTful, на примере системы электронной коммерции.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-217">The following table summarizes the common conventions adopted by most RESTful implementations using the ecommerce example.</span></span> <span data-ttu-id="8ae1b-218">Обратите внимание, что возможность реализации некоторых запросов зависит от конкретного сценария.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-218">Note that not all of these requests might be implemented; it depends on the specific scenario.</span></span>

| <span data-ttu-id="8ae1b-219">**Ресурс**</span><span class="sxs-lookup"><span data-stu-id="8ae1b-219">**Resource**</span></span> | <span data-ttu-id="8ae1b-220">**POST**</span><span class="sxs-lookup"><span data-stu-id="8ae1b-220">**POST**</span></span> | <span data-ttu-id="8ae1b-221">**GET**</span><span class="sxs-lookup"><span data-stu-id="8ae1b-221">**GET**</span></span> | <span data-ttu-id="8ae1b-222">**PUT**</span><span class="sxs-lookup"><span data-stu-id="8ae1b-222">**PUT**</span></span> | <span data-ttu-id="8ae1b-223">**DELETE**</span><span class="sxs-lookup"><span data-stu-id="8ae1b-223">**DELETE**</span></span> |
| --- | --- | --- | --- | --- |
| <span data-ttu-id="8ae1b-224">/customers</span><span class="sxs-lookup"><span data-stu-id="8ae1b-224">/customers</span></span> |<span data-ttu-id="8ae1b-225">Создание нового клиента</span><span class="sxs-lookup"><span data-stu-id="8ae1b-225">Create a new customer</span></span> |<span data-ttu-id="8ae1b-226">Получение всех клиентов</span><span class="sxs-lookup"><span data-stu-id="8ae1b-226">Retrieve all customers</span></span> |<span data-ttu-id="8ae1b-227">Массовое обновление клиентов (*если реализовано*)</span><span class="sxs-lookup"><span data-stu-id="8ae1b-227">Bulk update of customers (*if implemented*)</span></span> |<span data-ttu-id="8ae1b-228">Удаление всех клиентов</span><span class="sxs-lookup"><span data-stu-id="8ae1b-228">Remove all customers</span></span> |
| <span data-ttu-id="8ae1b-229">/customers/1</span><span class="sxs-lookup"><span data-stu-id="8ae1b-229">/customers/1</span></span> |<span data-ttu-id="8ae1b-230">Ошибка</span><span class="sxs-lookup"><span data-stu-id="8ae1b-230">Error</span></span> |<span data-ttu-id="8ae1b-231">Получение сведений для клиента 1</span><span class="sxs-lookup"><span data-stu-id="8ae1b-231">Retrieve the details for customer 1</span></span> |<span data-ttu-id="8ae1b-232">Обновление сведений клиента 1, если он существует; в противном случае — возврат сообщения об ошибке</span><span class="sxs-lookup"><span data-stu-id="8ae1b-232">Update the details of customer 1 if it exists, otherwise return an error</span></span> |<span data-ttu-id="8ae1b-233">Удаление клиента 1</span><span class="sxs-lookup"><span data-stu-id="8ae1b-233">Remove customer 1</span></span> |
| <span data-ttu-id="8ae1b-234">/customers/1/orders</span><span class="sxs-lookup"><span data-stu-id="8ae1b-234">/customers/1/orders</span></span> |<span data-ttu-id="8ae1b-235">Создание нового заказа для клиента 1</span><span class="sxs-lookup"><span data-stu-id="8ae1b-235">Create a new order for customer 1</span></span> |<span data-ttu-id="8ae1b-236">Получение всех заказов для клиента 1</span><span class="sxs-lookup"><span data-stu-id="8ae1b-236">Retrieve all orders for customer 1</span></span> |<span data-ttu-id="8ae1b-237">Массовое обновление заказов для клиента 1 (*если реализовано*)</span><span class="sxs-lookup"><span data-stu-id="8ae1b-237">Bulk update of orders for customer 1 (*if implemented*)</span></span> |<span data-ttu-id="8ae1b-238">Удаление всех заказов для клиента 1 (*если реализовано*)</span><span class="sxs-lookup"><span data-stu-id="8ae1b-238">Remove all orders for customer 1(*if implemented*)</span></span> |

<span data-ttu-id="8ae1b-239">Цель запросов GET и DELETE вполне ясна, однако в отношении цели и результатов запросов POST и PUT может возникать неопределенность.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-239">The purpose of GET and DELETE requests are relatively straightforward, but there is scope for confusion concerning the purpose and effects of POST and PUT requests.</span></span>

<span data-ttu-id="8ae1b-240">Запрос POST должен создавать новый ресурс на основе данных, предоставленных в тексте запроса.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-240">A POST request should create a new resource with data provided in the body of the request.</span></span> <span data-ttu-id="8ae1b-241">В модели REST запросы POST часто применяются к ресурсам-коллекциям. При этом новый ресурс добавляется в коллекцию.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-241">In the REST model, you frequently apply POST requests to resources that are collections; the new resource is added to the collection.</span></span>

> [!NOTE]
> <span data-ttu-id="8ae1b-242">Вы также можете определять запросы POST, запускающие какую-либо функцию и при этом не обязательно возвращающие данные. Эти типы запросов можно применять к коллекциям.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-242">You can also define POST requests that trigger some functionality (and that don't necessarily return data), and these types of request can be applied to collections.</span></span> <span data-ttu-id="8ae1b-243">Например, вы можете использовать запрос POST для передачи расписания службе обработки платежных ведомостей и получения вычисленной суммы налогов в качестве ответа.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-243">For example you could use a POST request to pass a timesheet to a payroll processing service and get the calculated taxes back as a response.</span></span>
>
>

<span data-ttu-id="8ae1b-244">Запрос PUT предназначен для изменения существующего ресурса.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-244">A PUT request is intended to modify an existing resource.</span></span> <span data-ttu-id="8ae1b-245">Если указанный ресурс не существует, запрос PUT может вернуть сообщение об ошибке (в некоторых случаях он может фактически создать ресурс).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-245">If the specified resource does not exist, the PUT request could return an error (in some cases, it might actually create the resource).</span></span> <span data-ttu-id="8ae1b-246">Запросы PUT чаще всего применяются к ресурсам-отдельным элементам (таким как конкретный клиент или заказ). Их также можно применять к коллекциям, хотя подобная практика менее распространена.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-246">PUT requests are most frequently applied to resources that are individual items (such as a specific customer or order), although they can be applied to collections, although this is less-commonly implemented.</span></span> <span data-ttu-id="8ae1b-247">Обратите внимание, что запросы PUT идемпотентны, в отличие от запросов POST. Если приложение многократно отправляет один и тот же запрос PUT, результаты всегда должны быть одинаковыми (одинаковые значения будут применяться для одного и того же ресурса), но если приложение повторно отправляет один и тот же запрос POST, в результате будут созданы несколько ресурсов.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-247">Note that PUT requests are idempotent whereas POST requests are not; if an application submits the same PUT request multiple times the results should always be the same (the same resource will be modified with the same values), but if an application repeats the same POST request the result will be the creation of multiple resources.</span></span>

> [!NOTE]
> <span data-ttu-id="8ae1b-248">Строго говоря, HTTP-запрос PUT заменяет существующий ресурс указанным в тексте запроса.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-248">Strictly speaking, an HTTP PUT request replaces an existing resource with the resource specified in the body of the request.</span></span> <span data-ttu-id="8ae1b-249">Если требуется изменить лишь часть свойств ресурса, не затрагивая остальные свойства, необходимо использовать HTTP-запрос PATCH.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-249">If the intention is to modify a selection of properties in a resource but leave other properties unchanged, then this should be implemented by using an HTTP PATCH request.</span></span> <span data-ttu-id="8ae1b-250">Однако во многих реализациях RESTful это правило не всегда соблюдается и в обеих ситуациях используется запрос PUT.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-250">However, many RESTful implementations relax this rule and use PUT for both situations.</span></span>
>
>

### <a name="processing-http-requests"></a><span data-ttu-id="8ae1b-251">Обработка HTTP-запросов</span><span class="sxs-lookup"><span data-stu-id="8ae1b-251">Processing HTTP requests</span></span>
<span data-ttu-id="8ae1b-252">Данные, включенные клиентским приложением во множество HTTP-запросов, и соответствующие ответные сообщения от веб-сервера можно представить в различных форматах (или типах мультимедиа).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-252">The data included by a client application in many HTTP requests, and the corresponding response messages from the web server, could be presented in a variety of formats (or media types).</span></span> <span data-ttu-id="8ae1b-253">Например, данные, содержащие сведения для клиента или заказа, можно предоставить в формате XML, JSON или другом закодированном и сжатом формате.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-253">For example, the data that specifies the details for a customer or order could be provided as XML, JSON, or some other encoded and compressed format.</span></span> <span data-ttu-id="8ae1b-254">Веб-API RESTful должен поддерживать различные типы носителей, согласно требованиям клиентского приложения, отправляющего запрос.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-254">A RESTful web API should support different media types as requested by the client application that submits a request.</span></span>

<span data-ttu-id="8ae1b-255">При отправке запроса, возвращающего данные в тексте сообщения, клиентское приложение может указать поддерживаемые типы носителей в заголовке "Accept" запроса.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-255">When a client application sends a request that returns data in the body of a message, it can specify the media types it can handle in the Accept header of the request.</span></span> <span data-ttu-id="8ae1b-256">Следующий код демонстрирует HTTP-запрос GET, который получает сведения о заказе 2 и требует ответа в формате JSON (клиентскому приложению нужно проверить тип данных в ответе и убедиться, что данные получены в правильном формате):</span><span class="sxs-lookup"><span data-stu-id="8ae1b-256">The following code illustrates an HTTP GET request that retrieves the details of order 2 and requests the result to be returned as JSON (the client should still examine the media type of the data in the response to verify the format of the data returned):</span></span>

```HTTP
GET http://adventure-works.com/orders/2 HTTP/1.1
...
Accept: application/json
...
```

<span data-ttu-id="8ae1b-257">Если веб-сервер поддерживает этот тип носителя, он может вернуть ответ, включающий заголовок "Content-Type", который указывает формат данных в тексте сообщения:</span><span class="sxs-lookup"><span data-stu-id="8ae1b-257">If the web server supports this media type, it can reply with a response that includes Content-Type header that specifies the format of the data in the body of the message:</span></span>

> [!NOTE]
> <span data-ttu-id="8ae1b-258">Для максимального взаимодействия типы носителей, указанные в заголовках "Accept" и "Content-Type", должны быть распознанными MIME-типами, а не пользовательскими типами носителей.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-258">For maximum interoperability, the media types referenced in the Accept and Content-Type headers should be recognized MIME types rather than some custom media type.</span></span>
>
>

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"orderID":2,"productID":4,"quantity":2,"orderValue":10.00}
```

<span data-ttu-id="8ae1b-259">Если веб-сервер не поддерживает запрашиваемый тип носителя, он может отправить данные в другом формате.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-259">If the web server does not support the requested media type, it can send the data in a different format.</span></span> <span data-ttu-id="8ae1b-260">В любом случае он должен указать тип носителя (например, *application/json*) в заголовке Content-Type.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-260">IN all cases it must specify the media type (such as *application/json*) in the Content-Type header.</span></span> <span data-ttu-id="8ae1b-261">Клиентское приложение отвечает за анализ ответного сообщения и правильную интерпретацию результатов в тексте сообщения.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-261">It is the responsibility of the client application to parse the response message and interpret the results in the message body appropriately.</span></span>

<span data-ttu-id="8ae1b-262">Обратите внимание, что в этом примере веб-сервер успешно получает запрашиваемые данные и сообщает об успешном завершении операции путем передачи кода состояния 200 в заголовке ответа.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-262">Note that in this example, the web server successfully retrieves the requested data and indicates success by passing back a status code of 200 in the response header.</span></span> <span data-ttu-id="8ae1b-263">Если соответствующие данные не обнаружены, веб-сервер должен вернуть код состояния 404 (не найдено), а текст ответного сообщения может содержать дополнительные сведения.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-263">If no matching data is found, it should instead return a status code of 404 (not found) and the body of the response message can contain additional information.</span></span> <span data-ttu-id="8ae1b-264">Формат этих сведений указывается в заголовке "Content-Type", как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="8ae1b-264">The format of this information is specified by the Content-Type header, as shown in the following example:</span></span>

```HTTP
GET http://adventure-works.com/orders/222 HTTP/1.1
...
Accept: application/json
...
```

<span data-ttu-id="8ae1b-265">Заказ 222 не существует, поэтому ответное сообщение выглядит следующим образом:</span><span class="sxs-lookup"><span data-stu-id="8ae1b-265">Order 222 does not exist, so the response message looks like this:</span></span>

```HTTP
HTTP/1.1 404 Not Found
...
Content-Type: application/json; charset=utf-8
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"message":"No such order"}
```

<span data-ttu-id="8ae1b-266">При отправке HTTP-запроса PUT для обновления ресурса приложение указывает универсальный код ресурса (URI) и предоставляет изменяемые данные в тексте запроса.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-266">When an application sends an HTTP PUT request to update a resource, it specifies the URI of the resource and provides the data to be modified in the body of the request message.</span></span> <span data-ttu-id="8ae1b-267">Приложение также должно указать формат этих данных с помощью заголовка "Content-Type".</span><span class="sxs-lookup"><span data-stu-id="8ae1b-267">It should also specify the format of this data by using the Content-Type header.</span></span> <span data-ttu-id="8ae1b-268">Для текстовой информации часто используется формат *application/x-www-form-urlencoded*, включающий набор пар "имя — значение", разделенных символом &.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-268">A common format used for text-based information is *application/x-www-form-urlencoded*, which comprises a set of name/value pairs separated by the & character.</span></span> <span data-ttu-id="8ae1b-269">В следующем примере показан HTTP-запрос PUT, изменяющий сведения в заказе 1:</span><span class="sxs-lookup"><span data-stu-id="8ae1b-269">The next example shows an HTTP PUT request that modifies the information in order 1:</span></span>

```HTTP
PUT http://adventure-works.com/orders/1 HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
ProductID=3&Quantity=5&OrderValue=250
```

<span data-ttu-id="8ae1b-270">Если изменение прошло успешно, в идеале должен вернуться ответ с кодом состояния HTTP 204, указывающим на успешное завершение процесса и отсутствие дополнительных сведений в тексте ответа.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-270">If the modification is successful, it should ideally respond with an HTTP 204 status code, indicating that the process has been successfully handled, but that the response body contains no further information.</span></span> <span data-ttu-id="8ae1b-271">Заголовок "Location" в ответе содержит универсальный код (URI) обновленного ресурса:</span><span class="sxs-lookup"><span data-stu-id="8ae1b-271">The Location header in the response contains the URI of the newly updated resource:</span></span>

```HTTP
HTTP/1.1 204 No Content
...
Location: http://adventure-works.com/orders/1
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
```

> [!TIP]
> <span data-ttu-id="8ae1b-272">Если данные в HTTP-запросе PUT включают сведения о дате и времени, убедитесь, что ваша веб-служба принимает сведения о дате и времени, отформатированные согласно стандарту ISO 8601.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-272">If the data in an HTTP PUT request message includes date and time information, make sure that your web service accepts dates and times formatted following the ISO 8601 standard.</span></span>
>
>

<span data-ttu-id="8ae1b-273">Если ресурс, который требуется обновить, не существует, веб-сервер может ответить сообщением "Не найдено", как было описано выше.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-273">If the resource to be updated does not exist, the web server can respond with a Not Found response as described earlier.</span></span> <span data-ttu-id="8ae1b-274">Кроме того, если сервер фактически создает сам объект, он может вернуть коды состояния HTTP 200 (ОК) или HTTP 201 (создано), а текст ответа может содержать данные для нового ресурса.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-274">Alternatively, if the server actually creates the object itself it could return the status codes HTTP 200 (OK) or HTTP 201 (Created) and the response body could contain the data for the new resource.</span></span> <span data-ttu-id="8ae1b-275">Если в заголовке "Content-Type" запроса указан формат данных, не поддерживаемый веб-сервером, сервер должен вернуть ответ с кодом состояния HTTP 415 (неподдерживаемый тип носителя).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-275">If the Content-Type header of the request specifies a data format that the web server cannot handle, it should respond with HTTP status code 415 (Unsupported Media Type).</span></span>

> [!TIP]
> <span data-ttu-id="8ae1b-276">Рассмотрите возможность реализации массовых HTTP-операций PUT, поддерживающих пакетные обновления нескольких ресурсов в коллекции.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-276">Consider implementing bulk HTTP PUT operations that can batch updates to multiple resources in a collection.</span></span> <span data-ttu-id="8ae1b-277">В запросе PUT должен быть указан универсальный код ресурса (URI) коллекции, а текст запроса должен содержать сведения о ресурсах, которые требуется изменить.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-277">The PUT request should specify the URI of the collection, and the request body should specify the details of the resources to be modified.</span></span> <span data-ttu-id="8ae1b-278">Такой подход помогает сократить избыточность и повысить производительность.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-278">This approach can help to reduce chattiness and improve performance.</span></span>
>
>

<span data-ttu-id="8ae1b-279">Формат HTTP-запросов POST, создающих новые ресурсы, аналогичен формату запросов PUT: текст сообщения содержит сведения о новом ресурсе, который требуется добавить.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-279">The format of an HTTP POST requests that create new resources are similar to those of PUT requests; the message body contains the details of the new resource to be added.</span></span> <span data-ttu-id="8ae1b-280">Однако универсальный код ресурса (URI), как правило, указывает коллекцию, в которую следует добавить ресурс.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-280">However, the URI typically specifies the collection to which the resource should be added.</span></span> <span data-ttu-id="8ae1b-281">В следующем примере создается новый заказ, который затем помещается в коллекцию заказов:</span><span class="sxs-lookup"><span data-stu-id="8ae1b-281">The following example creates a new order and adds it to the orders collection:</span></span>

```HTTP
POST http://adventure-works.com/orders HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
productID=5&quantity=15&orderValue=400
```

<span data-ttu-id="8ae1b-282">При успешном выполнении запроса веб-сервер должен отправить ответное сообщение с кодом состояния HTTP 201 (создано).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-282">If the request is successful, the web server should respond with a message code with HTTP status code 201 (Created).</span></span> <span data-ttu-id="8ae1b-283">Заголовок "Location" должен содержать универсальный код (URI) созданного ресурса, а текст ответа — копию нового ресурса. Заголовок "Content-Type" указывает формат этих данных:</span><span class="sxs-lookup"><span data-stu-id="8ae1b-283">The Location header should contain the URI of the newly created resource, and the body of the response should contain a copy of the new resource; the Content-Type header specifies the format of this data:</span></span>

```HTTP
HTTP/1.1 201 Created
...
Content-Type: application/json; charset=utf-8
Location: http://adventure-works.com/orders/99
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"orderID":99,"productID":5,"quantity":15,"orderValue":400}
```

> [!TIP]
> <span data-ttu-id="8ae1b-284">Если данные в запросе PUT или POST неверны, веб-сервер должен отправить ответное сообщение с кодом состояния HTTP 400 (неверный запрос).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-284">If the data provided by a PUT or POST request is invalid, the web server should respond with a message with HTTP status code 400 (Bad Request).</span></span> <span data-ttu-id="8ae1b-285">Текст этого сообщения может содержать дополнительные сведения о проблеме, связанной с запросом, и ожидаемых форматах, либо ссылку на URL-адрес с дополнительными сведениями.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-285">The body of this message can contain additional information about the problem with the request and the formats expected, or it can contain a link to a URL that provides more details.</span></span>
>
>

<span data-ttu-id="8ae1b-286">Для удаления ресурса HTTP-запрос DELETE предоставляет универсальный код ресурса (URI), который требуется удалить.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-286">To remove a resource, an HTTP DELETE request simply provides the URI of the resource to be deleted.</span></span> <span data-ttu-id="8ae1b-287">В следующем примере предпринимается попытка удаления заказа 99:</span><span class="sxs-lookup"><span data-stu-id="8ae1b-287">The following example attempts to remove order 99:</span></span>

```HTTP
DELETE http://adventure-works.com/orders/99 HTTP/1.1
...
```

<span data-ttu-id="8ae1b-288">Если операция удаления прошла успешно, веб-сервер должен отправить ответ с кодом состояния HTTP 204, указывающим на успешное завершение процесса и отсутствие дополнительных сведений (такой же ответ возвращается при успешном выполнении операции PUT, но в этом случае в ответе нет заголовка "Location", поскольку ресурс больше не существует). Запрос DELETE может также вернуть код состояния HTTP 200 (ОК) или 202 (принято), если удаление выполняется асинхронно.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-288">If the delete operation is successful, the web server should respond with HTTP status code 204, indicating that the process has been successfully handled, but that the response body contains no further information (this is the same response returned by a successful PUT operation, but without a Location header as the resource no longer exists.) It is also possible for a DELETE request to return HTTP status code 200 (OK) or 202 (Accepted) if the deletion is performed asynchronously.</span></span>

```HTTP
HTTP/1.1 204 No Content
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
```

<span data-ttu-id="8ae1b-289">Если ресурс не найден, веб-сервер должен вернуть сообщение с кодом 404 (не найдено).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-289">If the resource is not found, the web server should return a 404 (Not Found) message instead.</span></span>

> [!TIP]
> <span data-ttu-id="8ae1b-290">Если требуется удалить все ресурсы в коллекции, назначьте HTTP-запрос DELETE для универсального кода ресурса (URI) коллекции, вместо того чтобы вынуждать приложение по очереди удалять каждый ресурс из коллекции.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-290">If all the resources in a collection need to be deleted, enable an HTTP DELETE request to be specified for the URI of the collection rather than forcing an application to remove each resource in turn from the collection.</span></span>
>
>

### <a name="filtering-and-paginating-data"></a><span data-ttu-id="8ae1b-291">Фильтрация и разбивка данных на страницы</span><span class="sxs-lookup"><span data-stu-id="8ae1b-291">Filtering and paginating data</span></span>
<span data-ttu-id="8ae1b-292">Старайтесь поддерживать максимальную простоту и удобство универсальных кодов ресурсов (URI).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-292">You should endeavor to keep the URIs simple and intuitive.</span></span> <span data-ttu-id="8ae1b-293">Предоставление коллекции ресурсов через один универсальный код ресурса (URI) упрощает эту задачу, но может привести к тому, что приложения будут получать крупные объемы данных, когда нужно лишь подмножество информации.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-293">Exposing a collection of resources through a single URI assists in this respect, but it can lead to applications fetching large amounts of data when only a subset of the information is required.</span></span> <span data-ttu-id="8ae1b-294">Создание больших объемов трафика влияет не только на производительность и масштабируемость веб-сервера, но и негативно сказывается на скорости реагирования клиентских приложений, запрашивающих данные.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-294">Generating a large volume of traffic impacts not only the performance and scalability of the web server but also adversely affect the responsiveness of client applications requesting the data.</span></span>

<span data-ttu-id="8ae1b-295">Например, если заказы содержат уплаченную за них сумму, клиентскому приложению, перед которым стоит задача получить все заказы с суммой выше заданного значения, может потребоваться получить все заказы через универсальный код ресурса (URI) */orders*, после чего локально отфильтровать эти запросы.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-295">For example, if orders contain the price paid for the order, a client application that needs to retrieve all orders that have a cost over a specific value might need to retrieve all orders from the */orders* URI and then filter these orders locally.</span></span> <span data-ttu-id="8ae1b-296">Очевидно, что это крайне неэффективный процесс. Он впустую использует пропускную способность сети и вычислительные ресурсы сервера, на котором размещен веб-API.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-296">Clearly this process is highly inefficient; it wastes network bandwidth and processing power on the server hosting the web API.</span></span>

<span data-ttu-id="8ae1b-297">Возможное решение — реализовать схему URI вида */orders/ordervalue_greater_than_n*, где *n* обозначает стоимость заказа. Но такой подход очень неудобен, если нужно использовать большое количество уровней стоимости.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-297">One solution may be to provide a URI scheme such as */orders/ordervalue_greater_than_n* where *n* is the order price, but for all but a limited number of prices such an approach is impractical.</span></span> <span data-ttu-id="8ae1b-298">Кроме того, если вам требуется отправлять запросы по заказам на основе других критериев, в конце концов вам, вероятно, придется предоставлять длинный список универсальных кодов ресурсов (URI) со сложными именами.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-298">Additionally, if you need to query orders based on other criteria, you can end up being faced with providing with a long list of URIs with possibly non-intuitive names.</span></span>

<span data-ttu-id="8ae1b-299">Более рациональный подход к фильтрации данных заключается в том, чтобы предоставить условия фильтра в строке запроса, передаваемой веб-API, например */orders?ordervaluethreshold=n*.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-299">A better strategy to filtering data is to provide the filter criteria in the query string that is passed to the web API, such as */orders?ordervaluethreshold=n*.</span></span> <span data-ttu-id="8ae1b-300">В этом примере соответствующая операция в веб-API отвечает за анализ и обработку параметра `ordervaluethreshold` в строке запроса и возврат фильтрованных результатов в HTTP-ответе.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-300">In this example, the corresponding operation in the web API is responsible for parsing and handling the `ordervaluethreshold` parameter in the query string and returning the filtered results in the HTTP response.</span></span>

<span data-ttu-id="8ae1b-301">Некоторые HTTP-запросы GET по ресурсам коллекций потенциально могут возвращать большое число элементов.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-301">Some simple HTTP GET requests over collection resources could potentially return a large number of items.</span></span> <span data-ttu-id="8ae1b-302">Чтобы снизить эту вероятность, при проектировании веб-API следует ввести ограничение на объем данных, возвращаемый одним запросом.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-302">To combat the possibility of this occurring you should design the web API to limit the amount of data returned by any single request.</span></span> <span data-ttu-id="8ae1b-303">Этого можно добиться путем поддержки строк запроса, позволяющих пользователю указывать максимальное число получаемых элементов (которое само может быть ограничено верхним пределом для предотвращения атак типа "отказ в обслуживании") и начальное смещение внутрь коллекции.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-303">You can achieve this by supporting query strings that enable the user to specify the maximum number of items to be retrieved (which could itself be subject to an upperbound limit to help prevent Denial of Service attacks), and a starting offset into the collection.</span></span> <span data-ttu-id="8ae1b-304">Например, строка запроса в универсальном коде ресурса (URI) */orders?limit=25&offset=50* должна вернуть 25 заказов, начиная с 50 заказа в коллекции заказов.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-304">For example, the query string in the URI */orders?limit=25&offset=50* should retrieve 25 orders starting with the 50th order found in the orders collection.</span></span> <span data-ttu-id="8ae1b-305">Как и при фильтрации данных, операция, реализующая запрос GET в веб-API, отвечает за анализ и обработку параметров `limit` и `offset` в строке запроса.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-305">As with filtering data, the operation that implements the GET request in the web API is responsible for parsing and handling the `limit` and `offset` parameters in the query string.</span></span> <span data-ttu-id="8ae1b-306">Для поддержки клиентских приложений запросы GET, возвращающие разбитые по страницам данные, должны также включать какие-либо метаданные, указывающие общее число ресурсов, доступных в коллекции.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-306">To assist client applications, GET requests that return paginated data should also include some form of metadata that indicate the total number of resources available in the collection.</span></span> <span data-ttu-id="8ae1b-307">Вы также можете рассмотреть другие стратегии интеллектуального разбиения по страницам. Дополнительные сведения см. в статье [API Design Notes: Smart Paging](http://bizcoder.com/api-design-notes-smart-paging) (Заметки по разработке API: интеллектуальное разбиение по страницам).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-307">You might also consider other intelligent paging strategies; for more information, see [API Design Notes: Smart Paging](http://bizcoder.com/api-design-notes-smart-paging)</span></span>

<span data-ttu-id="8ae1b-308">Аналогичную стратегию для сортировки данных можно также применить при их получении. Вы можете указать параметр сортировки, использующий имя поля в качестве значения, например */orders?sort=ProductID*.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-308">You can follow a similar strategy for sorting data as it is fetched; you could provide a sort parameter that takes a field name as the value, such as */orders?sort=ProductID*.</span></span> <span data-ttu-id="8ae1b-309">Однако обратите внимание, что такой подход может негативно отразиться на кэшировании (параметры строки запроса составляют часть идентификатора ресурса, используемого многими реализациями кэша в качестве ключа к кэшированным данным).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-309">However, note that this approach can have a deleterious effect on caching (query string parameters form part of the resource identifier used by many cache implementations as the key to cached data).</span></span>

<span data-ttu-id="8ae1b-310">Вы можете расширить этот подход и ограничить (спроецировать) возвращаемые поля, если один элемент ресурса содержит большой объем данных.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-310">You can extend this approach to limit (project) the fields returned if a single resource item contains a large amount of data.</span></span> <span data-ttu-id="8ae1b-311">Например, используйте параметр строки запроса, принимающий разделенный запятыми список полей, например */orders?fields=ProductID,Quantity*.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-311">For example, you could use a query string parameter that accepts a comma-delimited list of fields, such as */orders?fields=ProductID,Quantity*.</span></span>

> [!TIP]
> <span data-ttu-id="8ae1b-312">Присвойте содержательные значения по умолчанию всем необязательным параметрам в строках запроса.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-312">Give all optional parameters in query strings meaningful defaults.</span></span> <span data-ttu-id="8ae1b-313">Например, установите параметру `limit` значение 10, а параметру `offset` — 0, если вы реализуете разбиение по страницам, параметру сортировки в качестве значения задайте ключ ресурса, если вы реализуете упорядочение, а в параметре `fields` укажите все поля в ресурсе при поддержке проекций.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-313">For example, set the `limit` parameter to 10 and the `offset` parameter to 0 if you implement pagination, set the sort parameter to the key of the resource if you implement ordering, and set the `fields` parameter to all fields in the resource if you support projections.</span></span>
>
>

### <a name="handling-large-binary-resources"></a><span data-ttu-id="8ae1b-314">Обработка больших двоичных ресурсов</span><span class="sxs-lookup"><span data-stu-id="8ae1b-314">Handling large binary resources</span></span>
<span data-ttu-id="8ae1b-315">Один ресурс может содержать большие двоичные поля, такие как файлы или изображения.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-315">A single resource may contain large binary fields, such as files or images.</span></span> <span data-ttu-id="8ae1b-316">Чтобы преодолеть проблемы передачи, вызванные ненадежными и непостоянными соединениями, и сократить время ответа, вы можете предоставить операции, позволяющие клиентскому приложению получать такие ресурсы поблочно.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-316">To overcome the transmission problems caused by unreliable and intermittent connections and to improve response times, consider providing operations that enable such resources to be retrieved in chunks by the client application.</span></span> <span data-ttu-id="8ae1b-317">Для этого веб-API должен поддерживать заголовок "Accept-Ranges" для запросов GET по большим ресурсам, а в идеале также реализовывать HTTP-запросы HEAD для этих ресурсов.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-317">To do this, the web API should support the Accept-Ranges header for GET requests for large resources, and ideally implement HTTP HEAD requests for these resources.</span></span> <span data-ttu-id="8ae1b-318">Заголовок "Accept-Ranges" указывает, что операция GET поддерживает частичные результаты и что клиентское приложение может отправлять запросы GET, возвращающие подмножество ресурса, указанное в виде диапазона байтов.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-318">The Accept-Ranges header indicates that the GET operation supports partial results, and that a client application can submit GET requests that return a subset of a resource specified as a range of bytes.</span></span> <span data-ttu-id="8ae1b-319">Запрос HEAD аналогичен запросу GET с тем исключением, что он возвращает только заголовок, описывающий ресурс, и пустое сообщение.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-319">A HEAD request is similar to a GET request except that it only returns a header that describes the resource and an empty message body.</span></span> <span data-ttu-id="8ae1b-320">Клиентское приложение может отправить запрос HEAD, чтобы определить необходимость получения ресурса с помощью частичных запросов GET.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-320">A client application can issue a HEAD request to determine whether to fetch a resource by using partial GET requests.</span></span> <span data-ttu-id="8ae1b-321">В следующем примере показан запрос HEAD, получающий сведения об изображении продукта:</span><span class="sxs-lookup"><span data-stu-id="8ae1b-321">The following example shows a HEAD request that obtains information about a product image:</span></span>

```HTTP
HEAD http://adventure-works.com/products/10?fields=productImage HTTP/1.1
...
```

<span data-ttu-id="8ae1b-322">Ответное сообщение содержит заголовок с размером ресурса (4580 байт) и заголовок "Accept-Ranges", согласно которому соответствующая операция GET поддерживает частичные результаты:</span><span class="sxs-lookup"><span data-stu-id="8ae1b-322">The response message contains a header that includes the size of the resource (4580 bytes), and the Accept-Ranges header that the corresponding GET operation supports partial results:</span></span>

```HTTP
HTTP/1.1 200 OK
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 4580
...
```

<span data-ttu-id="8ae1b-323">Клиентское приложение может использовать эти сведения, чтобы создать ряд операций GET для получения изображения небольшими блоками.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-323">The client application can use this information to construct a series of GET operations to retrieve the image in smaller chunks.</span></span> <span data-ttu-id="8ae1b-324">Первый запрос возвращает первые 2500 байт с помощью заголовка "Range":</span><span class="sxs-lookup"><span data-stu-id="8ae1b-324">The first request fetches the first 2500 bytes by using the Range header:</span></span>

```HTTP
GET http://adventure-works.com/products/10?fields=productImage HTTP/1.1
Range: bytes=0-2499
...
```

<span data-ttu-id="8ae1b-325">Ответное сообщение указывает, что это частичный ответ, возвращая код состояния HTTP 206.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-325">The response message indicates that this is a partial response by returning HTTP status code 206.</span></span> <span data-ttu-id="8ae1b-326">Заголовок "Content-Length" указывает фактическое число возвращаемых байтов в тексте сообщения (не размер ресурса), а заголовок "Content-Range" указывает, какая это часть ресурса (байты 0–2499 из 4580):</span><span class="sxs-lookup"><span data-stu-id="8ae1b-326">The Content-Length header specifies the actual number of bytes returned in the message body (not the size of the resource), and the Content-Range header indicates which part of the resource this is (bytes 0-2499 out of 4580):</span></span>

```HTTP
HTTP/1.1 206 Partial Content
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 2500
Content-Range: bytes 0-2499/4580
...
_{binary data not shown}_
```

<span data-ttu-id="8ae1b-327">Последующий запрос от клиентского приложения может получить оставшуюся часть ресурса с помощью соответствующего заголовка "Range":</span><span class="sxs-lookup"><span data-stu-id="8ae1b-327">A subsequent request from the client application can retrieve the remainder of the resource by using an appropriate Range header:</span></span>

```HTTP
GET http://adventure-works.com/products/10?fields=productImage HTTP/1.1
Range: bytes=2500-
...
```

<span data-ttu-id="8ae1b-328">Соответствующее ответное сообщение должно выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="8ae1b-328">The corresponding result message should look like this:</span></span>

```HTTP
HTTP/1.1 206 Partial Content
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 2080
Content-Range: bytes 2500-4580/4580
...
```

## <a name="using-the-hateoas-approach-to-enable-navigation-to-related-resources"></a><span data-ttu-id="8ae1b-329">Обеспечение перехода к связанным ресурсам с помощью подхода HATEOAS</span><span class="sxs-lookup"><span data-stu-id="8ae1b-329">Using the HATEOAS approach to enable navigation to related resources</span></span>
<span data-ttu-id="8ae1b-330">Одна из основных целей реализации модели REST — получение возможности перемещаться внутри всего набора ресурсов без предварительного знания схемы универсальных кодов ресурсов (URI).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-330">One of the primary motivations behind REST is that it should be possible to navigate the entire set of resources without requiring prior knowledge of the URI scheme.</span></span> <span data-ttu-id="8ae1b-331">Каждый HTTP-запрос GET должен возвращать сведения, необходимые для поиска ресурсов, напрямую связанных с запрашиваемым объектом, посредством гиперссылок, включенных в ответ. Запросу GET также необходимо предоставить сведения, описывающие операции, доступные в каждом из этих ресурсов.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-331">Each HTTP GET request should return the information necessary to find the resources related directly to the requested object through hyperlinks included in the response, and it should also be provided with information that describes the operations available on each of these resources.</span></span> <span data-ttu-id="8ae1b-332">Этот принцип называется HATEOAS (гипертекст как обработчик состояния приложения).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-332">This principle is known as HATEOAS, or Hypertext as the Engine of Application State.</span></span> <span data-ttu-id="8ae1b-333">Система фактически представляет собой конечный автомат. Ответ по каждому запросу содержит сведения, необходимые для перемещения между состояниями. Другие сведения не требуются.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-333">The system is effectively a finite state machine, and the response to each request contains the information necessary to move from one state to another; no other information should be necessary.</span></span>

> [!NOTE]
> <span data-ttu-id="8ae1b-334">На сегодняшний день не существует стандартов или спецификаций, определяющих правила моделирования принципа HATEOAS.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-334">Currently there are no standards or specifications that define how to model the HATEOAS principle.</span></span> <span data-ttu-id="8ae1b-335">Примеры в этом разделе демонстрируют одно из возможных решений.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-335">The examples shown in this section illustrate one possible solution.</span></span>
>
>

<span data-ttu-id="8ae1b-336">Например, для обработки связи между клиентами и заказами данные, возвращаемые в ответе по определенному заказу, должны содержать универсальные коды ресурсов (URI) в виде гиперссылки, определяющей клиента, разместившего заказ, и операции, которые можно выполнить для этого клиента.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-336">As an example, to handle the relationship between customers and orders, the data returned in the response for a specific order should contain URIs in the form of a hyperlink identifying the customer that placed the order, and the operations that can be performed on that customer.</span></span>

```HTTP
GET http://adventure-works.com/orders/3 HTTP/1.1
Accept: application/json
...
```

<span data-ttu-id="8ae1b-337">Текст ответного сообщения содержит массив `links` (выделен в примере кода), указывающий характер связи (*клиент*), универсальный код ресурса (URI) клиента (*http://adventure-works.com/customers/3*), способ получения сведений об этом клиенте (*GET*) и типы MIME, используемые веб-сервером для получения этих сведений (*text/xml* и *application/json*).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-337">The body of the response message contains a `links` array (highlighted in the code example) that specifies the nature of the relationship (*Customer*), the URI of the customer (*http://adventure-works.com/customers/3*), how to retrieve the details of this customer (*GET*), and the MIME types that the web server supports for retrieving this information (*text/xml* and *application/json*).</span></span> <span data-ttu-id="8ae1b-338">Это все сведения, необходимые клиентскому приложению для получения сведений о клиенте.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-338">This is all the information that a client application needs to be able to fetch the details of the customer.</span></span> <span data-ttu-id="8ae1b-339">Помимо этого, массив "Links" также включает ссылки для других возможных операций, таких как PUT (для изменения клиента, включая формат, который веб-сервер ожидает получить от клиентского приложения) и DELETE.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-339">Additionally, the Links array also includes links for the other operations that can be performed, such as PUT (to modify the customer, together with the format that the web server expects the client to provide), and DELETE.</span></span>

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"orderID":3,"productID":2,"quantity":4,"orderValue":16.60,"links":[(some links omitted){"rel":"customer","href":" http://adventure-works.com/customers/3", "action":"GET","types":["text/xml","application/json"]},{"rel":"
customer","href":" http://adventure-works.com /customers/3", "action":"PUT","types":["application/x-www-form-urlencoded"]},{"rel":"customer","href":" http://adventure-works.com /customers/3","action":"DELETE","types":[]}]}
```

<span data-ttu-id="8ae1b-340">Для полноты массив "Links" также должен включать автореферентные сведения, относящиеся к полученному ресурсу.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-340">For completeness, the Links array should also include self-referencing information pertaining to the resource that has been retrieved.</span></span> <span data-ttu-id="8ae1b-341">Эти ссылки опущены в предыдущем примере, но выделены в следующем коде.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-341">These links have been omitted from the previous example, but are highlighted in the following code.</span></span> <span data-ttu-id="8ae1b-342">Обратите внимание, что связь *self* в этих ссылках используется для указания на то, что это ссылка на ресурс, возвращаемый операцией.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-342">Notice that in these links, the relationship *self* has been used to indicate that this is a reference to the resource being returned by the operation:</span></span>

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"orderID":3,"productID":2,"quantity":4,"orderValue":16.60,"links":[{"rel":"self","href":" http://adventure-works.com/orders/3", "action":"GET","types":["text/xml","application/json"]},{"rel":" self","href":" http://adventure-works.com /orders/3", "action":"PUT","types":["application/x-www-form-urlencoded"]},{"rel":"self","href":" http://adventure-works.com /orders/3", "action":"DELETE","types":[]},{"rel":"customer",
"href":" http://adventure-works.com /customers/3", "action":"GET","types":["text/xml","application/json"]},{"rel":" customer" (customer links omitted)}]}
```

<span data-ttu-id="8ae1b-343">Чтобы такой подход оказался эффективным, клиентские приложения должны быть готовы к получению и анализу этих дополнительных сведений.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-343">For this approach to be effective, client applications must be prepared to retrieve and parse this additional information.</span></span>

## <a name="versioning-a-restful-web-api"></a><span data-ttu-id="8ae1b-344">Управление версиями веб-API RESTful</span><span class="sxs-lookup"><span data-stu-id="8ae1b-344">Versioning a RESTful web API</span></span>
<span data-ttu-id="8ae1b-345">Маловероятно, что веб-API останется статическим, за исключением самых простых ситуаций.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-345">It is highly unlikely that in all but the simplest of situations that a web API will remain static.</span></span> <span data-ttu-id="8ae1b-346">По мере изменения бизнес-требований добавляются новые коллекции ресурсов, изменяются связи между ресурсами и структура данных в ресурсах.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-346">As business requirements change new collections of resources may be added, the relationships between resources might change, and the structure of the data in resources might be amended.</span></span> <span data-ttu-id="8ae1b-347">Несмотря на то что обновление веб-API для соответствия новым или измененным требованиям — довольно простой процесс, вам необходимо учесть, какое воздействие эти изменения окажут на клиентские приложения, использующие веб-API.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-347">While updating a web API to handle new or differing requirements is a relatively straightforward process, you must consider the effects that such changes will have on client applications consuming the web API.</span></span> <span data-ttu-id="8ae1b-348">Проблема в том, что хотя разработчик, занимающийся проектированием и реализацией веб-API, полностью контролирует этот API, у него нет того же уровня контроля над клиентскими приложениями, которые порой создаются сторонними организациями, работающими в удаленном режиме.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-348">The issue is that although the developer designing and implementing a web API has full control over that API, the developer does not have the same degree of control over client applications which may be built by third party organizations operating remotely.</span></span> <span data-ttu-id="8ae1b-349">В первую очередь необходимо позволить существующим клиентским приложениям продолжать работу без изменений, при этом предоставляя новым клиентским приложениям доступ к новым функциям и ресурсам.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-349">The primary imperative is to enable existing client applications to continue functioning unchanged while allowing new client applications to take advantage of new features and resources.</span></span>

<span data-ttu-id="8ae1b-350">Управление версиями позволяет веб-API указывать предоставляемые функции и ресурсы, за счет чего клиентское приложение может отправлять запросы для определенной версии функции или ресурса.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-350">Versioning enables a web API to indicate the features and resources that it exposes, and a client application can submit requests that are directed to a specific version of a feature or resource.</span></span> <span data-ttu-id="8ae1b-351">В следующих разделах описано несколько различных подходов со своими преимуществами и недостатками.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-351">The following sections describe several different approaches, each of which has its own benefits and trade-offs.</span></span>

### <a name="no-versioning"></a><span data-ttu-id="8ae1b-352">Отсутствие управления версиями</span><span class="sxs-lookup"><span data-stu-id="8ae1b-352">No versioning</span></span>
<span data-ttu-id="8ae1b-353">Эта простейший подход, приемлемый для некоторых внутренних API.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-353">This is the simplest approach, and may be acceptable for some internal APIs.</span></span> <span data-ttu-id="8ae1b-354">Масштабные изменения можно представлять в виде новых ресурсов или ссылок.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-354">Big changes could be represented as new resources or new links.</span></span>  <span data-ttu-id="8ae1b-355">Добавление содержимого к существующим ресурсам не всегда является значительным изменением, поскольку клиентские приложения, не ожидающие увидеть это содержимое, просто пропустят его.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-355">Adding content to existing resources might not present a breaking change as client applications that are not expecting to see this content will simply ignore it.</span></span>

<span data-ttu-id="8ae1b-356">Например, запрос на универсальный код ресурса (URI) *http://adventure-works.com/customers/3* должен вернуть сведения одного клиента с полями `id`, `name` и `address`, которые ожидает клиентское приложение.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-356">For example, a request to the URI *http://adventure-works.com/customers/3* should return the details of a single customer containing `id`, `name`, and `address` fields expected by the client application:</span></span>

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","address":"1 Microsoft Way Redmond WA 98053"}
```

> [!NOTE]
> <span data-ttu-id="8ae1b-357">Для простоты и понятности примеры ответов в этом разделе не содержат ссылок HATEOAS.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-357">For the purposes of simplicity and clarity, the example responses shown in this section do not include HATEOAS links.</span></span>
>
>

<span data-ttu-id="8ae1b-358">Если поле `DateCreated` добавить в схему ресурса клиента, ответ будет выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="8ae1b-358">If the `DateCreated` field is added to the schema of the customer resource, then the response would look like this:</span></span>

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","dateCreated":"2014-09-04T12:11:38.0376089Z","address":"1 Microsoft Way Redmond WA 98053"}
```

<span data-ttu-id="8ae1b-359">Существующие клиентские приложения могут продолжить работать без ошибок, если они могут пропускать нераспознанные поля, в то время как при проектировании новых клиентских приложений можно обеспечить поддержку новых полей.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-359">Existing client applications might continue functioning correctly if they are capable of ignoring unrecognized fields, while new client applications can be designed to handle this new field.</span></span> <span data-ttu-id="8ae1b-360">Однако внесение более серьезных изменений в схему ресурсов (таких как удаление или переименование полей) или изменение связей между ресурсами могут быть значительными изменениями, мешающими корректной работе существующих клиентских приложений.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-360">However, if more radical changes to the schema of resources occur (such as removing or renaming fields) or the relationships between resources change then these may constitute breaking changes that prevent existing client applications from functioning correctly.</span></span> <span data-ttu-id="8ae1b-361">В такой ситуации вам следует рассмотреть один из следующих подходов.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-361">In these situations you should consider one of the following approaches.</span></span>

### <a name="uri-versioning"></a><span data-ttu-id="8ae1b-362">Управление версиями через универсальные коды ресурсов (URI)</span><span class="sxs-lookup"><span data-stu-id="8ae1b-362">URI versioning</span></span>
<span data-ttu-id="8ae1b-363">При каждом изменении веб-API или схемы ресурсов вы добавляете номер версии в универсальный код (URI) каждого ресурса.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-363">Each time you modify the web API or change the schema of resources, you add a version number to the URI for each resource.</span></span> <span data-ttu-id="8ae1b-364">Уже существующие универсальные коды ресурсов (URI) должны продолжить функционировать без изменений, возвращая ресурсы, соответствующие их исходной схеме.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-364">The previously existing URIs should continue to operate as before, returning resources that conform to their original schema.</span></span>

<span data-ttu-id="8ae1b-365">Расширим предыдущий пример. Если изменить структуру поля `address` и добавить подполя, содержащие каждую составляющую часть адреса (например, `streetAddress`, `city`, `state` и `zipCode`), эту версию ресурса можно предоставить посредством универсального кода ресурса (URI) с номером версии, например http://adventure-works.com/v2/customers/3.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-365">Extending the previous example, if the `address` field is restructured into sub-fields containing each constituent part of the address (such as `streetAddress`, `city`, `state`, and `zipCode`), this version of the resource could be exposed through a URI containing a version number, such as http://adventure-works.com/v2/customers/3:</span></span>

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","dateCreated":"2014-09-04T12:11:38.0376089Z","address":{"streetAddress":"1 Microsoft Way","city":"Redmond","state":"WA","zipCode":98053}}
```

<span data-ttu-id="8ae1b-366">Этот механизм управления версиями очень прост, но для него требуется, чтобы сервер направлял запрос к соответствующей конечной точке.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-366">This versioning mechanism is very simple but depends on the server routing the request to the appropriate endpoint.</span></span> <span data-ttu-id="8ae1b-367">Однако этот подход может стать чрезмерно сложным по мере прохождения веб-API через несколько итераций и необходимости поддержки сервером нескольких различных версий.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-367">However, it can become unwieldy as the web API matures through several iterations and the server has to support a number of different versions.</span></span> <span data-ttu-id="8ae1b-368">Кроме того, c пуристической точки зрения, во всех случаях клиентские приложения получают одни и те же данные (клиент 3), поэтому универсальный код ресурса (URI) фактически не должен отличаться в зависимости от версии.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-368">Also, from a purist’s point of view, in all cases the client applications are fetching the same data (customer 3), so the URI should not really be different depending on the version.</span></span> <span data-ttu-id="8ae1b-369">Эта схема также усложняет реализацию HATEOAS, поскольку потребуется включать номер версии в универсальные коды ресурсов (URI) всех ссылок.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-369">This scheme also complicates implementation of HATEOAS as all links will need to include the version number in their URIs.</span></span>

### <a name="query-string-versioning"></a><span data-ttu-id="8ae1b-370">Управление версиями через строку запроса</span><span class="sxs-lookup"><span data-stu-id="8ae1b-370">Query string versioning</span></span>
<span data-ttu-id="8ae1b-371">Чтобы избежать предоставления множества универсальных кодов ресурсов (URI), вы можете указывать версию ресурса с помощью параметра в строке запроса, добавленного к HTTP-запросу, например *http://adventure-works.com/customers/3?version=2*.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-371">Rather than providing multiple URIs, you can specify the version of the resource by using a parameter within the query string appended to the HTTP request, such as *http://adventure-works.com/customers/3?version=2*.</span></span> <span data-ttu-id="8ae1b-372">Значение по умолчанию параметра версии должно быть содержательным, например 1, если оно опускается клиентскими приложениями прежних версий.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-372">The version parameter should default to a meaningful value such as 1 if it is omitted by older client applications.</span></span>

<span data-ttu-id="8ae1b-373">Этот подход обладает семантическим преимуществом в том плане, что один и тот же ресурс всегда возвращается по одинаковому универсальному коду ресурса (URI). Однако он зависит от кода, обрабатывающего запрос для анализа строки запроса и возврата соответствующего HTTP-ответа.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-373">This approach has the semantic advantage that the same resource is always retrieved from the same URI, but it depends on the code that handles the request to parse the query string and send back the appropriate HTTP response.</span></span> <span data-ttu-id="8ae1b-374">Кроме того, этот подход также усложняет реализацию HATEOAS, как и механизм управления версиями через универсальные коды ресурсов (URI).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-374">This approach also suffers from the same complications for implementing HATEOAS as the URI versioning mechanism.</span></span>

> [!NOTE]
> <span data-ttu-id="8ae1b-375">Некоторые браузеры прежних версий и веб-прокси не могут кэшировать ответы по запросам, содержащим строку запроса в URL-адресе.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-375">Some older web browsers and web proxies will not cache responses for requests that include a query string in the URL.</span></span> <span data-ttu-id="8ae1b-376">Это может негативно сказаться на производительности веб-приложений, использующих веб-API и выполняемых через такой веб-браузер.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-376">This can have an adverse impact on performance for web applications that use a web API and that run from within such a web browser.</span></span>
>
>

### <a name="header-versioning"></a><span data-ttu-id="8ae1b-377">Управление версиями через заголовок</span><span class="sxs-lookup"><span data-stu-id="8ae1b-377">Header versioning</span></span>
<span data-ttu-id="8ae1b-378">Вместо того чтобы добавлять номер версии в виде параметра строки запроса, вы можете реализовать пользовательский заголовок, указывающий версию ресурса.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-378">Rather than appending the version number as a query string parameter, you could implement a custom header that indicates the version of the resource.</span></span> <span data-ttu-id="8ae1b-379">Этот подход требует от клиентского приложения добавления соответствующего заголовка во все запросы. При этом в коде, обрабатывающем запрос клиентского приложения, можно использовать значение по умолчанию (версия 1), если заголовок с номером версии опускается.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-379">This approach requires that the client application adds the appropriate header to any requests, although the code handling the client request could use a default value (version 1) if the version header is omitted.</span></span> <span data-ttu-id="8ae1b-380">В следующих примерах используется пользовательский заголовок с именем *Custom-Header*.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-380">The following examples utilize a custom header named *Custom-Header*.</span></span> <span data-ttu-id="8ae1b-381">Значение этого заголовка указывает версию веб-API.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-381">The value of this header indicates the version of web API.</span></span>

<span data-ttu-id="8ae1b-382">Версия 1:</span><span class="sxs-lookup"><span data-stu-id="8ae1b-382">Version 1:</span></span>

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Custom-Header: api-version=1
...
```

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","address":"1 Microsoft Way Redmond WA 98053"}
```

<span data-ttu-id="8ae1b-383">Версия 2:</span><span class="sxs-lookup"><span data-stu-id="8ae1b-383">Version 2:</span></span>

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Custom-Header: api-version=2
...
```

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","dateCreated":"2014-09-04T12:11:38.0376089Z","address":{"streetAddress":"1 Microsoft Way","city":"Redmond","state":"WA","zipCode":98053}}
```

<span data-ttu-id="8ae1b-384">Обратите внимание, что, как и в двух предыдущих подходах, для реализации HATEOAS потребуется включать соответствующий пользовательский заголовок во все ссылки.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-384">Note that as with the previous two approaches, implementing HATEOAS requires including the appropriate custom header in any links.</span></span>

### <a name="media-type-versioning"></a><span data-ttu-id="8ae1b-385">Управление версиями через тип носителя</span><span class="sxs-lookup"><span data-stu-id="8ae1b-385">Media type versioning</span></span>
<span data-ttu-id="8ae1b-386">При отправке HTTP-запроса GET на веб-сервер клиентское приложение должно указывать поддерживаемый формат содержимого с помощью заголовка "Accept", как описано ранее в этом руководстве.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-386">When a client application sends an HTTP GET request to a web server it should stipulate the format of the content that it can handle by using an Accept header, as described earlier in this guidance.</span></span> <span data-ttu-id="8ae1b-387">Нередко заголовок *Accept* используется для того, чтобы позволить клиентскому приложению указать требуемый формат текста ответа: XML, JSON или другой формат, который клиентское приложение может анализировать.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-387">Frequently the purpose of the *Accept* header is to allow the client application to specify whether the body of the response should be XML, JSON, or some other common format that the client can parse.</span></span> <span data-ttu-id="8ae1b-388">Однако можно определить пользовательские типы носителей, которые содержат сведения, позволяющие клиентскому приложению указывать предпочтительную версию ресурса.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-388">However, it is possible to define custom media types that include information enabling the client application to indicate which version of a resource it is expecting.</span></span> <span data-ttu-id="8ae1b-389">В следующем примере показан запрос, в котором используется заголовок *Accept* со значением *application/vnd.adventure-works.v1+json*.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-389">The following example shows a request that specifies an *Accept* header with the value *application/vnd.adventure-works.v1+json*.</span></span> <span data-ttu-id="8ae1b-390">Элемент *vnd.adventure-works.v1* указывает веб-серверу на необходимость возврата ресурса версии 1, в то время как элемент *json* указывает JSON в качестве предпочтительного формата текста ответа.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-390">The *vnd.adventure-works.v1* element indicates to the web server that it should return version 1 of the resource, while the *json* element specifies that the format of the response body should be JSON:</span></span>

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Accept: application/vnd.adventure-works.v1+json
...
```

<span data-ttu-id="8ae1b-391">Код, обрабатывающий запрос, отвечает за обработку заголовка *Accept* и максимальное выполнение содержащихся в нем требований (клиентское приложение может указать в заголовке *Accept* несколько форматов, в случае чего веб-сервер может выбрать наиболее подходящий формат текста ответа).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-391">The code handling the request is responsible for processing the *Accept* header and honoring it as far as possible (the client application may specify multiple formats in the *Accept* header, in which case the web server can choose the most appropriate format for the response body).</span></span> <span data-ttu-id="8ae1b-392">Веб-сервер подтверждает формат данных в тексте ответа с помощью заголовка "Content-Type":</span><span class="sxs-lookup"><span data-stu-id="8ae1b-392">The web server confirms the format of the data in the response body by using the Content-Type header:</span></span>

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/vnd.adventure-works.v1+json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","address":"1 Microsoft Way Redmond WA 98053"}
```

<span data-ttu-id="8ae1b-393">Если в заголовке "Accept" не указан ни один из известных типов носителя, веб-сервер может отправить ответное сообщение с кодом HTTP 406 (неприемлемо) или вернуть сообщение с типом носителя по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-393">If the Accept header does not specify any known media types, the web server could generate an HTTP 406 (Not Acceptable) response message or return a message with a default media type.</span></span>

<span data-ttu-id="8ae1b-394">Вероятно, это самый полноценный механизм управления версиями, беспрепятственно поддерживающий принцип HATEOAS, который может включать MIME-тип связанных данных в ссылках ресурсов.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-394">This approach is arguably the purest of the versioning mechanisms and lends itself naturally to HATEOAS, which can include the MIME type of related data in resource links.</span></span>

> [!NOTE]
> <span data-ttu-id="8ae1b-395">При выборе стратегии управления версиями вам также следует учесть воздействие на производительность, особенно при кэшировании на веб-сервере.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-395">When you select a versioning strategy, you should also consider the implications on performance, especially caching on the web server.</span></span> <span data-ttu-id="8ae1b-396">Управление версиями через универсальные коды ресурсов (URI) и строку запроса поддерживает кэширование, поскольку одинаковое сочетание универсального кода ресурса (URI) и строки запроса каждый раз соотносится с одними и теми же данными.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-396">The URI versioning and Query String versioning schemes are cache-friendly inasmuch as the same URI/query string combination refers to the same data each time.</span></span>
>
> <span data-ttu-id="8ae1b-397">Механизмы управления версиями через заголовок и тип носителя, как правило, требуют дополнительной логики для проверки значений в пользовательском заголовке или заголовке "Accept".</span><span class="sxs-lookup"><span data-stu-id="8ae1b-397">The Header versioning and Media Type versioning mechanisms typically require additional logic to examine the values in the custom header or the Accept header.</span></span> <span data-ttu-id="8ae1b-398">Использование многочисленными клиентами разных версий веб-API в крупномасштабной среде может привести к образованию большого объема повторяющихся данных в кэше на стороне сервера.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-398">In a large-scale environment, many clients using different versions of a web API can result in a significant amount of duplicated data in a server-side cache.</span></span> <span data-ttu-id="8ae1b-399">Эта проблема может усложниться, если клиентское приложение обменивается данными с веб-сервером через прокси-сервер, реализующий кэширование, который перенаправляет запрос на веб-сервер лишь в том случае, если в его кэше на текущий момент не содержится копия запрашиваемых данных.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-399">This issue can become acute if a client application communicates with a web server through a proxy that implements caching, and that only forwards a request to the web server if it does not currently hold a copy of the requested data in its cache.</span></span>
>
>

## <a name="open-api-initiative"></a><span data-ttu-id="8ae1b-400">Open API Initiative</span><span class="sxs-lookup"><span data-stu-id="8ae1b-400">Open API Initiative</span></span>
<span data-ttu-id="8ae1b-401">Организация [Open API Initiative](https://www.openapis.org/) создана отраслевым консорциумом для стандартизации описаний REST API разных поставщиков.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-401">The [Open API Initiative](https://www.openapis.org/) was created by an industry consortium to standardize REST API descriptions across vendors.</span></span> <span data-ttu-id="8ae1b-402">В рамках этой инициативы спецификация Swagger 2.0 была переименована в OpenAPI Specification (OAS) и перенесена в проект Open API Initiative.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-402">As part of this initiative, the Swagger 2.0 specification was renamed the OpenAPI Specification (OAS) and brought under the Open API Initiative.</span></span>

<span data-ttu-id="8ae1b-403">Возможно, вам потребуется применить OpenAPI для вашего веб-API.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-403">You may want to adopt OpenAPI for your web APIs.</span></span> <span data-ttu-id="8ae1b-404">Учитывайте следующие факторы.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-404">Some points to consider:</span></span>

- <span data-ttu-id="8ae1b-405">Спецификация OpenAPI поставляется с набором заключений и рекомендаций по разработке REST API.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-405">The OpenAPI Specification comes with with a set of opinionated guidelines on how a REST API should be designed.</span></span> <span data-ttu-id="8ae1b-406">Она дает ряд преимуществ для взаимодействия, но требует дополнительного внимания при разработке API для соблюдения спецификации.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-406">That has advantages for interoperability, but requires more care when designing your API to conform to the specification.</span></span>
- <span data-ttu-id="8ae1b-407">В OpenAPI рекомендуется начинать работу с создания контракта, а не реализации.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-407">OpenAPI promotes a contract-first approach, rather than an implementation-first approach.</span></span> <span data-ttu-id="8ae1b-408">Это означает, что при разработке API вы сначала создаете контракт (интерфейс) и лишь после этого пишете код для его реализации.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-408">Contract-first means you design the API contract (the interface) first and then write code that implements the contract.</span></span> 
- <span data-ttu-id="8ae1b-409">При помощи Swagger и других средства можно создавать клиентские библиотеки и документацию на основе контрактов API.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-409">Tools like Swagger can generate client libraries or documentation from API contracts.</span></span> <span data-ttu-id="8ae1b-410">См. [пример создания веб-API справки на ASP.NET с помощью Swagger](/aspnet/core/tutorials/web-api-help-pages-using-swagger).</span><span class="sxs-lookup"><span data-stu-id="8ae1b-410">For example, see [ASP.NET Web API Help Pages using Swagger](/aspnet/core/tutorials/web-api-help-pages-using-swagger).</span></span>

## <a name="more-information"></a><span data-ttu-id="8ae1b-411">Дополнительные сведения</span><span class="sxs-lookup"><span data-stu-id="8ae1b-411">More information</span></span>
* <span data-ttu-id="8ae1b-412">В статье [Microsoft REST API Guidelines](https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md) (Рекомендации корпорации Майкрософт по REST API) подробно описана разработка общедоступных REST API.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-412">The [Microsoft REST API Guidelines](https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md) contain detailed recommendations for designing public REST APIs.</span></span>
* <span data-ttu-id="8ae1b-413">[Подробная инструкция по RESTful](http://restcookbook.com/) содержит общие сведения о создании API RESTful.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-413">The [RESTful Cookbook](http://restcookbook.com/) contains an introduction to building RESTful APIs.</span></span>
* <span data-ttu-id="8ae1b-414">В [контрольном списке для веб-API](https://mathieu.fenniak.net/the-api-checklist/) описаны факторы, которые важно учитывать при разработке и реализации веб-API.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-414">The [Web API Checklist](https://mathieu.fenniak.net/the-api-checklist/) contains a useful list of items to consider when designing and implementing a web API.</span></span>
* <span data-ttu-id="8ae1b-415">Сайт [Open API Initiative](https://www.openapis.org/) содержит всю документацию и описание реализации для спецификации Open API.</span><span class="sxs-lookup"><span data-stu-id="8ae1b-415">The [Open API Initiative](https://www.openapis.org/) site, contains all related documentation and implementation details on Open API.</span></span>

---
title: Стратегии секционирования данных
titleSuffix: Best practices for cloud applications
description: Руководство по разделению секций данных для реализации отдельного управления и доступа.
author: dragon119
ms.date: 11/04/2018
ms.custom: seodec18
ms.openlocfilehash: 609da490537c20c1ea5e3fd739233d51435c689a
ms.sourcegitcommit: 4ba3304eebaa8c493c3e5307bdd9d723cd90b655
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/12/2018
ms.locfileid: "53307305"
---
# <a name="data-partitioning-strategies"></a><span data-ttu-id="1e0a7-103">Стратегии секционирования данных</span><span class="sxs-lookup"><span data-stu-id="1e0a7-103">Data partitioning strategies</span></span>

<span data-ttu-id="1e0a7-104">В этой статье описываются стратегии секционирования данных в различных хранилищах данных Azure.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-104">This article describes some strategies for partitioning data in various Azure data stores.</span></span> <span data-ttu-id="1e0a7-105">Общие рекомендации по секционировании данных см. в статье [Секционирование данных](./data-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-105">For general guidance about when to partition data and best practices, see [Data partitioning](./data-partitioning.md)</span></span>

## <a name="partitioning-azure-sql-database"></a><span data-ttu-id="1e0a7-106">Секционирование Базы данных SQL Azure</span><span class="sxs-lookup"><span data-stu-id="1e0a7-106">Partitioning Azure SQL Database</span></span>

<span data-ttu-id="1e0a7-107">Одна база данных SQL имеет ограничение на объем содержащихся в ней данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-107">A single SQL database has a limit to the volume of data that it can contain.</span></span> <span data-ttu-id="1e0a7-108">Пропускная способность ограничена архитектурными факторами и числом поддерживаемых одновременных подключений.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-108">Throughput is constrained by architectural factors and the number of concurrent connections that it supports.</span></span>

<span data-ttu-id="1e0a7-109">[Эластичные пулы](/azure/sql-database/sql-database-elastic-pool) поддерживают горизонтальное масштабирование базы данных SQL.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-109">[Elastic pools](/azure/sql-database/sql-database-elastic-pool) support horizontal scaling for a SQL database.</span></span> <span data-ttu-id="1e0a7-110">С помощью эластичных пулов можно секционировать данные в сегменты, которые распределены между несколькими базами данных SQL.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-110">Using elastic pools, you can partition your data into shards that are spread across multiple SQL databases.</span></span> <span data-ttu-id="1e0a7-111">Можно также добавлять или удалять сегменты по мере роста или уменьшения объема обрабатываемых данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-111">You can also add or remove shards as the volume of data that you need to handle grows and shrinks.</span></span> <span data-ttu-id="1e0a7-112">Кроме того, эластичные пулы помогают уменьшить количество конфликтов за счет распределения нагрузки между базами данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-112">Elastic pools can also help reduce contention by distributing the load across databases.</span></span>

<span data-ttu-id="1e0a7-113">Каждый сегмент реализуется как база данных SQL.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-113">Each shard is implemented as a SQL database.</span></span> <span data-ttu-id="1e0a7-114">Сегмент может содержать более одного набора данных, называемого *шардлетом*.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-114">A shard can hold more than one dataset (called a *shardlet*).</span></span> <span data-ttu-id="1e0a7-115">Каждая база данных хранит метаданные, которые описывают содержащиеся в ней шардлеты.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-115">Each database maintains metadata that describes the shardlets that it contains.</span></span> <span data-ttu-id="1e0a7-116">Шардлет может быть отдельным элементом данных или группой элементов, которые совместно используют один и тот же ключ шардлета.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-116">A shardlet can be a single data item, or a group of items that share the same shardlet key.</span></span> <span data-ttu-id="1e0a7-117">Например, в приложении с несколькими клиентами ключом шардлета может быть идентификатор клиента, а все данные для клиента могут храниться в одном и том же шардлете.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-117">For example, in a multitenant application, the shardlet key can be the tenant ID, and all data for a tenant can be held in the same shardlet.</span></span>

<span data-ttu-id="1e0a7-118">Клиентские приложения отвечают за связывание набора данных с ключом шардлета.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-118">Client applications are responsible for associating a dataset with a shardlet key.</span></span> <span data-ttu-id="1e0a7-119">Отдельная база данных SQL выступает в роли глобального диспетчера сопоставления сегментов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-119">A separate SQL database acts as a global shard map manager.</span></span> <span data-ttu-id="1e0a7-120">Эта база данных содержит список всех сегментов и шардлетов в системе.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-120">This database has a list of all the shards and shardlets in the system.</span></span> <span data-ttu-id="1e0a7-121">Приложение подключается к базе данных диспетчера карты сегментов для получения копии карты сегментов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-121">The application connects to the shard map manager database to obtain a copy of the shard map.</span></span> <span data-ttu-id="1e0a7-122">Оно локально кэширует карту сегментов и использует ее для маршрутизации запросов к данным в соответствующий сегмент.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-122">It caches the shard map locally, and uses the map to route data requests to the appropriate shard.</span></span> <span data-ttu-id="1e0a7-123">Эта функция скрыта за рядом API-интерфейсов, содержащихся в [клиентской библиотеке эластичной базы данных](/azure/sql-database/sql-database-elastic-database-client-library), доступной для Java и .NET.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-123">This functionality is hidden behind a series of APIs that are contained in the [Elastic Database client library](/azure/sql-database/sql-database-elastic-database-client-library), which is available for Java and .NET.</span></span>

<span data-ttu-id="1e0a7-124">Дополнительные сведения об эластичных пулах см. в статье [Развертывание с помощью Базы данных SQL Azure](/azure/sql-database/sql-database-elastic-scale-introduction).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-124">For more information about elastic pools, see [Scaling out with Azure SQL Database](/azure/sql-database/sql-database-elastic-scale-introduction).</span></span>

<span data-ttu-id="1e0a7-125">Можно реплицировать глобальную базу данных диспетчера карты сегментов для уменьшения задержки и повышения доступности.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-125">To reduce latency and improve availability, you can replicate the global shard map manager database.</span></span> <span data-ttu-id="1e0a7-126">С помощью одной из ценовых категорий "Премиум" можно настроить активную георепликацию для непрерывного копирования данных в базы данных в разных регионах.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-126">With the Premium pricing tiers, you can configure active geo-replication to continuously copy data to databases in different regions.</span></span>

<span data-ttu-id="1e0a7-127">В качестве альтернативы можно использовать [синхронизацию данных SQL Azure](/azure/sql-database/sql-database-sync-data) или [Фабрику данных Azure](/azure/data-factory/) для репликации базы данных диспетчера карты сегментов между регионами.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-127">Alternatively, use [Azure SQL Data Sync](/azure/sql-database/sql-database-sync-data) or [Azure Data Factory](/azure/data-factory/) to replicate the shard map manager database across regions.</span></span> <span data-ttu-id="1e0a7-128">Репликация этого типа запускается периодически и лучше подходит, если карта сегментов изменяется редко. Выбор ценовой категории "Премиум" при этом не требуется.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-128">This form of replication runs periodically and is more suitable if the shard map changes infrequently, and does not require Premium tier.</span></span>

<span data-ttu-id="1e0a7-129">Эластичная база данных предоставляет две схемы для сопоставления данных и шардлетов и их хранения в сегментах.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-129">Elastic Database provides two schemes for mapping data to shardlets and storing them in shards:</span></span>

- <span data-ttu-id="1e0a7-130">**Карта сегментов в виде списка** связывает один ключ с шардлетом.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-130">A **list shard map** associates a single key to a shardlet.</span></span> <span data-ttu-id="1e0a7-131">Например, в мультитенантной системе данные для каждого клиента могут быть связаны с уникальным ключом и храниться в собственном шардлете.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-131">For example, in a multitenant system, the data for each tenant can be associated with a unique key and stored in its own shardlet.</span></span> <span data-ttu-id="1e0a7-132">Чтобы обеспечить изоляцию, каждый шардлет может храниться в собственном сегменте.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-132">To guarantee isolation, each shardlet can be held within its own shard.</span></span>

    ![Использование карты сегментов в виде списка для хранения данных клиента в отдельных сегментах](./images/data-partitioning/PointShardlet.png)

- <span data-ttu-id="1e0a7-134">**Карта сегментов в виде диапазона** связывает набор связанных значений ключа с шардлетом.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-134">A **range shard map** associates a set of contiguous key values to a shardlet.</span></span> <span data-ttu-id="1e0a7-135">Например, можно группировать данные для набора клиентов (каждый из которых имеет собственный ключ) в пределах одного шардлета.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-135">For example, you can group the data for a set of tenants (each with their own key) within the same shardlet.</span></span> <span data-ttu-id="1e0a7-136">Эта схема дешевле первой, так как клиенты совместно используют хранилище данных, хотя и с меньшей степенью изоляции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-136">This scheme is less expensive than the first, because tenants share data storage, but has less isolation.</span></span>

    ![Использование карты сегментов в виде диапазона для хранения данных диапазона клиентов в сегменте](./images/data-partitioning/RangeShardlet.png)

<span data-ttu-id="1e0a7-138">Один сегмент может содержать данные для нескольких шардлетов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-138">A single shard can contain the data for several shardlets.</span></span> <span data-ttu-id="1e0a7-139">Например, можно использовать шардлеты в виде списка для хранения данных разных несмежных клиентов в одном сегменте.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-139">For example, you can use list shardlets to store data for different non-contiguous tenants in the same shard.</span></span> <span data-ttu-id="1e0a7-140">Можно также смешивать шардлеты в виде диапазона и шардлеты в виде списка в одном сегменте, хотя они будут использоваться с помощью разных карт.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-140">You can also mix range shardlets and list shardlets in the same shard, although they will be addressed through different maps.</span></span> <span data-ttu-id="1e0a7-141">Этот подход показан на схеме ниже.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-141">The following diagram shows this approach:</span></span>

![Реализация нескольких карт сегментов](./images/data-partitioning/MultipleShardMaps.png)

<span data-ttu-id="1e0a7-143">Эластичные пулы позволяют добавлять и удалять сегменты в соответствии с изменением объема данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-143">Elastic pools makes it possible to add and remove shards as the volume of data shrinks and grows.</span></span> <span data-ttu-id="1e0a7-144">Клиентские приложения могут создавать и удалять сегменты динамически, а также прозрачно обновлять диспетчер карты сегментов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-144">Client applications can create and delete shards dynamically, and transparently update the shard map manager.</span></span> <span data-ttu-id="1e0a7-145">Однако удаление сегмента является необратимой операцией, в ходе которой также необходимо удалить все данные этого сегмента.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-145">However, removing a shard is a destructive operation that also requires deleting all the data in that shard.</span></span>

<span data-ttu-id="1e0a7-146">Если приложению требуется разбить сегмент на два отдельных сегмента или объединить их, можно использовать [средство разделения и объединения](/azure/sql-database/sql-database-elastic-scale-overview-split-and-merge).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-146">If an application needs to split a shard into two separate shards or combine shards, use the [split-merge tool](/azure/sql-database/sql-database-elastic-scale-overview-split-and-merge).</span></span> <span data-ttu-id="1e0a7-147">Это средство работает как веб-служба Azure, безопасно перенося данные между сегментами.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-147">This tool runs as an Azure web service, and migrates data safely between shards.</span></span>

<span data-ttu-id="1e0a7-148">Такая схема секционирования способна значительно повлиять на производительность системы.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-148">The partitioning scheme can significantly impact the performance of your system.</span></span> <span data-ttu-id="1e0a7-149">Она также может влиять на скорость добавления или удаления сегментов, а также повторного секционирования данных между сегментами.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-149">It can also affect the rate at which shards have to be added or removed, or that data must be repartitioned across shards.</span></span> <span data-ttu-id="1e0a7-150">Вот несколько рекомендаций.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-150">Consider the following points:</span></span>

- <span data-ttu-id="1e0a7-151">Группируйте используемые вместе данные в одном сегменте и избегайте операций с доступом к данным, хранящимся в нескольких сегментах.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-151">Group data that is used together in the same shard, and avoid operations that access data from multiple shards.</span></span> <span data-ttu-id="1e0a7-152">Сегмент сам является базой данных SQL, а межбазовые соединения должны выполняться на стороне клиента.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-152">A shard is a SQL database in its own right, and cross-database joins must be performed on the client side.</span></span>

    <span data-ttu-id="1e0a7-153">Хотя база данных SQL Azure не поддерживает межбазовые соединения, используйте средства эластичной базы данных для выполнения [запросов к нескольким сегментам](/azure/sql-database/sql-database-elastic-scale-multishard-querying).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-153">Although SQL Database does not support cross-database joins, you can use the Elastic Database tools to perform [mutli-shard queries](/azure/sql-database/sql-database-elastic-scale-multishard-querying).</span></span> <span data-ttu-id="1e0a7-154">При запросе к нескольким сегментам отдельные запросы направляются к каждой базе данных, а полученные результаты объединяются.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-154">A multi-shard query sends individual queries to each database and merges the results.</span></span>

- <span data-ttu-id="1e0a7-155">Не создавайте такую систему, в которой есть зависимости между сегментами.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-155">Don't design a system that has dependencies between shards.</span></span> <span data-ttu-id="1e0a7-156">Ограничения целостности данных, триггеры и хранимые процедуры в одной базе данных не могут ссылаться на объекты в другой базе данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-156">Referential integrity constraints, triggers, and stored procedures in one database cannot reference objects in another.</span></span>

- <span data-ttu-id="1e0a7-157">При наличии эталонных данных, которые часто используется при выполнении запросов, рассмотрите возможность репликации данных между сегментами.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-157">If you have reference data that is frequently used by queries, consider replicating this data across shards.</span></span> <span data-ttu-id="1e0a7-158">Такой подход может исключить необходимость в соединениях между базами данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-158">This approach can remove the need to join data across databases.</span></span> <span data-ttu-id="1e0a7-159">В идеальном случае такие данные должны быть статическими или медленно изменяющимися, чтобы максимально упростить репликацию и снизить вероятность устаревания данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-159">Ideally, such data should be static or slow-moving, to minimize the replication effort and reduce the chances of it becoming stale.</span></span>

- <span data-ttu-id="1e0a7-160">Шардлеты, принадлежащие к одной карте сегментов, должны иметь одинаковую схему.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-160">Shardlets that belong to the same shard map should have the same schema.</span></span> <span data-ttu-id="1e0a7-161">В Базе данных SQL это не является обязательным, но управление данными и запросами становится очень сложным, если шардлеты имеют разные схемы.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-161">This rule is not enforced by SQL Database, but data management and querying becomes very complex if each shardlet has a different schema.</span></span> <span data-ttu-id="1e0a7-162">Вместо этого создайте отдельные карты сегментов для каждой схемы.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-162">Instead, create separate shard maps for each schema.</span></span> <span data-ttu-id="1e0a7-163">Помните, что данные, принадлежащие к разным шардлетам, можно хранить в одном сегменте.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-163">Remember that data belonging to different shardlets can be stored in the same shard.</span></span>

- <span data-ttu-id="1e0a7-164">Транзакционные операции поддерживаются только для данных одного сегмента, но не между сегментами.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-164">Transactional operations are only supported for data within a shard, and not across shards.</span></span> <span data-ttu-id="1e0a7-165">Транзакции могут охватывать шардлеты при условии, что они являются частью одного сегмента.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-165">Transactions can span shardlets as long as they are part of the same shard.</span></span> <span data-ttu-id="1e0a7-166">Таким образом, если в соответствии с вашей бизнес-логикой требуется выполнять транзакции, храните данные в одном сегменте или выбирайте итоговую согласованность.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-166">Therefore, if your business logic needs to perform transactions, either store the data in the same shard or implement eventual consistency.</span></span>

- <span data-ttu-id="1e0a7-167">Размещайте сегменты поближе к пользователям, которые обращаются к данным в этих сегментах.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-167">Place shards close to the users that access the data in those shards.</span></span> <span data-ttu-id="1e0a7-168">Эта стратегия помогает сократить задержку.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-168">This strategy helps reduce latency.</span></span>

- <span data-ttu-id="1e0a7-169">Избегайте смешения активных и относительно неактивных сегментов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-169">Avoid having a mixture of highly active and relatively inactive shards.</span></span> <span data-ttu-id="1e0a7-170">Попробуйте равномерно распределить нагрузку по сегментам.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-170">Try to spread the load evenly across shards.</span></span> <span data-ttu-id="1e0a7-171">Для этого может потребоваться хэшировать ключи сегментирования.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-171">This might require hashing the sharding keys.</span></span> <span data-ttu-id="1e0a7-172">При географическом распределении сегментов убедитесь, что хэшированные ключи соответствуют шардлетам, хранящимся в сегментах, которые находятся рядом с использующими эти данные пользователями.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-172">If you are geo-locating shards, make sure that the hashed keys map to shardlets held in shards stored close to the users that access that data.</span></span>

### <a name="partitioning-azure-table-storage"></a><span data-ttu-id="1e0a7-173">Секционирование хранилища таблиц Microsoft Azure</span><span class="sxs-lookup"><span data-stu-id="1e0a7-173">Partitioning Azure table storage</span></span>

<span data-ttu-id="1e0a7-174">Хранилище таблиц Azure является хранилищем ключей и значений, которое разработано на основе секционирования.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-174">Azure table storage is a key-value store that's designed around partitioning.</span></span> <span data-ttu-id="1e0a7-175">Все сущности хранятся в секции, а секции управляются внутренне хранилищем таблиц Azure.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-175">All entities are stored in a partition, and partitions are managed internally by Azure table storage.</span></span> <span data-ttu-id="1e0a7-176">Каждая сущность, хранящаяся в таблице, должна предоставить ключ, состоящий из двух компонентов:</span><span class="sxs-lookup"><span data-stu-id="1e0a7-176">Each entity stored in a table must provide a two-part key that includes:</span></span>

- <span data-ttu-id="1e0a7-177">**Ключ секции**.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-177">**The partition key**.</span></span> <span data-ttu-id="1e0a7-178">Это строковое значение, определяющее секцию, в которой хранилище таблиц Azure размещает сущность.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-178">This is a string value that determines the partition where Azure table storage will place the entity.</span></span> <span data-ttu-id="1e0a7-179">Все сущности с одинаковым ключом секции хранятся в одной секции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-179">All entities with the same partition key are stored in the same partition.</span></span>

- <span data-ttu-id="1e0a7-180">**Ключ строки**.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-180">**The row key**.</span></span> <span data-ttu-id="1e0a7-181">Это строковое значение, определяющее сущность в секции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-181">This is a string value that identifies the entity within the partition.</span></span> <span data-ttu-id="1e0a7-182">Все сущности в секции сортируются лексически в порядке возрастания с помощью этого ключа.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-182">All entities within a partition are sorted lexically, in ascending order, by this key.</span></span> <span data-ttu-id="1e0a7-183">Сочетание ключа секции и ключа строки должно быть уникальным для каждой сущности, а его длина не может превышать 1 КБ.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-183">The partition key/row key combination must be unique for each entity and cannot exceed 1 KB in length.</span></span>

<span data-ttu-id="1e0a7-184">При добавлении сущности в таблицу с ранее неиспользуемым ключом секции хранилище таблиц Azure создаст новую секцию для этой сущности.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-184">If an entity is added to a table with a previously unused partition key, Azure table storage creates a new partition for this entity.</span></span> <span data-ttu-id="1e0a7-185">Другие сущности с одинаковым ключом секции будут храниться в одной секции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-185">Other entities with the same partition key will be stored in the same partition.</span></span>

<span data-ttu-id="1e0a7-186">Этот механизм эффективно реализует стратегию автоматического масштабирования.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-186">This mechanism effectively implements an automatic scale-out strategy.</span></span> <span data-ttu-id="1e0a7-187">Каждая секция хранится на одном сервере в центре обработки данных Azure, чтобы обеспечить быстрое выполнение запросов, получающих данные из одной секции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-187">Each partition is stored on the same server in an Azure datacenter to help ensure that queries that retrieve data from a single partition run quickly.</span></span>

<span data-ttu-id="1e0a7-188">Корпорация Майкрософт опубликовала [целевые показатели масштабируемости] для службы хранилища Azure.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-188">Microsoft has published [scalability targets] for Azure Storage.</span></span> <span data-ttu-id="1e0a7-189">Если для вашей системы высока вероятность превышения этих ограничений, рассмотрите возможность разделения сущностей на несколько таблиц.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-189">If your system is likely to exceed these limits, consider splitting entities into multiple tables.</span></span> <span data-ttu-id="1e0a7-190">Используйте вертикальное секционирование и разделите поля на группы, которые, скорее всего, используются вместе.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-190">Use vertical partitioning to divide the fields into the groups that are most likely to be accessed together.</span></span>

<span data-ttu-id="1e0a7-191">На схеме ниже показан пример логической структуры для учетной записи хранения.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-191">The following diagram shows the logical structure of an example storage account.</span></span> <span data-ttu-id="1e0a7-192">Учетная запись хранения содержит три таблицы со сведениями о клиентах, продуктах и заказах.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-192">The storage account contains three tables: Customer Info, Product Info, and Order Info.</span></span>

![Таблицы и секции в примере учетной записи хранения](./images/data-partitioning/TableStorage.png)

<span data-ttu-id="1e0a7-194">Каждая таблица содержит несколько секций.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-194">Each table has multiple partitions.</span></span>

- <span data-ttu-id="1e0a7-195">В таблице сведений о клиентах данные секционируются по городам, в которых находятся клиенты.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-195">In the Customer Info table, the data is partitioned according to the city where the customer is located.</span></span> <span data-ttu-id="1e0a7-196">Ключ строки содержит идентификатор клиента.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-196">The row key contains the customer ID.</span></span>
- <span data-ttu-id="1e0a7-197">В таблице сведений о продукции продукты секционированы по категориям, а ключ строки содержит номер продукта.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-197">In the Product Info table, products are partitioned by product category, and the row key contains the product number.</span></span>
- <span data-ttu-id="1e0a7-198">В таблице сведений о заказах заказы секционируются по дате заказа, а ключ строки указывает время получения заказа.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-198">In the Order Info table, the orders are partitioned by order date, and the row key specifies the time the order was received.</span></span> <span data-ttu-id="1e0a7-199">Обратите внимание, что все данные в каждой секции упорядочены с помощью ключа строки.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-199">Note that all data is ordered by the row key in each partition.</span></span>

<span data-ttu-id="1e0a7-200">При проектировании сущностей для хранилища таблиц Azure учитывайте следующие моменты.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-200">Consider the following points when you design your entities for Azure table storage:</span></span>

- <span data-ttu-id="1e0a7-201">При выборе ключа секции и ключа строки необходимо учитывать способ доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-201">Select a partition key and row key by how the data is accessed.</span></span> <span data-ttu-id="1e0a7-202">Необходимо выбрать сочетание ключа секции и ключа строки, которое поддерживает большинство запросов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-202">Choose a partition key/row key combination that supports the majority of your queries.</span></span> <span data-ttu-id="1e0a7-203">Наиболее эффективные запросы будут получать данные, указав ключ секции и ключ строки.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-203">The most efficient queries retrieve data by specifying the partition key and the row key.</span></span> <span data-ttu-id="1e0a7-204">Запросы, которые определяют ключ секции и диапазон ключей строк, могут быть выполнены путем сканирования одной секции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-204">Queries that specify a partition key and a range of row keys can be completed by scanning a single partition.</span></span> <span data-ttu-id="1e0a7-205">Это относительно быстро, поскольку данные хранятся в порядке значений ключей строк.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-205">This is relatively fast because the data is held in row key order.</span></span> <span data-ttu-id="1e0a7-206">Если в запросах не указано, какую секцию сканировать, сканируются все секции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-206">If queries don't specify which partition to scan, every partition must be scanned.</span></span>

- <span data-ttu-id="1e0a7-207">Если у сущности есть один естественный ключ, используйте его в качестве ключа секции и укажите пустую строку в качестве ключа строки.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-207">If an entity has one natural key, then use it as the partition key and specify an empty string as the row key.</span></span> <span data-ttu-id="1e0a7-208">Если сущность имеет составной ключ, состоящий из двух свойств, выберите наиболее медленно изменяющееся свойство в качестве ключа секции, а второе — в качестве ключа строки.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-208">If an entity has a composite key consisting of two properties, select the slowest changing property as the partition key and the other as the row key.</span></span> <span data-ttu-id="1e0a7-209">Если сущность имеет более двух свойств ключа, используйте объединение свойств, чтобы указать ключи секций и строк.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-209">If an entity has more than two key properties, use a concatenation of properties to provide the partition and row keys.</span></span>

- <span data-ttu-id="1e0a7-210">Если вы регулярно выполняете запросы, которые ищут данные с использованием других полей, кроме ключей секций и строк, реализуйте [шаблон таблицы индексов](../patterns/index-table.md) или используйте отдельное хранилище данных с поддержкой индексирования, например Cosmos DB.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-210">If you regularly perform queries that look up data by using fields other than the partition and row keys, consider implementing the [Index Table pattern](../patterns/index-table.md), or consider using a different data store that supports indexing, such as Cosmos DB.</span></span>

- <span data-ttu-id="1e0a7-211">Если вы создаете ключи секций с помощью монотонной последовательности (например 0001, 0002, 0003) и каждая секция содержит только ограниченный объем данных, хранилище таблиц Azure может физически сгруппировать эти секции вместе на одном сервере.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-211">If you generate partition keys by using a monotonic sequence (such as "0001", "0002", "0003") and each partition only contains a limited amount of data, Azure table storage can physically group these partitions together on the same server.</span></span> <span data-ttu-id="1e0a7-212">При использовании службы хранилища Azure предполагается, что приложение, скорее всего, будет выполнять запросы к смежным секциям (запросы к диапазону) и что оно оптимизировано для такой ситуации.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-212">Azure Storage assumes that the application is most likely to perform queries across a contiguous range of partitions (range queries) and is optimized for this case.</span></span> <span data-ttu-id="1e0a7-213">Но такой подход может привести к дисбалансу, так как все операции добавления новых сущностей, вероятно, будут выполняться относительно одного конца этого диапазона.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-213">However, this approach can lead to hotspots, because all insertions of new entities are likely to be concentrated at one end the contiguous range.</span></span> <span data-ttu-id="1e0a7-214">Он также может снизить масштабируемость.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-214">It can also reduce scalability.</span></span> <span data-ttu-id="1e0a7-215">Чтобы более равномерно распределить нагрузку, рассмотрите возможность хэширования ключа секции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-215">To spread the load more evenly, consider hashing the partition key.</span></span>

- <span data-ttu-id="1e0a7-216">Хранилище таблиц Azure поддерживает транзакционные операции для сущностей, которые относятся к одной секции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-216">Azure table storage supports transactional operations for entities that belong to the same partition.</span></span> <span data-ttu-id="1e0a7-217">Приложение может выполнять несколько операций вставки, обновления, удаления или объединения как одну неделимую операцию, если число сущностей транзакции не превышает 100, а размер полезных данных запроса — 4 МБ.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-217">An application can perform multiple insert, update, delete, replace, or merge operations as an atomic unit, as long as the transaction doesn't include more than 100 entities and the payload of the request doesn't exceed 4 MB.</span></span> <span data-ttu-id="1e0a7-218">Операции, охватывающие несколько секций, не являются транзакционными и могут требовать реализации итоговой согласованности.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-218">Operations that span multiple partitions are not transactional, and might require you to implement eventual consistency.</span></span> <span data-ttu-id="1e0a7-219">Дополнительные сведения о хранилище таблиц и транзакциях см. в статье [Performing Entity Group Transactions] (Выполнение групповых транзакций для сущности).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-219">For more information about table storage and transactions, see [Performing entity group transactions].</span></span>

- <span data-ttu-id="1e0a7-220">Учитывайте свойства ключа секции:</span><span class="sxs-lookup"><span data-stu-id="1e0a7-220">Consider the granularity of the partition key:</span></span>

  - <span data-ttu-id="1e0a7-221">Использование одного и того же ключа секции для каждой сущности приведет к созданию одной секции, хранящейся на одном сервере.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-221">Using the same partition key for every entity results in a single partition that's held on one server.</span></span> <span data-ttu-id="1e0a7-222">В результате масштабирование секции будет затруднено, и нагрузка на одном сервере возрастет.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-222">This prevents the partition from scaling out and focuses the load on a single server.</span></span> <span data-ttu-id="1e0a7-223">Следовательно, этот подход применим только для хранения небольшого количества сущностей.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-223">As a result, this approach is only suitable for storing a small number of entities.</span></span> <span data-ttu-id="1e0a7-224">Но он гарантирует, что все сущности смогут участвовать в транзакциях группы сущностей.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-224">However, it does ensure that all entities can participate in entity group transactions.</span></span>

  - <span data-ttu-id="1e0a7-225">Использование уникального ключа секции для каждой сущности приведет к созданию службой хранилища таблиц отдельных секций для каждой сущности, в результате чего может появиться большое количество небольших секций.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-225">Using a unique partition key for every entity causes the table storage service to create a separate partition for each entity, possibly resulting in a large number of small partitions.</span></span> <span data-ttu-id="1e0a7-226">Этот подход лучше поддается масштабированию, чем подход с использованием одного ключа секции, но транзакции группы сущностей невозможны.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-226">This approach is more scalable than using a single partition key, but entity group transactions are not possible.</span></span> <span data-ttu-id="1e0a7-227">Кроме того запросы, получающие более одной сущности, могут включать чтение с нескольких серверов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-227">Also, queries that fetch more than one entity might involve reading from more than one server.</span></span> <span data-ttu-id="1e0a7-228">Но, если приложение выполняет запросы к диапазону, использование монотонной последовательности ключей секций может помочь оптимизировать такие запросы.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-228">However, if the application performs range queries, then using a monotonic sequence for the partition keys might help to optimize these queries.</span></span>

  - <span data-ttu-id="1e0a7-229">Совместное использование ключа секции в подмножестве сущностей позволяет группировать связанные сущности в одну секцию.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-229">Sharing the partition key across a subset of entities makes it possible to group related entities in the same partition.</span></span> <span data-ttu-id="1e0a7-230">Операции, включающие связанные сущности, можно выполнить с помощью транзакции группы сущностей, и запросы, получающие набор связанных сущностей, могут удовлетворяться путем доступа к одному серверу.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-230">Operations that involve related entities can be performed by using entity group transactions, and queries that fetch a set of related entities can be satisfied by accessing a single server.</span></span>

<span data-ttu-id="1e0a7-231">Дополнительные сведения см. в статье [Azure Storage Table Design Guide].</span><span class="sxs-lookup"><span data-stu-id="1e0a7-231">For more information, see [Azure storage table design guide].</span></span>

## <a name="partitioning-azure-blob-storage"></a><span data-ttu-id="1e0a7-232">Секционирование хранилища BLOB-объектов Azure</span><span class="sxs-lookup"><span data-stu-id="1e0a7-232">Partitioning Azure blob storage</span></span>

<span data-ttu-id="1e0a7-233">Хранилище BLOB-объектов Azure позволяет хранить большие двоичные объекты.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-233">Azure blob storage makes it possible to hold large binary objects.</span></span> <span data-ttu-id="1e0a7-234">Используйте блочные BLOB-объекты в сценариях, где требуется быстро отправлять или скачивать большие объемы данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-234">Use block blobs in scenarios when you need to upload or download large volumes of data quickly.</span></span> <span data-ttu-id="1e0a7-235">Используйте страничные BLOB-объекты для приложений, требующих случайного, а не последовательного доступа к частям данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-235">Use page blobs for applications that require random rather than serial access to parts of the data.</span></span>

<span data-ttu-id="1e0a7-236">Каждый BLOB-объект (блочный или страничный) удерживается в контейнере в учетной записи хранения Azure.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-236">Each blob (either block or page) is held in a container in an Azure storage account.</span></span> <span data-ttu-id="1e0a7-237">Контейнеры можно использовать для группировки связанных BLOB-объектов с одинаковыми требованиями безопасности.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-237">You can use containers to group related blobs that have the same security requirements.</span></span> <span data-ttu-id="1e0a7-238">Это группирование на логическом, а не на физическом уровне.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-238">This grouping is logical rather than physical.</span></span> <span data-ttu-id="1e0a7-239">Внутри контейнера каждый BLOB-объект имеет уникальное имя.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-239">Inside a container, each blob has a unique name.</span></span>

<span data-ttu-id="1e0a7-240">Ключ секции для большого двоичного объекта состоит из имен учетной записи, контейнера и большого двоичного объекта.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-240">The partition key for a blob is account name + container name + blob name.</span></span> <span data-ttu-id="1e0a7-241">Данные распределяются по диапазонам с помощью ключа секции, а затем эти диапазоны распределяются по системе.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-241">The partition key is used to partition data into ranges and these ranges are load-balanced across the system.</span></span> <span data-ttu-id="1e0a7-242">Большие двоичные объекты могут быть распределены по нескольким серверам для развертывания доступа к ним, но один большой двоичный объект может обслуживаться только одним сервером.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-242">Blobs can be distributed across many servers in order to scale out access to them, but a single blob can only be served by a single server.</span></span>

<span data-ttu-id="1e0a7-243">Если в схеме именования используются метки времени или числовые идентификаторы, это может привести к чрезмерному трафику к одной секции, затрудняя эффективную балансировку нагрузки системой.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-243">If your naming scheme uses timestamps or numerical identifiers, it can lead to excessive traffic going to one partition, limiting the system from effectively load balancing.</span></span> <span data-ttu-id="1e0a7-244">Например, при ежедневных операциях с BLOB-объектом с меткой времени вида *гггг-мм-дд*, весь трафик такой операции направляется на один сервер секционирования.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-244">For instance, if you have daily operations that use a blob object with a timestamp such as *yyyy-mm-dd*, all the traffic for that operation would go to a single partition server.</span></span> <span data-ttu-id="1e0a7-245">Вместо этого рекомендуется добавлять к именам трехзначный хэш в виде префикса.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-245">Instead, consider prefixing the name with a 3-digit hash.</span></span> <span data-ttu-id="1e0a7-246">Дополнительные сведения см. в статье [Соглашение об именовании секций](/azure/storage/common/storage-performance-checklist#subheading47).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-246">For more information, see [Partition Naming Convention](/azure/storage/common/storage-performance-checklist#subheading47)</span></span>

<span data-ttu-id="1e0a7-247">Действия записи одного блока или страницы являются атомарными в отличие от операций, охватывающих блоки, страницы или BLOB-объекты.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-247">The actions of writing a single block or page are atomic, but operations that span blocks, pages, or blobs are not.</span></span> <span data-ttu-id="1e0a7-248">Если требуется обеспечить согласованность при выполнении операций записи всех блоков, страниц и BLOB-объектов, необходимо убрать блокировку записи с помощью аренды BLOB-объекта.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-248">If you need to ensure consistency when performing write operations across blocks, pages, and blobs, take out a write lock by using a blob lease.</span></span>

## <a name="partitioning-azure-storage-queues"></a><span data-ttu-id="1e0a7-249">Секционирование очередей хранилища Azure</span><span class="sxs-lookup"><span data-stu-id="1e0a7-249">Partitioning Azure storage queues</span></span>

<span data-ttu-id="1e0a7-250">Очереди хранилища Azure позволяют реализовать асинхронный обмен сообщениями между процессами.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-250">Azure storage queues enable you to implement asynchronous messaging between processes.</span></span> <span data-ttu-id="1e0a7-251">Учетная запись хранения Azure может содержать любое количество очередей, и каждая очередь может содержать любое количество сообщений.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-251">An Azure storage account can contain any number of queues, and each queue can contain any number of messages.</span></span> <span data-ttu-id="1e0a7-252">Единственным ограничением является место, доступное в учетной записи хранения.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-252">The only limitation is the space that's available in the storage account.</span></span> <span data-ttu-id="1e0a7-253">Максимальный размер отдельного сообщения составляет 64 КБ.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-253">The maximum size of an individual message is 64 KB.</span></span> <span data-ttu-id="1e0a7-254">Если требуются сообщения большего размера, попробуйте использовать очереди служебной шины Azure.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-254">If you require messages bigger than this, then consider using Azure Service Bus queues instead.</span></span>

<span data-ttu-id="1e0a7-255">Каждая очередь хранилища имеет уникальное имя в пределах учетной записи хранения, где она содержится.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-255">Each storage queue has a unique name within the storage account that contains it.</span></span> <span data-ttu-id="1e0a7-256">Очереди секций Azure основаны на имени.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-256">Azure partitions queues based on the name.</span></span> <span data-ttu-id="1e0a7-257">Все сообщения одной очереди хранятся в одной секции, управляемой одним сервером.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-257">All messages for the same queue are stored in the same partition, which is controlled by a single server.</span></span> <span data-ttu-id="1e0a7-258">Различными очередями могут управлять разные серверы, чтобы сбалансировать нагрузку.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-258">Different queues can be managed by different servers to help balance the load.</span></span> <span data-ttu-id="1e0a7-259">Выделение очередей для серверов является прозрачным для приложений и пользователей.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-259">The allocation of queues to servers is transparent to applications and users.</span></span>

<span data-ttu-id="1e0a7-260">В приложении большого объема не используйте одну и ту же очередь хранилища для всех экземпляров приложения: этот подход может привести к тому, что на сервере образуется очередь, являющаяся горячей точкой.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-260">In a large-scale application, don't use the same storage queue for all instances of the application because this approach might cause the server that's hosting the queue to become a hotspot.</span></span> <span data-ttu-id="1e0a7-261">Используйте различные очереди для различных функциональных областей приложения.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-261">Instead, use different queues for different functional areas of the application.</span></span> <span data-ttu-id="1e0a7-262">Очереди хранилища Azure не поддерживают транзакции, поэтому направление сообщений в различные очереди должно мало влиять на согласованность обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-262">Azure storage queues do not support transactions, so directing messages to different queues should have little impact on messaging consistency.</span></span>

<span data-ttu-id="1e0a7-263">Очередь хранилища Azure может обрабатывать до 2 000 сообщений в секунду.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-263">An Azure storage queue can handle up to 2,000 messages per second.</span></span> <span data-ttu-id="1e0a7-264">Если необходимо обрабатывать сообщения с большей скоростью, рассмотрите возможность создания нескольких очередей.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-264">If you need to process messages at a greater rate than this, consider creating multiple queues.</span></span> <span data-ttu-id="1e0a7-265">Например, в глобальном приложении создайте отдельные очереди хранилища в отдельных учетных записях хранения для обработки экземпляров приложений, работающих в каждом регионе.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-265">For example, in a global application, create separate storage queues in separate storage accounts to handle application instances that are running in each region.</span></span>

## <a name="partitioning-azure-service-bus"></a><span data-ttu-id="1e0a7-266">Секционирование Служебной шины Azure</span><span class="sxs-lookup"><span data-stu-id="1e0a7-266">Partitioning Azure Service Bus</span></span>

<span data-ttu-id="1e0a7-267">Служебная шина Azure использует брокер сообщений для обработки сообщений, отправленных в очередь или раздел служебной шины.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-267">Azure Service Bus uses a message broker to handle messages that are sent to a Service Bus queue or topic.</span></span> <span data-ttu-id="1e0a7-268">По умолчанию все сообщения, отправленные в очередь или раздел, обрабатываются одним процессом брокера сообщений.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-268">By default, all messages that are sent to a queue or topic are handled by the same message broker process.</span></span> <span data-ttu-id="1e0a7-269">Эта архитектура может ограничить общую пропускную способность очереди сообщений.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-269">This architecture can place a limitation on the overall throughput of the message queue.</span></span> <span data-ttu-id="1e0a7-270">Однако можно секционировать очереди или разделы при их создании.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-270">However, you can also partition a queue or topic when it is created.</span></span> <span data-ttu-id="1e0a7-271">Это можно сделать, задав свойству *EnablePartitioning* описания очереди или раздела значение *true*.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-271">You do this by setting the *EnablePartitioning* property of the queue or topic description to *true*.</span></span>

<span data-ttu-id="1e0a7-272">Секционированная очередь или раздел делится на несколько фрагментов, для каждого из которых выполняется резервное копирование в отдельном хранилище сообщений и брокере сообщений.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-272">A partitioned queue or topic is divided into multiple fragments, each of which is backed by a separate message store and message broker.</span></span> <span data-ttu-id="1e0a7-273">Служебная шина отвечает за создание этих фрагментов и управление ими.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-273">Service Bus takes responsibility for creating and managing these fragments.</span></span> <span data-ttu-id="1e0a7-274">Когда приложение отправляет сообщение в секционированную очередь или раздел, служебная шина назначает сообщение фрагменту для этой очереди или раздела.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-274">When an application posts a message to a partitioned queue or topic, Service Bus assigns the message to a fragment for that queue or topic.</span></span> <span data-ttu-id="1e0a7-275">Когда приложение получает сообщение из очереди или подписки, служебная шина проверяет каждый фрагмент на наличие следующего доступного сообщения и передает его приложению для обработки.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-275">When an application receives a message from a queue or subscription, Service Bus checks each fragment for the next available message and then passes it to the application for processing.</span></span>

<span data-ttu-id="1e0a7-276">Эта структура позволяет распределять нагрузку между брокерами сообщений и хранилищами сообщений, повышая масштабируемость и доступность.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-276">This structure helps distribute the load across message brokers and message stores, increasing scalability and improving availability.</span></span> <span data-ttu-id="1e0a7-277">Если брокер или хранилище сообщений для одного фрагмента временно недоступны, служебная шина может получить сообщения от одного из оставшихся доступных фрагментов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-277">If the message broker or message store for one fragment is temporarily unavailable, Service Bus can retrieve messages from one of the remaining available fragments.</span></span>

<span data-ttu-id="1e0a7-278">Служебная шина присваивает сообщение фрагменту следующим образом.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-278">Service Bus assigns a message to a fragment as follows:</span></span>

- <span data-ttu-id="1e0a7-279">Если сообщение относится к сеансу, все сообщения с одинаковым значением свойства *SessionId* отправляются в один и тот же фрагмент.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-279">If the message belongs to a session, all messages with the same value for the *SessionId*  property are sent to the same fragment.</span></span>

- <span data-ttu-id="1e0a7-280">Если сообщение не относится к сеансу, но отправитель указал значение для свойства *PartitionKey*, все сообщения с тем же значением *PartitionKey* отправляются в тот же фрагмент.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-280">If the message does not belong to a session, but the sender has specified a value for the *PartitionKey* property, then all messages with the same *PartitionKey* value are sent to the same fragment.</span></span>

  > [!NOTE]
  > <span data-ttu-id="1e0a7-281">Если значения заданы обоим свойствам (*SessionId* и *PartitionKey*), они должны быть одинаковыми, иначе сообщение будет отклонено.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-281">If the *SessionId* and *PartitionKey* properties are both specified, then they must be set to the same value or the message will be rejected.</span></span>

- <span data-ttu-id="1e0a7-282">Если свойства *SessionId* и *PartitionKey* для сообщения не заданы, но включен поиск повторяющихся данных, будет использоваться свойство *MessageId*.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-282">If the *SessionId* and *PartitionKey* properties for a message are not specified, but duplicate detection is enabled, the *MessageId* property will be used.</span></span> <span data-ttu-id="1e0a7-283">Все сообщения с тем же значением *MessageId* будут направляться в тот же фрагмент.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-283">All messages with the same *MessageId* will be directed to the same fragment.</span></span>

- <span data-ttu-id="1e0a7-284">Если сообщения не содержат свойства *SessionId, PartitionKey* или *MessageId*, служебная шина назначает сообщения фрагментам по очереди.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-284">If messages do not include a *SessionId, PartitionKey,* or *MessageId* property, then Service Bus assigns messages to fragments sequentially.</span></span> <span data-ttu-id="1e0a7-285">Если фрагмент недоступен, служебная шина перейдет к следующему.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-285">If a fragment is unavailable, Service Bus will move on to the next.</span></span> <span data-ttu-id="1e0a7-286">Таким образом, временная ошибка в инфраструктуре обмена сообщениями не вызовет сбой операции отправки сообщения.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-286">This means that a temporary fault in the messaging infrastructure does not cause the message-send operation to fail.</span></span>

<span data-ttu-id="1e0a7-287">При принятии решения о том, стоит ли и как именно секционировать очередь сообщений или раздел служебной шины, рекомендуется учитывать следующее.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-287">Consider the following points when deciding if or how to partition a Service Bus message queue or topic:</span></span>

- <span data-ttu-id="1e0a7-288">Очереди и разделы служебной шины создаются в области пространства имен служебной шины.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-288">Service Bus queues and topics are created within the scope of a Service Bus namespace.</span></span> <span data-ttu-id="1e0a7-289">В настоящее время служебная шина обеспечивает до 100 секционированных очередей или разделов на пространство имен.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-289">Service Bus currently allows up to 100 partitioned queues or topics per namespace.</span></span>

- <span data-ttu-id="1e0a7-290">Каждое пространство имен служебной шины налагает квоты на доступные ресурсы, такие как количество подписок на раздел, количество параллельных запросов на отправку и получение в секунду, а также максимальное число одновременных подключений, которые можно установить.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-290">Each Service Bus namespace imposes quotas on the available resources, such as the number of subscriptions per topic, the number of concurrent send and receive requests per second, and the maximum number of concurrent connections that can be established.</span></span> <span data-ttu-id="1e0a7-291">Эти квоты описаны в статье [Квоты на служебную шину].</span><span class="sxs-lookup"><span data-stu-id="1e0a7-291">These quotas are documented in [Service Bus quotas].</span></span> <span data-ttu-id="1e0a7-292">Если предполагается, что эти значения будут превышены, создайте дополнительные пространства имен с собственными очередями и разделами и распределите работу по этим пространствам имен.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-292">If you expect to exceed these values, then create additional namespaces with their own queues and topics, and spread the work across these namespaces.</span></span> <span data-ttu-id="1e0a7-293">Например, в глобальном приложении создайте отдельные пространства имен в каждом регионе и настройте экземпляры приложения на использование очередей и разделов в ближайшем пространстве имен.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-293">For example, in a global application, create separate namespaces in each region and configure application instances to use the queues and topics in the nearest namespace.</span></span>

- <span data-ttu-id="1e0a7-294">Сообщения, отправленные в рамках транзакции, должны указать ключ секции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-294">Messages that are sent as part of a transaction must specify a partition key.</span></span> <span data-ttu-id="1e0a7-295">Это может быть свойство *SessionId*, *PartitionKey* или *MessageId*.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-295">This can be a *SessionId*, *PartitionKey*, or *MessageId* property.</span></span> <span data-ttu-id="1e0a7-296">Все сообщения, отправленные в рамках одной транзакции, должны указать один и тот же ключ секции, так как их должен обрабатывать один брокер сообщений.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-296">All messages that are sent as part of the same transaction must specify the same partition key because they must be handled by the same message broker process.</span></span> <span data-ttu-id="1e0a7-297">Невозможно отправить сообщения в различные очереди или разделы в рамках одной транзакции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-297">You cannot send messages to different queues or topics within the same transaction.</span></span>

- <span data-ttu-id="1e0a7-298">Невозможно настроить автоматическое удаление секционированной очереди или раздела, когда они становятся неактивными.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-298">Partitioned queues and topics can't be configured to be automatically deleted when they become idle.</span></span>

- <span data-ttu-id="1e0a7-299">При построении межплатформенных или гибридных решений в настоящее время нельзя использовать секционированные очереди и расширенный протокол управления очередью сообщений (AMQP).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-299">Partitioned queues and topics can't currently be used with the Advanced Message Queuing Protocol (AMQP) if you are building cross-platform or hybrid solutions.</span></span>

## <a name="partitioning-cosmos-db"></a><span data-ttu-id="1e0a7-300">Секционирование Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="1e0a7-300">Partitioning Cosmos DB</span></span>

<span data-ttu-id="1e0a7-301">Azure Cosmos DB — это база данных NoSQL для хранения документов JSON, использующая [API SQL Azure Cosmos DB][cosmosdb-sql-api].</span><span class="sxs-lookup"><span data-stu-id="1e0a7-301">Azure Cosmos DB is a NoSQL database that can store JSON documents using the [Azure Cosmos DB SQL API][cosmosdb-sql-api].</span></span> <span data-ttu-id="1e0a7-302">Документ в базе данных Cosmos DB является представлением сериализованных данных JSON объекта или другого блока данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-302">A document in a Cosmos DB database is a JSON-serialized representation of an object or other piece of data.</span></span> <span data-ttu-id="1e0a7-303">Фиксированные схемы не применяются, за исключением того, что каждый документ должен содержать уникальный идентификатор.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-303">No fixed schemas are enforced except that every document must contain a unique ID.</span></span>

<span data-ttu-id="1e0a7-304">Документы организованы в коллекции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-304">Documents are organized into collections.</span></span> <span data-ttu-id="1e0a7-305">Связанные документы можно группировать в коллекции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-305">You can group related documents together in a collection.</span></span> <span data-ttu-id="1e0a7-306">Например, в системе, которая хранит сообщения блогов, можно хранить содержимое каждой записи блога в виде документа в коллекции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-306">For example, in a system that maintains blog postings, you can store the contents of each blog post as a document in a collection.</span></span> <span data-ttu-id="1e0a7-307">Можно также создавать коллекции для каждого типа субъекта.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-307">You can also create collections for each subject type.</span></span> <span data-ttu-id="1e0a7-308">Кроме того, в мультитенантном приложении, таком как система, где разные авторы управляют собственными блогами и записями, можно секционировать блоги по авторам и создавать отдельную коллекцию для каждого автора.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-308">Alternatively, in a multitenant application, such as a system where different authors control and manage their own blog posts, you can partition blogs by author and create separate collections for each author.</span></span> <span data-ttu-id="1e0a7-309">Выделенное для коллекций дисковое пространство гибкое и может уменьшаться или увеличиваться по мере необходимости.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-309">The storage space that's allocated to collections is elastic and can shrink or grow as needed.</span></span>

<span data-ttu-id="1e0a7-310">Cosmos DB поддерживает автоматическое секционирование данных на основе ключа секции, определяемого приложением.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-310">Cosmos DB supports automatic partitioning of data based on an application-defined partition key.</span></span> <span data-ttu-id="1e0a7-311">*Логический раздел* — это секция, которая хранит все данные для значения ключа одной секции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-311">A *logical partition* is a partition that stores all the data for a single partition key value.</span></span> <span data-ttu-id="1e0a7-312">Все документы с одинаковым значением ключа раздела помещаются в один логический раздел.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-312">All documents that share the same value for the partition key are placed within the same logical partition.</span></span> <span data-ttu-id="1e0a7-313">Cosmos DB распространяет значения в соответствии с хэшем ключа секции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-313">Cosmos DB distributes values according to hash of the partition key.</span></span> <span data-ttu-id="1e0a7-314">Размер логического раздела не превышает 10 ГБ.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-314">A logical partition has a maximum size of 10 GB.</span></span> <span data-ttu-id="1e0a7-315">Следовательно, выбор ключа секции — это важное решение, которое принимается на этапе проектирования.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-315">Therefore, the choice of the partition key is an important decision at design time.</span></span> <span data-ttu-id="1e0a7-316">Выберите свойство с широким диапазоном значений и шаблоны доступа.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-316">Choose a property with a wide range of values and even access patterns.</span></span> <span data-ttu-id="1e0a7-317">См. дополнительные сведения о [секциях и масштабировании в базе данных Azure Cosmos DB](/azure/cosmos-db/partition-data).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-317">For more information, see [Partition and scale in Azure Cosmos DB](/azure/cosmos-db/partition-data).</span></span>

> [!NOTE]
> <span data-ttu-id="1e0a7-318">У каждой базы данных Cosmos DB свой *уровень производительности*, который определяет объем выделяемых для нее ресурсов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-318">Each Cosmos DB database has a *performance level* that determines the amount of resources it gets.</span></span> <span data-ttu-id="1e0a7-319">Каждый уровень производительности связан с ограничением частоты в виде *единицы запроса* (ЕЗ).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-319">A performance level is associated with a *request unit* (RU) rate limit.</span></span> <span data-ttu-id="1e0a7-320">Ограничение частоты RU определяет объем ресурсов, которые зарезервированы для этой коллекции и доступны для эксклюзивного использования этой коллекцией.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-320">The RU rate limit specifies the volume of resources that's reserved and available for exclusive use by that collection.</span></span> <span data-ttu-id="1e0a7-321">Стоимость коллекции зависит от выбранного для нее уровня производительности.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-321">The cost of a collection depends on the performance level that's selected for that collection.</span></span> <span data-ttu-id="1e0a7-322">Чем выше уровень производительность (и ограничение частоты RU), тем выше стоимость.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-322">The higher the performance level (and RU rate limit) the higher the charge.</span></span> <span data-ttu-id="1e0a7-323">Уровень производительности коллекции можно настроить с помощью портала Azure.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-323">You can adjust the performance level of a collection by using the Azure portal.</span></span> <span data-ttu-id="1e0a7-324">См. дополнительные сведения о [единицах запросов в базе данных Azure Cosmos DB][cosmos-db-ru].</span><span class="sxs-lookup"><span data-stu-id="1e0a7-324">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span>

<span data-ttu-id="1e0a7-325">Если механизм секционирования, предоставляемый Cosmos DB, не подходит, можно сегментировать данные на уровне приложения.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-325">If the partitioning mechanism that Cosmos DB provides is not sufficient, you may need to shard the data at the application level.</span></span> <span data-ttu-id="1e0a7-326">Коллекция документов предоставляет естественный механизм для секционирования данных в пределах отдельной базы данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-326">Document collections provide a natural mechanism for partitioning data within a single database.</span></span> <span data-ttu-id="1e0a7-327">Самый простой способ реализации сегментирования — создание коллекции для каждого сегмента.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-327">The simplest way to implement sharding is to create a collection for each shard.</span></span> <span data-ttu-id="1e0a7-328">Контейнеры — это логические ресурсы, которые могут охватывать один или несколько серверов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-328">Containers are logical resources and can span one or more servers.</span></span> <span data-ttu-id="1e0a7-329">Контейнеры фиксированного размера имеют максимальный размер в 10 ГБ и пропускную способность в 10 000 ЕЗ в секунду.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-329">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span></span> <span data-ttu-id="1e0a7-330">Для контейнеров неограниченного размера максимальный размер хранилища не предусмотрен, но необходимо указать ключ секции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-330">Unlimited containers do not have a maximum storage size, but must specify a partition key.</span></span> <span data-ttu-id="1e0a7-331">При сегментировании клиентское приложение должно направлять запросы в соответствующий сегмент, как правило, реализуя собственный механизм сопоставления на основе некоторых атрибутов данных, которые определяют ключ сегмента.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-331">With application sharding, the client application must direct requests to the appropriate shard, usually by implementing its own mapping mechanism based on some attributes of the data that define the shard key.</span></span>

<span data-ttu-id="1e0a7-332">Все базы данных создаются в контексте учетной записи базы данных Cosmos DB.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-332">All databases are created in the context of a Cosmos DB database account.</span></span> <span data-ttu-id="1e0a7-333">Одна учетная запись может содержать несколько баз данных. Также она определяет, в каком регионе создаются эти базы данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-333">A single account can contain several databases, and it specifies in which regions the databases are created.</span></span> <span data-ttu-id="1e0a7-334">Кроме того, для каждой учетной записи отдельно настраивается управление доступом.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-334">Each account also enforces its own access control.</span></span> <span data-ttu-id="1e0a7-335">С помощью учетных записей Cosmos DB вы можете выделить сегменты (коллекции в базах данных), географически расположенные рядом с пользователями, и настроить ограничения так, чтобы к ним подключались только такие пользователи.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-335">You can use Cosmos DB accounts to geo-locate shards (collections within databases) close to the users who need to access them, and enforce restrictions so that only those users can connect to them.</span></span>

<span data-ttu-id="1e0a7-336">Принимая решение о том, как секционировать данные с помощью API SQL Cosmos DB, учитывайте следующие аспекты:</span><span class="sxs-lookup"><span data-stu-id="1e0a7-336">Consider the following points when deciding how to partition data with the Cosmos DB SQL API:</span></span>

- <span data-ttu-id="1e0a7-337">**Ресурсы, доступные для базы данных API Cosmos DB, могут быть ограничены квотами учетной записи**.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-337">**The resources available to a Cosmos DB database are subject to the quota limitations of the account**.</span></span> <span data-ttu-id="1e0a7-338">Каждая база данных может содержать несколько коллекций, каждая из которых связана с уровнем производительности, который управляет ограничением частоты ЕЗ (зарезервированной пропускной способностью) для этой коллекции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-338">Each database can hold a number of collections, and each collection is associated with a performance level that governs the RU rate limit (reserved throughput) for that collection.</span></span> <span data-ttu-id="1e0a7-339">Дополнительные сведения см. в статье [Подписка Azure, границы, квоты и ограничения службы][azure-limits].</span><span class="sxs-lookup"><span data-stu-id="1e0a7-339">For more information, see [Azure subscription and service limits, quotas, and constraints][azure-limits].</span></span>

- <span data-ttu-id="1e0a7-340">**Каждый документ должен иметь атрибут, который используется для идентификации этого документа в пределах содержащей его коллекции**.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-340">**Each document must have an attribute that can be used to uniquely identify that document within the collection in which it is held**.</span></span> <span data-ttu-id="1e0a7-341">Этот атрибут отличается от ключа сегмента, который определяет, в какой коллекции содержится документ.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-341">This attribute is different from the shard key, which defines which collection holds the document.</span></span> <span data-ttu-id="1e0a7-342">Коллекция может содержать большое количество документов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-342">A collection can contain a large number of documents.</span></span> <span data-ttu-id="1e0a7-343">Теоретически она ограничена только максимальной длиной идентификатора документа.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-343">In theory, it's limited only by the maximum length of the document ID.</span></span> <span data-ttu-id="1e0a7-344">Идентификатор документа может включать до 255 символов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-344">The document ID can be up to 255 characters.</span></span>

- <span data-ttu-id="1e0a7-345">**Все операции с документом выполняются в контексте транзакции. Транзакции выполняются в той коллекции, где содержится документ.**</span><span class="sxs-lookup"><span data-stu-id="1e0a7-345">**All operations against a document are performed within the context of a transaction. Transactions are scoped to the collection in which the document is contained.**</span></span> <span data-ttu-id="1e0a7-346">Если произошел сбой операции, происходит откат выполняемой работы.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-346">If an operation fails, the work that it has performed is rolled back.</span></span> <span data-ttu-id="1e0a7-347">Пока выполняется операция с документом, любые сделанные изменения подвергаются изоляции уровня моментальных снимков.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-347">While a document is subject to an operation, any changes that are made are subject to snapshot-level isolation.</span></span> <span data-ttu-id="1e0a7-348">Этот механизм гарантирует, что если, например, запрос на создание нового документа завершается ошибкой, другой пользователь, одновременно запрашивающий базу данных, не увидит частичный документ, который затем удаляется.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-348">This mechanism guarantees that if, for example, a request to create a new document fails, another user who's querying the database simultaneously will not see a partial document that is then removed.</span></span>

- <span data-ttu-id="1e0a7-349">**Запросы к базам данных также ограничиваются уровнем коллекции**.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-349">**Database queries are also scoped to the collection level**.</span></span> <span data-ttu-id="1e0a7-350">Один запрос может получать данные только из одной коллекции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-350">A single query can retrieve data from only one collection.</span></span> <span data-ttu-id="1e0a7-351">Если требуется получить данные из нескольких коллекций, необходимо запросить каждую коллекцию отдельно и объединить результаты в коде приложения.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-351">If you need to retrieve data from multiple collections, you must query each collection individually and merge the results in your application code.</span></span>

- <span data-ttu-id="1e0a7-352">**Базы данных Cosmos DB поддерживают программируемые элементы, которые могут храниться в коллекции вместе с документами**.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-352">**Cosmos DB supports programmable items that can all be stored in a collection alongside documents**.</span></span> <span data-ttu-id="1e0a7-353">Это хранимые процедуры, определяемые пользователем функции и триггеры (на языке JavaScript).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-353">These include stored procedures, user-defined functions, and triggers (written in JavaScript).</span></span> <span data-ttu-id="1e0a7-354">Эти элементы могут получить доступ к любому документу в одной коллекции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-354">These items can access any document within the same collection.</span></span> <span data-ttu-id="1e0a7-355">Кроме того, эти элементы выполняются либо внутри области внешней транзакции (в случае триггера, срабатывающего в результате операций создания, удаления и замены документа), либо путем запуска новой транзакции (в случае хранимой процедуры, выполняемой в результате явного запроса клиента).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-355">Furthermore, these items run either inside the scope of the ambient transaction (in the case of a trigger that fires as the result of a create, delete, or replace operation performed against a document), or by starting a new transaction (in the case of a stored procedure that is run as the result of an explicit client request).</span></span> <span data-ttu-id="1e0a7-356">Если код в программируемом элементе создает исключение, транзакция откатывается.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-356">If the code in a programmable item throws an exception, the transaction is rolled back.</span></span> <span data-ttu-id="1e0a7-357">Чтобы сохранить целостность и согласованность между документами, можно использовать хранимые процедуры и триггеры, но эти документы всегда должны быть частью одной коллекции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-357">You can use stored procedures and triggers to maintain integrity and consistency between documents, but these documents must all be part of the same collection.</span></span>

- <span data-ttu-id="1e0a7-358">**В базах данных следует хранить такие коллекции, нагрузка на которые не превысит ограничения пропускной способности, установленных для соответствующего уровня производительности**.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-358">**The collections that you intend to hold in the databases should be unlikely to exceed the throughput limits defined by the performance levels of the collections**.</span></span> <span data-ttu-id="1e0a7-359">См. дополнительные сведения о [единицах запросов в базе данных Azure Cosmos DB][cosmos-db-ru].</span><span class="sxs-lookup"><span data-stu-id="1e0a7-359">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span> <span data-ttu-id="1e0a7-360">Если вы ожидаете, что нагрузка превысит эти ограничения, попробуйте распределить коллекции между базами данных в разных учетных записях, чтобы снизить нагрузку на каждую коллекцию.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-360">If you anticipate reaching these limits, consider splitting collections across databases in different accounts to reduce the load per collection.</span></span>

## <a name="partitioning-azure-search"></a><span data-ttu-id="1e0a7-361">Секционирование Поиска Azure</span><span class="sxs-lookup"><span data-stu-id="1e0a7-361">Partitioning Azure Search</span></span>

<span data-ttu-id="1e0a7-362">Возможность поиска данных часто является основным методом навигации и просмотра, который предоставляют многие веб-приложения.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-362">The ability to search for data is often the primary method of navigation and exploration that's provided by many web applications.</span></span> <span data-ttu-id="1e0a7-363">Она помогает пользователям быстро находить ресурсы (например продукты в приложении электронной коммерции) на основе сочетания условий поиска.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-363">It helps users find resources quickly (for example, products in an e-commerce application) based on combinations of search criteria.</span></span> <span data-ttu-id="1e0a7-364">Служба поиска Azure предоставляет возможности полнотекстового поиска по веб-содержимому и включает такие функции, как автозаполнение, предлагаемые запросы на основании совпадений и многогранная навигация.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-364">The Azure Search service provides full-text search capabilities over web content, and includes features such as type-ahead, suggested queries based on near matches, and faceted navigation.</span></span> <span data-ttu-id="1e0a7-365">Дополнительные сведения см. в статье [Что такое поиск Azure?]</span><span class="sxs-lookup"><span data-stu-id="1e0a7-365">For more information, see [What is Azure Search?].</span></span>

<span data-ttu-id="1e0a7-366">Служба поиска Azure хранит подлежащее поиску содержимое как документы JSON в базе данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-366">Azure Search stores searchable content as JSON documents in a database.</span></span> <span data-ttu-id="1e0a7-367">Можно определить индексы, которые указывают поля для поиска в этих документах, и предоставить эти определения службе поиска Azure.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-367">You define indexes that specify the searchable fields in these documents and provide these definitions to Azure Search.</span></span> <span data-ttu-id="1e0a7-368">Когда пользователь отправляет поисковый запрос, служба поиска Azure использует соответствующие индексы для поиска совпадающих элементов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-368">When a user submits a search request, Azure Search uses the appropriate indexes to find matching items.</span></span>

<span data-ttu-id="1e0a7-369">Чтобы снизить количество конфликтов, можно разделить хранилища, используемые службой поиска Azure, на 1, 2, 3, 4, 6 или 12 секций, и каждую секцию реплицировать до 6 раз.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-369">To reduce contention, the storage that's used by Azure Search can be divided into 1, 2, 3, 4, 6, or 12 partitions, and each partition can be replicated up to 6 times.</span></span> <span data-ttu-id="1e0a7-370">Произведение числа секций и числа реплик называется *единицей поиска* (SU).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-370">The product of the number of partitions multiplied by the number of replicas is called the *search unit* (SU).</span></span> <span data-ttu-id="1e0a7-371">Один экземпляр службы поиска Azure может содержать не более 36 единиц поиска (база данных с 12 секциями поддерживает не более 3 реплик).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-371">A single instance of Azure Search can contain a maximum of 36 SUs (a database with 12 partitions only supports a maximum of 3 replicas).</span></span>

<span data-ttu-id="1e0a7-372">Плата взимается за каждую единицу поиска, выделенную для службы.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-372">You are billed for each SU that is allocated to your service.</span></span> <span data-ttu-id="1e0a7-373">При увеличении объема содержимого для поиска или скорости запросов поиска можно добавить единицы поиска в существующий экземпляр службы поиска Azure для обработки дополнительной нагрузки.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-373">As the volume of searchable content increases or the rate of search requests grows, you can add SUs to an existing instance of Azure Search to handle the extra load.</span></span> <span data-ttu-id="1e0a7-374">Сама служба поиска Azure отвечает за равномерное распределение документов по секциям.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-374">Azure Search itself distributes the documents evenly across the partitions.</span></span> <span data-ttu-id="1e0a7-375">Сейчас стратегии секционирования вручную не поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-375">No manual partitioning strategies are currently supported.</span></span>

<span data-ttu-id="1e0a7-376">Каждая секция может содержать не более 15 миллионов документов или занимать не более 300 ГБ дискового пространства (в зависимости от того, какое значение ниже).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-376">Each partition can contain a maximum of 15 million documents or occupy 300 GB of storage space (whichever is smaller).</span></span> <span data-ttu-id="1e0a7-377">Можно создать до 50 индексов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-377">You can create up to 50 indexes.</span></span> <span data-ttu-id="1e0a7-378">Производительность службы зависит от сложности документов, доступных индексов и эффектов задержки в сети.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-378">The performance of the service varies and depends on the complexity of the documents, the available indexes, and the effects of network latency.</span></span> <span data-ttu-id="1e0a7-379">В среднем одна реплика (1 единица поиска) должна уметь обрабатывать 15 запросов в секунду (QPS), хотя рекомендуется выполнить тестирование производительности со своими данными, чтобы получить более точные показатели пропускной способности.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-379">On average, a single replica (1 SU) should be able to handle 15 queries per second (QPS), although we recommend performing benchmarking with your own data to obtain a more precise measure of throughput.</span></span> <span data-ttu-id="1e0a7-380">Дополнительные сведения см. в статье [Ограничения Поиска Azure].</span><span class="sxs-lookup"><span data-stu-id="1e0a7-380">For more information, see [Service limits in Azure Search].</span></span>

> [!NOTE]
> <span data-ttu-id="1e0a7-381">В документах для поиска можно хранить ограниченный набор типов данных: строки, логические значения, числовые данные, данные даты и времени и географические данные.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-381">You can store a limited set of data types in searchable documents, including strings, Booleans, numeric data, datetime data, and some geographical data.</span></span> <span data-ttu-id="1e0a7-382">Дополнительные сведения см. на странице [Поддерживаемые типы данных (служба поиска Azure)] (Поддерживаемые типы данных (поиск Azure)) на веб-сайте Майкрософт.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-382">For more details, see the page [Supported data types (Azure Search)] on the Microsoft website.</span></span>

<span data-ttu-id="1e0a7-383">Вы можете лишь частично контролировать то, как служба поиска Azure секционирует данные для каждого экземпляра службы.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-383">You have limited control over how Azure Search partitions data for each instance of the service.</span></span> <span data-ttu-id="1e0a7-384">Однако в глобальной среде можно повысить производительность и снизить задержку и количество конфликтов за счет секционирования самой службы одним из следующих способов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-384">However, in a global environment you might be able to improve performance and reduce latency and contention further by partitioning the service itself using either of the following strategies:</span></span>

- <span data-ttu-id="1e0a7-385">Создайте экземпляр службы поиска Azure в каждом географическом регионе и убедитесь, что клиентские приложения направляются к ближайшему доступному экземпляру.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-385">Create an instance of Azure Search in each geographic region, and ensure that client applications are directed towards the nearest available instance.</span></span> <span data-ttu-id="1e0a7-386">Эта стратегия требует своевременной репликации всех обновлений содержимого для поиска во всех экземплярах службы.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-386">This strategy requires that any updates to searchable content are replicated in a timely manner across all instances of the service.</span></span>

- <span data-ttu-id="1e0a7-387">Создайте два уровня службы поиска Azure:</span><span class="sxs-lookup"><span data-stu-id="1e0a7-387">Create two tiers of Azure Search:</span></span>

  - <span data-ttu-id="1e0a7-388">локальную службу в каждом регионе, которая содержит наиболее часто применяемые пользователями этого региона данные.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-388">A local service in each region that contains the data that's most frequently accessed by users in that region.</span></span> <span data-ttu-id="1e0a7-389">Пользователи могут направлять запросы в локальную службу для получения быстрых, но ограниченных результатов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-389">Users can direct requests here for fast but limited results.</span></span>
  - <span data-ttu-id="1e0a7-390">Глобальная служба, которая включает в себя все данные.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-390">A global service that encompasses all the data.</span></span> <span data-ttu-id="1e0a7-391">Пользователи могут направлять запросы в глобальную службу для получения менее быстрых, но более полных результатов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-391">Users can direct requests here for slower but more complete results.</span></span>

<span data-ttu-id="1e0a7-392">Этот подход наиболее эффективен при значительных региональных различиях в данных, по которым выполняется поиск.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-392">This approach is most suitable when there is a significant regional variation in the data that's being searched.</span></span>

## <a name="partitioning-azure-redis-cache"></a><span data-ttu-id="1e0a7-393">Секционирование кэша Redis для Azure</span><span class="sxs-lookup"><span data-stu-id="1e0a7-393">Partitioning Azure Redis Cache</span></span>

<span data-ttu-id="1e0a7-394">Кэш Redis для Azure предоставляет службу общего кэша в облаке, которая основана на хранилище данных Redis типа ключ-значение.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-394">Azure Redis Cache provides a shared caching service in the cloud that's based on the Redis key-value data store.</span></span> <span data-ttu-id="1e0a7-395">Как понятно из названия, кэш Redis для Azure создан как решение для кэширования.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-395">As its name implies, Azure Redis Cache is intended as a caching solution.</span></span> <span data-ttu-id="1e0a7-396">Поэтому его следует использовать только для хранения временных данных, а не как постоянное хранилище данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-396">Use it only for holding transient data and not as a permanent data store.</span></span> <span data-ttu-id="1e0a7-397">Приложения, использующие кэш Redis для Azure, должны иметь возможность продолжать работу, даже если кэш недоступен.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-397">Applications that utilize Azure Redis Cache should be able to continue functioning if the cache is unavailable.</span></span> <span data-ttu-id="1e0a7-398">Кэш Redis для Azure поддерживает первичную или вторичную репликацию для обеспечения высокой доступности, но сейчас максимальный размер кэша ограничен 53 ГБ.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-398">Azure Redis Cache supports primary/secondary replication to provide high availability, but currently limits the maximum cache size to 53 GB.</span></span> <span data-ttu-id="1e0a7-399">Если требуется больше места, необходимо создать дополнительные кэши.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-399">If you need more space than this, you must create additional caches.</span></span> <span data-ttu-id="1e0a7-400">Дополнительные сведения см. в статье [кэш Azure Redis].</span><span class="sxs-lookup"><span data-stu-id="1e0a7-400">For more information, see [Azure Redis Cache].</span></span>

<span data-ttu-id="1e0a7-401">Секционирование хранилища данных Redis включает в себя разбиение данных по экземплярам службы Redis.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-401">Partitioning a Redis data store involves splitting the data across instances of the Redis service.</span></span> <span data-ttu-id="1e0a7-402">Каждый экземпляр представляет одну секцию.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-402">Each instance constitutes a single partition.</span></span> <span data-ttu-id="1e0a7-403">Кэш Redis для Azure абстрагирует службы Redis за фасадом и не раскрывает их напрямую.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-403">Azure Redis Cache abstracts the Redis services behind a façade and does not expose them directly.</span></span> <span data-ttu-id="1e0a7-404">Самый простой способ реализации секционирования — создание нескольких экземпляров кэша Redis для Azure и распределение данных между ними.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-404">The simplest way to implement partitioning is to create multiple Azure Redis Cache instances and spread the data across them.</span></span>

<span data-ttu-id="1e0a7-405">Каждый элемент данных можно связать с идентификатором (ключом секции), который указывает, в каком кэше его следует хранить.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-405">You can associate each data item with an identifier (a partition key) that specifies which cache stores the data item.</span></span> <span data-ttu-id="1e0a7-406">Логика клиентского приложения может использовать этот идентификатор для перенаправления запросов в соответствующую секцию.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-406">The client application logic can then use this identifier to route requests to the appropriate partition.</span></span> <span data-ttu-id="1e0a7-407">Эта схема очень проста, но при изменении схемы секционирования (например, если создаются дополнительные экземпляры кэша Redis для Azure) может потребоваться изменение конфигурации клиентских приложений.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-407">This scheme is very simple, but if the partitioning scheme changes (for example, if additional Azure Redis Cache instances are created), client applications might need to be reconfigured.</span></span>

<span data-ttu-id="1e0a7-408">Собственный Redis (не кэш Redis для Azure) поддерживает серверную часть секционирования на основе кластеризации Redis.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-408">Native Redis (not Azure Redis Cache) supports server-side partitioning based on Redis clustering.</span></span> <span data-ttu-id="1e0a7-409">При таком подходе данные делятся поровну между серверами с помощью механизма хэширования.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-409">In this approach, you can divide the data evenly across servers by using a hashing mechanism.</span></span> <span data-ttu-id="1e0a7-410">На каждом сервере Redis хранятся метаданные, описывающие диапазон содержащихся в секции хэш-ключей, а также сведения о хэш-ключах, которые находятся в секциях на других серверах.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-410">Each Redis server stores metadata that describes the range of hash keys that the partition holds, and also contains information about which hash keys are located in the partitions on other servers.</span></span>

<span data-ttu-id="1e0a7-411">Клиентские приложения просто отправляют запросы на любой сервер-участник Redis (скорее всего, на ближайший).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-411">Client applications simply send requests to any of the participating Redis servers (probably the closest one).</span></span> <span data-ttu-id="1e0a7-412">Сервер Redis проверяет запрос клиента.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-412">The Redis server examines the client request.</span></span> <span data-ttu-id="1e0a7-413">Если его можно разрешить локально, сервер выполняет запрошенную операцию.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-413">If it can be resolved locally, it performs the requested operation.</span></span> <span data-ttu-id="1e0a7-414">В противном случае он перенаправляет запрос на соответствующий сервер.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-414">Otherwise it forwards the request on to the appropriate server.</span></span>

<span data-ttu-id="1e0a7-415">Эта модель реализуется с помощью кластеризации Redis и более подробно описана на странице [Учебник по кластерам Redis] на веб-сайте Redis.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-415">This model is implemented by using Redis clustering, and is described in more detail on the [Redis cluster tutorial] page on the Redis website.</span></span> <span data-ttu-id="1e0a7-416">Кластеризация Redis прозрачна для клиентских приложений.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-416">Redis clustering is transparent to client applications.</span></span> <span data-ttu-id="1e0a7-417">В кластер можно добавлять дополнительные серверы Redis (а также повторно секционировать данные) без необходимости перенастройки клиентов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-417">Additional Redis servers can be added to the cluster (and the data can be re-partitioned) without requiring that you reconfigure the clients.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="1e0a7-418">Кэш Redis для Azure в настоящее время не поддерживает кластеризацию Redis.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-418">Azure Redis Cache does not currently support Redis clustering.</span></span> <span data-ttu-id="1e0a7-419">Если вы хотите реализовать такой подход с Azure, необходимо сначала реализовать собственные серверы Redis, установив Redis на набор виртуальных машин Azure и настроив их вручную.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-419">If you want to implement this approach with Azure, then you must implement your own Redis servers by installing Redis on a set of Azure virtual machines and configuring them manually.</span></span> <span data-ttu-id="1e0a7-420">В статье [Запуск Redis на виртуальной машине CentOS Linux в Azure] (Запуск Redis на виртуальной машине CentOS Linux в Azure) показано, как создать и настроить узел Redis, запущенный в качестве виртуальной машины Azure.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-420">The page [Running Redis on a CentOS Linux VM in Azure] walks through an example that shows you how to build and configure a Redis node running as an Azure VM.</span></span>

<span data-ttu-id="1e0a7-421">Дополнительные сведения о реализации секционирования с помощью Redis см. на странице [Секционирование: распределение данных между несколькими экземплярами Redis] (Секционирование: распределение данных между несколькими экземплярами Redis) на веб-сайте Redis.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-421">The page [Partitioning: how to split data among multiple Redis instances] on the Redis website provides more information about implementing partitioning with Redis.</span></span> <span data-ttu-id="1e0a7-422">В оставшейся части этого раздела предполагается, что вы реализуете секционирование на стороне клиента или через прокси-сервер.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-422">The remainder of this section assumes that you are implementing client-side or proxy-assisted partitioning.</span></span>

<span data-ttu-id="1e0a7-423">При выборе способа секционирования данных с помощью кэша Redis для Azure учитывайте следующие моменты.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-423">Consider the following points when deciding how to partition data with Azure Redis Cache:</span></span>

- <span data-ttu-id="1e0a7-424">Кэш Redis для Azure не предназначен для работы в качестве постоянного хранилища данных, поэтому, какую бы схему секционирования вы ни выбрали, код приложения должен быть готов извлекать данные из источника, не являющегося кэшем.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-424">Azure Redis Cache is not intended to act as a permanent data store, so whatever partitioning scheme you implement, your application code must be able to retrieve data from a location that's not the cache.</span></span>

- <span data-ttu-id="1e0a7-425">Часто используемые данные необходимо размещать в одной секции.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-425">Data that is frequently accessed together should be kept in the same partition.</span></span> <span data-ttu-id="1e0a7-426">Redis — это эффективное хранилище типа ключ-значение, которое предоставляет несколько значительно оптимизированных механизмов для структурирования данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-426">Redis is a powerful key-value store that provides several highly optimized mechanisms for structuring data.</span></span> <span data-ttu-id="1e0a7-427">Механизмы могут быть следующими:</span><span class="sxs-lookup"><span data-stu-id="1e0a7-427">These mechanisms can be one of the following:</span></span>
  - <span data-ttu-id="1e0a7-428">простые строки (двоичные данные длиной до 512 МБ);</span><span class="sxs-lookup"><span data-stu-id="1e0a7-428">Simple strings (binary data up to 512 MB in length)</span></span>
  - <span data-ttu-id="1e0a7-429">агрегатные типы, такие как списки (которые могут выступать в качестве очередей и стеков);</span><span class="sxs-lookup"><span data-stu-id="1e0a7-429">Aggregate types such as lists (which can act as queues and stacks)</span></span>
  - <span data-ttu-id="1e0a7-430">наборы (упорядоченные и неупорядоченные);</span><span class="sxs-lookup"><span data-stu-id="1e0a7-430">Sets (ordered and unordered)</span></span>
  - <span data-ttu-id="1e0a7-431">хэши (которые могут группировать связанные поля, например элементы, представляющие поля в объекте).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-431">Hashes (which can group related fields together, such as the items that represent the fields in an object)</span></span>

- <span data-ttu-id="1e0a7-432">Агрегатные типы позволяют связывать несколько взаимосвязанных значений с одним ключом.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-432">The aggregate types enable you to associate many related values with the same key.</span></span> <span data-ttu-id="1e0a7-433">Ключ Redis определяет список, набор или хэш, а не элементы данных, которые он содержит.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-433">A Redis key identifies a list, set, or hash rather than the data items that it contains.</span></span> <span data-ttu-id="1e0a7-434">Все эти типы доступны в кэше Redis для Azure и описаны на странице [Data types] (Типы данных) на веб-сайте Redis.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-434">These types are all available with Azure Redis Cache and are described by the [Data types] page on the Redis website.</span></span> <span data-ttu-id="1e0a7-435">Например, в части системы электронной коммерции, отслеживающей размещенные клиентами заказы, подробные сведения о каждом клиенте могут храниться в хэше Redis, зашифрованном с помощью идентификатора клиента.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-435">For example, in part of an e-commerce system that tracks the orders that are placed by customers, the details of each customer can be stored in a Redis hash that is keyed by using the customer ID.</span></span> <span data-ttu-id="1e0a7-436">Каждый хэш может содержать коллекцию идентификаторов заказов клиента.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-436">Each hash can hold a collection of order IDs for the customer.</span></span> <span data-ttu-id="1e0a7-437">Отдельный набор Redis может содержать заказы, опять же структурированные как хэши, зашифрованные с помощью идентификатора заказа.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-437">A separate Redis set can hold the orders, again structured as hashes, and keyed by using the order ID.</span></span> <span data-ttu-id="1e0a7-438">Эта структура показана на рис. 8.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-438">Figure 8 shows this structure.</span></span> <span data-ttu-id="1e0a7-439">Обратите внимание, что Redis не реализует какую-либо форму целостности данных, поэтому разработчик сам должен обеспечить связь между клиентами и заказами.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-439">Note that Redis does not implement any form of referential integrity, so it is the developer's responsibility to maintain the relationships between customers and orders.</span></span>

![Предлагаемая структура в хранилище Redis для записи заказов клиентов и сведений о них](./images/data-partitioning/RedisCustomersandOrders.png)

<span data-ttu-id="1e0a7-441">*Рис. 8. Предлагаемая структура в хранилище Redis для записи заказов клиентов и сведений о них*.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-441">*Figure 8. Suggested structure in Redis storage for recording customer orders and their details.*</span></span>

> [!NOTE]
> <span data-ttu-id="1e0a7-442">В Redis все ключи являются значениями двоичных данных (например строки Redis) и могут содержать до 512 МБ данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-442">In Redis, all keys are binary data values (like Redis strings) and can contain up to 512 MB of data.</span></span> <span data-ttu-id="1e0a7-443">В теории ключ может содержать почти любую информацию.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-443">In theory, a key can contain almost any information.</span></span> <span data-ttu-id="1e0a7-444">Однако рекомендуется использовать согласованный контекст именования ключей, согласно которому имя должно описывать тип данных и определять сущность, но не быть слишком длинным.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-444">However, we recommend adopting a consistent naming convention for keys that is descriptive of the type of data and that identifies the entity, but is not excessively long.</span></span> <span data-ttu-id="1e0a7-445">Распространенный подход — использовать ключи в формате "entity_type: ID".</span><span class="sxs-lookup"><span data-stu-id="1e0a7-445">A common approach is to use keys of the form "entity_type:ID".</span></span> <span data-ttu-id="1e0a7-446">Например, можно использовать "customer: 99", чтобы указать ключ для клиента с идентификатором 99.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-446">For example, you can use "customer:99" to indicate the key for a customer with the ID 99.</span></span>

- <span data-ttu-id="1e0a7-447">Можно реализовать вертикальное секционирование, сохраняя связанные сведения в различных агрегатах в одной базе данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-447">You can implement vertical partitioning by storing related information in different aggregations in the same database.</span></span> <span data-ttu-id="1e0a7-448">Например, в приложении электронной коммерции можно хранить часто используемые сведения о продуктах в одном хэше Redis, а реже используемые сведения — в другом.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-448">For example, in an e-commerce application, you can store commonly accessed information about products in one Redis hash and less frequently used detailed information in another.</span></span> <span data-ttu-id="1e0a7-449">Оба хэша могут использовать один и тот же идентификатор продукта как часть ключа.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-449">Both hashes can use the same product ID as part of the key.</span></span> <span data-ttu-id="1e0a7-450">Например, product:*nn* (где *nn* — идентификатор продукта) для сведений о продукте и product_details: *nn* для подробного описания.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-450">For example, you can use "product: *nn*" (where *nn* is the product ID) for the product information and "product_details: *nn*" for the detailed data.</span></span> <span data-ttu-id="1e0a7-451">Эта стратегия позволяет сократить объем данных, к которым обращается большинство запросов.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-451">This strategy can help reduce the volume of data that most queries are likely to retrieve.</span></span>

- <span data-ttu-id="1e0a7-452">Перераспределение хранилища данных Redis является сложной задачей, которая требует много времени.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-452">You can repartition a Redis data store, but keep in mind that it's a complex and time-consuming task.</span></span> <span data-ttu-id="1e0a7-453">Кластеризация Redis может секционировать данные автоматически, но эта возможность не поддерживается в кэше Redis для Azure.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-453">Redis clustering can repartition data automatically, but this capability is not available with Azure Redis Cache.</span></span> <span data-ttu-id="1e0a7-454">Таким образом, при разработке схемы секционирования попытайтесь оставить достаточно свободного места в каждой секции, чтобы учесть ожидаемый со временем рост данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-454">Therefore, when you design your partitioning scheme, try to leave sufficient free space in each partition to allow for expected data growth over time.</span></span> <span data-ttu-id="1e0a7-455">Однако помните, что кэш Redis для Azure предназначен для временного кэширования данных, а также что у данных, хранящихся в кэше, может быть ограниченное время существования, указанное как значение срока жизни (TTL).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-455">However, remember that Azure Redis Cache is intended to cache data temporarily, and that data held in the cache can have a limited lifetime specified as a time-to-live (TTL) value.</span></span> <span data-ttu-id="1e0a7-456">Для относительно временных данных значение TTL должно быть коротким, но для статических данных значение TTL может быть гораздо большим.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-456">For relatively volatile data, the TTL can be short, but for static data the TTL can be a lot longer.</span></span> <span data-ttu-id="1e0a7-457">Не следует хранить большие объемы долгоживущих данных в кэше, если эти данные, скорее всего, переполнят кэш.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-457">Avoid storing large amounts of long-lived data in the cache if the volume of this data is likely to fill the cache.</span></span> <span data-ttu-id="1e0a7-458">Можно указать политику вытеснения, согласно которой кэш Redis для Azure будет удалять данные, если места осталось мало.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-458">You can specify an eviction policy that causes Azure Redis Cache to remove data if space is at a premium.</span></span>

  > [!NOTE]
  > <span data-ttu-id="1e0a7-459">При использовании кэша Redis для Azure вы указываете максимальный размер кэша (от 250 МБ до 53 ГБ), выбирая соответствующую ценовую категорию.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-459">When you use Azure Redis cache, you specify the maximum size of the cache (from 250 MB to 53 GB) by selecting the appropriate pricing tier.</span></span> <span data-ttu-id="1e0a7-460">Однако после создания кэша Redis для Azure нельзя увеличить (или уменьшить) его размер.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-460">However, after an Azure Redis Cache has been created, you cannot increase (or decrease) its size.</span></span>

- <span data-ttu-id="1e0a7-461">Пакеты и транзакции Redis не могут охватывать несколько подключений, поэтому все данные, затрагиваемые пакетом или транзакцией, должны храниться в одной базе данных (в одном сегменте).</span><span class="sxs-lookup"><span data-stu-id="1e0a7-461">Redis batches and transactions cannot span multiple connections, so all data that is affected by a batch or transaction should be held in the same database (shard).</span></span>

  > [!NOTE]
  > <span data-ttu-id="1e0a7-462">Последовательность операций в транзакции Redis не обязательно является неделимой.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-462">A sequence of operations in a Redis transaction is not necessarily atomic.</span></span> <span data-ttu-id="1e0a7-463">Команды, которые составляют транзакцию, проверяются и добавляются в очередь перед выполнением.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-463">The commands that compose a transaction are verified and queued before they run.</span></span> <span data-ttu-id="1e0a7-464">Если на этом этапе возникает ошибка, вся очередь удаляется.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-464">If an error occurs during this phase, the entire queue is discarded.</span></span> <span data-ttu-id="1e0a7-465">Однако после успешной отправки транзакции команды в очереди будут выполняться последовательно.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-465">However, after the transaction has been successfully submitted, the queued commands run in sequence.</span></span> <span data-ttu-id="1e0a7-466">Если какая-либо из команд завершается ошибкой, прерывается только эта команда.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-466">If any command fails, only that command stops running.</span></span> <span data-ttu-id="1e0a7-467">Все предыдущие и последующие команды выполняются по очереди.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-467">All previous and subsequent commands in the queue are performed.</span></span> <span data-ttu-id="1e0a7-468">Дополнительные сведения см. на странице [Транзакции] (Транзакции) на веб-сайте Redis.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-468">For more information, go to the [Transactions] page on the Redis website.</span></span>

- <span data-ttu-id="1e0a7-469">Redis поддерживает ограниченное число атомарных операций.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-469">Redis supports a limited number of atomic operations.</span></span> <span data-ttu-id="1e0a7-470">Единственными операциями такого типа, которые поддерживают несколько ключей, являются MGET и MSET.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-470">The only operations of this type that support multiple keys and values are MGET and MSET operations.</span></span> <span data-ttu-id="1e0a7-471">Операции MGET возвращают коллекцию значений для указанного списка ключей, а операции MSET сохраняют коллекцию значений для указанного списка ключей.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-471">MGET operations return a collection of values for a specified list of keys, and MSET operations store a collection of values for a specified list of keys.</span></span> <span data-ttu-id="1e0a7-472">Если необходимо использовать эти операции, пары ключ-значение, на которые ссылаются команды MSET и MGET, должны храниться в той же базе данных.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-472">If you need to use these operations, the key-value pairs that are referenced by the MSET and MGET commands must be stored within the same database.</span></span>

## <a name="partitioning-azure-service-fabric"></a><span data-ttu-id="1e0a7-473">Секционирование Azure Service Fabric</span><span class="sxs-lookup"><span data-stu-id="1e0a7-473">Partitioning Azure Service Fabric</span></span>

<span data-ttu-id="1e0a7-474">Azure Service Fabric — это платформа микрослужб, которая предоставляет в облаке среду выполнения для распределенных приложений.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-474">Azure Service Fabric is a microservices platform that provides a runtime for distributed applications in the cloud.</span></span> <span data-ttu-id="1e0a7-475">Service Fabric поддерживает гостевые исполняемые файлы .NET, службы с отслеживанием состояния и без, а также контейнеры.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-475">Service Fabric supports .Net guest executables, stateful and stateless services, and containers.</span></span> <span data-ttu-id="1e0a7-476">Службы с отслеживанием состояния предоставляют [надежные коллекции][service-fabric-reliable-collections] для долгосрочного хранения данных в формате "ключ — значение" в кластере Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-476">Stateful services provide a [reliable collection][service-fabric-reliable-collections] to persistently store data in a key-value collection within the Service Fabric cluster.</span></span> <span data-ttu-id="1e0a7-477">Дополнительные сведения об использовании ключей сегментирования в надежной коллекции см. в [Инструкции и рекомендации по использованию надежных коллекций в Azure Service Fabric].</span><span class="sxs-lookup"><span data-stu-id="1e0a7-477">For more information about strategies for partitioning keys in a reliable collection, see [guidelines and recommendations for reliable collections in Azure Service Fabric].</span></span>

### <a name="more-information"></a><span data-ttu-id="1e0a7-478">Дополнительные сведения</span><span class="sxs-lookup"><span data-stu-id="1e0a7-478">More information</span></span>

- <span data-ttu-id="1e0a7-479">В статье [Общие сведения о Service Fabric] содержится обзор службы Azure Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-479">[Overview of Azure Service Fabric] is an introduction to Azure Service Fabric.</span></span>

- <span data-ttu-id="1e0a7-480">В статье [Секционирование служб Reliable Services в Service Fabric] содержатся дополнительные сведения о надежных службах в Azure Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-480">[Partition Service Fabric reliable services] provides more information about reliable services in Azure Service Fabric.</span></span>

## <a name="partitioning-azure-event-hubs"></a><span data-ttu-id="1e0a7-481">Секционирование Центров событий Azure</span><span class="sxs-lookup"><span data-stu-id="1e0a7-481">Partitioning Azure Event Hubs</span></span>

<span data-ttu-id="1e0a7-482">[Центры событий Azure][event-hubs] предназначены для потоковой передачи данных в больших объемах. В них реализована встроенная поддержка секционирования, которая обеспечивает горизонтальное масштабирование.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-482">[Azure Event Hubs][event-hubs] is designed for data streaming at massive scale, and partitioning is built into the service to enable horizontal scaling.</span></span> <span data-ttu-id="1e0a7-483">Каждый потребитель считывает только определенный раздел потока сообщений.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-483">Each consumer only reads a specific partition of the message stream.</span></span>

<span data-ttu-id="1e0a7-484">Издателю событий известен только ключ секции, но не сама секция, в которой публикуются события.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-484">The event publisher is only aware of its partition key, not the partition to which the events are published.</span></span> <span data-ttu-id="1e0a7-485">Благодаря разделению ключа и секции отправителю не нужно располагать избыточными сведениями о последующей обработке и хранении событий.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-485">This decoupling of key and partition insulates the sender from needing to know too much about the downstream processing.</span></span> <span data-ttu-id="1e0a7-486">(Также есть возможность отправлять события напрямую в определенную секцию, но обычно так делать не следует.)</span><span class="sxs-lookup"><span data-stu-id="1e0a7-486">(It's also possible send events directly to a given partition, but generally that's not recommended.)</span></span>  

<span data-ttu-id="1e0a7-487">Выбирать число секций следует с учетом долгосрочной перспективы.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-487">Consider long-term scale when you select the partition count.</span></span> <span data-ttu-id="1e0a7-488">Создав концентратор событий, вы уже не сможете изменить число секций.</span><span class="sxs-lookup"><span data-stu-id="1e0a7-488">After an event hub is created, you can't change the number of partitions.</span></span>

<span data-ttu-id="1e0a7-489">Дополнительные сведения об использовании секций в Центрах событий см. в статье [Что такое Центры событий?]</span><span class="sxs-lookup"><span data-stu-id="1e0a7-489">For more information about using partitions in Event Hubs, see [What is Event Hubs?].</span></span>

<span data-ttu-id="1e0a7-490">См. также дополнительные сведения о [Доступность и согласованность в Центрах событий].</span><span class="sxs-lookup"><span data-stu-id="1e0a7-490">For considerations about trade-offs between availability and consistency, see [Availability and consistency in Event Hubs].</span></span>

[Доступность и согласованность в Центрах событий]: /azure/event-hubs/event-hubs-availability-and-consistency
[Availability and consistency in Event Hubs]: /azure/event-hubs/event-hubs-availability-and-consistency
[azure-limits]: /azure/azure-subscription-service-limits
[Azure Content Delivery Network]: /azure/cdn/cdn-overview
[кэш Azure Redis]: https://azure.microsoft.com/services/cache/
[Azure Redis Cache]: https://azure.microsoft.com/services/cache/
[Azure Storage Scalability and Performance Targets]: /azure/storage/storage-scalability-targets
[Azure Storage Table Design Guide]: /azure/storage/storage-table-design-guide
[Building a Polyglot Solution]: https://msdn.microsoft.com/library/dn313279.aspx
[cosmos-db-ru]: /azure/cosmos-db/request-units
[Data Access for Highly-Scalable Solutions: Using SQL, NoSQL, and Polyglot Persistence]: https://msdn.microsoft.com/library/dn271399.aspx
[Data consistency primer]: https://aka.ms/Data-Consistency-Primer
[Data Partitioning Guidance]: https://msdn.microsoft.com/library/dn589795.aspx
[Data Types]: https://redis.io/topics/data-types
[cosmosdb-sql-api]: /azure/cosmos-db/sql-api-introduction
[Elastic Database features overview]: /azure/sql-database/sql-database-elastic-scale-introduction
[event-hubs]: /azure/event-hubs
[Federations Migration Utility]: https://code.msdn.microsoft.com/vstudio/Federations-Migration-ce61e9c1
[Инструкции и рекомендации по использованию надежных коллекций в Azure Service Fabric]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[guidelines and recommendations for reliable collections in Azure Service Fabric]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[Multi-shard querying]: /azure/sql-database/sql-database-elastic-scale-multishard-querying
[Общие сведения о Service Fabric]: /azure/service-fabric/service-fabric-overview
[Overview of Azure Service Fabric]: /azure/service-fabric/service-fabric-overview
[Секционирование служб Reliable Services в Service Fabric]: /azure/service-fabric/service-fabric-concepts-partitioning
[Partition Service Fabric reliable services]: /azure/service-fabric/service-fabric-concepts-partitioning
[Секционирование: распределение данных между несколькими экземплярами Redis]: https://redis.io/topics/partitioning
[Partitioning: how to split data among multiple Redis instances]: https://redis.io/topics/partitioning
[Performing Entity Group Transactions]: /rest/api/storageservices/Performing-Entity-Group-Transactions
[Учебник по кластерам Redis]: https://redis.io/topics/cluster-tutorial
[Redis cluster tutorial]: https://redis.io/topics/cluster-tutorial
[Запуск Redis на виртуальной машине CentOS Linux в Azure]: https://blogs.msdn.microsoft.com/tconte/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure/
[Running Redis on a CentOS Linux VM in Azure]: https://blogs.msdn.microsoft.com/tconte/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure/
[Scaling using the Elastic Database split-merge tool]: /azure/sql-database/sql-database-elastic-scale-overview-split-and-merge
[Using Azure Content Delivery Network]: /azure/cdn/cdn-create-new-endpoint
[Квоты на служебную шину]: /azure/service-bus-messaging/service-bus-quotas
[Service Bus quotas]: /azure/service-bus-messaging/service-bus-quotas
[service-fabric-reliable-collections]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections
[Ограничения поиска Azure]:  /azure/search/search-limits-quotas-capacity
[Service limits in Azure Search]:  /azure/search/search-limits-quotas-capacity
[Sharding pattern]: ../patterns/sharding.md
[Поддерживаемые типы данных (служба поиска Azure)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[Supported Data Types (Azure Search)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[Транзакции]: https://redis.io/topics/transactions
[Transactions]: https://redis.io/topics/transactions
[Что такое Центры событий?]: /azure/event-hubs/event-hubs-what-is-event-hubs
[What is Event Hubs?]: /azure/event-hubs/event-hubs-what-is-event-hubs
[Что такое поиск Azure?]: /azure/search/search-what-is-azure-search
[What is Azure Search?]: /azure/search/search-what-is-azure-search
[What is Azure SQL Database?]: /azure/sql-database/sql-database-technical-overview
[Целевые показатели масштабируемости]: /azure/storage/common/storage-scalability-targets
[scalability targets]: /azure/storage/common/storage-scalability-targets
